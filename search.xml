<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux基础</title>
    <url>/2021/01/17/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>2020.11.18-2020.12.20</p>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-vim的基本使用"><a href="#1-vim的基本使用" class="headerlink" title="1.vim的基本使用"></a>1.<code>vim</code>的基本使用</h2><a id="more"></a>

<blockquote>
<p><code>pwd</code>        (print working directory)</p>
<p><code>$0whoamiaptapt </code></p>
<p><code>updateapt</code> </p>
<p><code>upgrade</code><br><code>apt-cache search XXX</code>        (搜索XXX软件)<br><code>apt remove XXX</code>        (卸载XXX软件)<br><code>dpkg -i xxx.dep</code>        (使用dpkg程序安装xxx.dep)(安装 = install -&gt; -i)<br><code>dpkg -r</code>         (使用dpkg卸载软件)(卸载 = remove -&gt; -r)</p>
</blockquote>
<h2 id="2-Terminal"><a href="#2-Terminal" class="headerlink" title="2.Terminal"></a>2.<code>Terminal</code></h2><p>终端<code>( terminal )= tty </code>(Teletypewriter， 电传打印机)，作用是提供一个命令的输入输出环 境，在<code>linux</code>操作系统下使用组合键 <code>ctrl + alt + T</code> 打开的就是终端，可以认为 <code>terminal</code> 和 <code>tty </code>是 同义词。</p>
<h2 id="3-shell"><a href="#3-shell" class="headerlink" title="3.shell"></a>3.<code>shell</code></h2><p><code>shell</code>是一种人机交互的接口。 <code>shell</code> 有壳的意思，是指 “提供使用者使用界面” 的软件，是一种 命令解析器,是<code>Linux</code>内核的一个壳，负责外界与Linux内核的交互。</p>
<blockquote>
<p><code>windows</code> 的cmd就是一种<code>shell</code>。所以 <code>shell</code> 并不只是指命令语言<code>-Bash/Zsh</code>。 其实GUI本身也是一种<code>shell</code>.</p>
</blockquote>
<p>用户在 <code>shell</code> 中提交命令， <code>shell</code> 负责接收用户的命令，并扮演命令解析器的⻆色。 </p>
<p>当你打开一个 <code>Terminal</code> 时，操作系统会将 Terminal 和 Shell 关联起来，当我们在 <code>Terminal</code> 中输入命令的时候， <code>Shell</code> 就负责解释命令。</p>
<h2 id="3、命令"><a href="#3、命令" class="headerlink" title="3、命令"></a>3、命令</h2><blockquote>
<p>命令是人和计算机交互的基本单位，人使用命令 将要做什么事传达给计算机，计算机做出解 析，并做出回应。</p>
</blockquote>
<p><strong>命令也有自己的语法结构</strong>:</p>
<p>和人说话一样，命令的主要结构也可以看做为主谓宾的简单句和复杂句，在命令中，省略主语</p>
<blockquote>
<p>举个例子</p>
</blockquote>
<p><code>cp(谓语动词) fileA(宾语) fileB(宾语)</code></p>
<p> <code>cp(谓语动词) -ar(方式状语) fileA(宾语) fileB(宾语)</code></p>
<p><strong>命令细节</strong></p>
<blockquote>
<p>Linux命令由以下几个部分组成: 命令名 ， 分隔符 ， 选项 和 操作对象 组成。 </p>
</blockquote>
<p><strong>命令名</strong></p>
<p>命令名标识了命令的功能，如cp，rm，mv，rename，fdisk等等，都能很轻易的看出该命令的功能， 还有一些命令，有二级子命令，如apt-get install | remove，install和remove就是apt-get的子命令。</p>
<p><strong>分隔符</strong></p>
<p>  分隔符通常为空格，连续的多个空格会被视为一个空格。</p>
<blockquote>
<p>一些特殊的符号也属于分隔符，例如管道<code>|</code>，重定向<code>&gt;,&lt;&lt;,&lt;,&gt;&gt;,</code>后台运行<code>&amp;</code>，序列执行<code>&amp;&amp;```、;</code>都 是特殊的分隔符，在使用这些特殊符号的时候，不需要额外加空格，但为了使命令更易读，通常会 加上空格。</p>
</blockquote>
<p><strong>选项</strong></p>
<ul>
<li>命令的选项通常用 <code>-</code> 连接，通常为一个字母，是选项的首字母。大多数命令都可以使用 <code>-h</code> 来 查看该命令的帮助。</li>
<li>命令的选项也可以使用 <code>--</code> 来引导，接的是选项的全程，效果与—连接单个字母是一样的。</li>
</ul>
<p><strong>操作对象</strong></p>
<p>   操作对象为该命令动作的承受着。</p>
<p><strong>格式约定</strong></p>
<ul>
<li>使用 <code>[]</code> 来标记可以选择的选项</li>
<li>使用 <code>|</code> 来表示不能同时使用的参数 </li>
<li>选项通常紧跟命令名，当然，在很多时候我们可以省略命令的选项而使用默认参数</li>
</ul>
<h2 id="4-程序与进程"><a href="#4-程序与进程" class="headerlink" title="4.程序与进程"></a><strong>4.程序与进程</strong></h2><blockquote>
<p>那么什么是程序呢?</p>
<blockquote>
<p> 计算机程序是指一组指示计算机执行动作或做出判断的指令，通常用某种程序设计语言<br> 编写，运行于某种目标体系结构上。</p>
</blockquote>
</blockquote>
<blockquote>
<p>什么又是进程呢?</p>
<blockquote>
<p>进程是程序在内存中的镜像。</p>
</blockquote>
</blockquote>
<h2 id="5-路径"><a href="#5-路径" class="headerlink" title="5.路径"></a>5.路径</h2><p><strong>绝对路径</strong></p>
<p>​    绝对路径的起始点为根目录 <code>/</code> ,例如 <code>/usr/bin/cp</code> 就是一个绝对路径。</p>
<p><strong>相对路径</strong> </p>
<p>​    相对路径的起始点为当前路径 <code>.</code> ，假如用户当前目录为 <code>/home/apricity/</code> ，那么同样的文件 <code>cp</code> ,其 相对路径为 <code>../../usr/bin/cp</code> 。</p>
<p><strong>远程路径</strong></p>
<blockquote>
<p>在很多时候，我们会需要访问本机之外的资源，这个时候远程路径就有了用武之地了。</p>
</blockquote>
<p>远程路径的一般表示方法为: <code>协议://用户名:密码@位置/路径:端口</code> 比如: <a href="http://baidu.com/">http://baidu.com</a></p>
<p>​    <code>ftp://user:passwd@ftp.baidu.com:21</code><br>  远程路径根据应用的不同，具体表示方法和所需要的参数都不太一致，从以上两个远程路径就可以<br>看出。</p>
<p><strong>路径相关的命令</strong></p>
<blockquote>
<p><code>cd</code> #change directory</p>
</blockquote>
<blockquote>
<p><code>ls</code> #list<br><code>pwd</code> #print working directory</p>
</blockquote>
<p><strong>特殊路径</strong></p>
<blockquote>
<p><code>~</code> 家目录<br><code>-</code> 上次工作目录</p>
</blockquote>
<h2 id="6-软件"><a href="#6-软件" class="headerlink" title="6.软件"></a><strong>6.软件</strong></h2><p>通常，一个软件包含的内容会分别被拷⻉到同级别的 <code>bin lib share</code> 和 <code>/etc</code> 目录下。</p>
<blockquote>
<p><code>bin</code> 存放程序的可执行文件。在系统环境变量中将该路径添加进去，就可以直接执行程序. </p>
<p><code>lib</code> 库文件集中存放，方便共享。<br><code>share</code> 存放程序需要的其他资源.<br><code>/etc</code> 配置文件存放路径，大部分的程序的配置文件都可以在这个路径下找到</p>
</blockquote>
<h2 id="7-配置方式"><a href="#7-配置方式" class="headerlink" title="7.配置方式"></a>7.<strong>配置方式</strong></h2><blockquote>
<p><code>/etc/network/interface</code> 文件为Ubuntu的网络配置文件，通过修改该文件，并重启网络， 就可以实现网络的配置工作。</p>
</blockquote>
<p>直接使用ifconfig命令来直接修改网络配置:</p>
<p><code>ifconfig eth0 172.17.211.175</code></p>
<p>这条命令将把设备<code> eth0</code> 的<code>ip</code>地址更新为 <code>172.17.211.175</code> 。</p>
<h2 id="8-隐藏文件"><a href="#8-隐藏文件" class="headerlink" title="8.隐藏文件"></a>8.隐藏文件</h2><p>Linux的隐藏文件都是以<code> .</code> 开头的，也就是说所有以 <code>.</code> 开头的文件都会被系统识别为隐藏文件。</p>
<p>使用<code> ls</code> 命令添加 <code>a</code> 选项，就可以显示隐藏文件。 这里有两个特殊的目录 <code>.</code> 和<code> ..</code> ,分别为当前目录和父目录。</p>
<h2 id="9-文件类型"><a href="#9-文件类型" class="headerlink" title="9.文件类型"></a>9.文件类型</h2><p>使用 <code>ll</code> 命令可以查看当前文件夹下所有文件的详细信息。</p>
<blockquote>
<p><code>ll</code> 等效于 <code>ls -al</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apricity@qiu ~ % ll                                                                                                                                                           [0]</span><br><span class="line">total 40K</span><br><span class="line">-rw-rw-r-- 1 apricity apricity    0 Nov 22 16:39 aaa.txt</span><br><span class="line">drwxrwxr-x 7 apricity apricity 4.0K Nov 20 19:08 autojump</span><br><span class="line">drwxrwxr-x 2 apricity apricity 4.0K Nov 25 11:34 C语言</span><br><span class="line">drwxrwxr-x 3 apricity apricity 4.0K Nov 19 14:42 guziqiu</span><br><span class="line">drwxrwxr-x 2 apricity apricity 4.0K Nov 20 19:33 haizei_oj</span><br><span class="line">-rw-rw-r-- 1 apricity apricity 8.3K May 25  2020 install_zsh.sh</span><br><span class="line">drwxrwxr-x 4 apricity apricity 4.0K Nov 22 14:10 linux基础</span><br><span class="line">drwxrwxr-x 2 apricity apricity 4.0K Nov 22 20:46 <span class="built_in">test</span></span><br><span class="line">-rw-rw-r-- 1 apricity apricity    0 Nov 12 01:14 update</span><br><span class="line">drwxrwxr-x 7 apricity apricity 4.0K Nov 12 00:49 zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>
<p>​        <strong>该命令主要输出了七列内容，分别为:权限、文件数、所属用户、所属群组、文件大小、常⻅日</strong><br><strong>期、文件名。</strong><br>          <strong>第一列权限，主要可以分为以下四个部分:文件类型，所属用户权限，所属组权限，其他用户权</strong><br><strong>限</strong>。</p>
<blockquote>
<p>以刚才执行<code>ll</code>的结果中的 <code>../</code> 目录的权限为例:</p>
<table>
<thead>
<tr>
<th align="center">文件类型</th>
<th align="center">所属用户权限</th>
<th align="center">所属群组权限</th>
<th align="center">其他用户权限</th>
</tr>
</thead>
<tbody><tr>
<td align="center">d</td>
<td align="center">rwx</td>
<td align="center">r-x</td>
<td align="center">r-x</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li><p>第一部分文件类型为 d ,代表这个文件是一个目录(directory)，目录是一种特殊的文件; </p>
</li>
<li><p>第二部分所属用户权限为 rwx ，代表该文件拥有者拥有可读(read),可写(write),可执行(execute) 的权限;</p>
</li>
<li><p>第三部分所属群组权限为 r-x ，代表与该文件拥有者在一个群组的用户具有可读，可执行的权 限，在这里<code> -</code> 顶替了<code>w</code>的位置，代表没有写权限; </p>
</li>
<li><p>第四部分其他用户权限同样为可读，可执行。</p>
</li>
</ul>
<blockquote>
<p><code>rwx</code> 的顺序是固定的!</p>
</blockquote>
<p>Linux中的文件类型除了目录 d 之外，总共有7种文件类型，</p>
<ul>
<li><code>-</code> regular file 普通文件</li>
<li><code>d</code> directory目录 </li>
<li><code>l</code> link链接</li>
<li><code>b</code>  block 块设备 存储数据以供系统存取的接口设备，也就是硬盘</li>
<li><code>c</code>   character 字符设备 串口设备，键盘，鼠标等</li>
<li><code>s</code> socket套接字<code>//应用层和底层的接口</code></li>
<li><code>p</code> pipe管道</li>
</ul>
<p>对于普通文件又可以分为以下三种:</p>
<ul>
<li><p>纯文本文件</p>
<p>​        纯文本文件使用<code>ASCII</code>编码，这是<code>Linux</code>系统中最常⻅的一种文件类型，之所以成为纯文本文件，是因 为这种类型的文件是我们可以直接读取的内容，在<code>Linux</code>，几乎所有的配置文件都属于这种类型。</p>
</li>
<li><p>二进制文件 </p>
<p>​        二进制文件是系统中的可执行文件(不包括脚本)，计算机只能认识并执行二进制文件。二进制文件不能使用 <code>cat</code> 等命令直接读出。 </p>
</li>
<li><p>数据格式的文件</p>
<p>在一些程序运行过程中，需要读取特定格式的文件，这种文件被称为数据文件(data file)。这种文件 通常也不能使用<code>cat</code>命令读出。 例如: <code>/var/log/wtmp</code> 文件。</p>
</li>
</ul>
<blockquote>
<p>使用<code>ll</code>命令查看文件，可以看到该文件为普通文件   <code>ll</code> == <code>ls -l</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ll /var/<span class="built_in">log</span>/wtmp</span><br><span class="line"></span><br><span class="line">&gt;-rw-rw-r-- 1 root utmp 8832 Apr 27 11:50 /var/<span class="built_in">log</span>/wtmp</span><br></pre></td></tr></table></figure>

<p>使用file命令查看问价详情，返回为 <code>data</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;file /var/<span class="built_in">log</span>/wtmp</span><br><span class="line">&gt;/var/<span class="built_in">log</span>/wtmp: data</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="10-文件权限"><a href="#10-文件权限" class="headerlink" title="10.文件权限"></a>10.文件权限</h2><p>​        </p>
<blockquote>
<p>文件的权限包含三组( <code>u</code> 用户，<code> g</code> 群组，<code> o</code> 其他用户)，每一组又都包含 三组具体的权限(<code>r</code>读，<code>w</code>写，<code>x</code>执行)。    </p>
</blockquote>
<p>​            对于文件权限，我们也可以用下面的方式来表示:</p>
<table>
<thead>
<tr>
<th align="center">r</th>
<th align="center">w</th>
<th align="center">x</th>
<th align="center">r</th>
<th align="center">w</th>
<th align="center">x</th>
<th align="center">r</th>
<th align="center">w</th>
<th align="center">x</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(2^2) 4</td>
<td align="center">(2^1) 2</td>
<td align="center">(2^0) 1</td>
<td align="center">(2^2) 4</td>
<td align="center">(2^1) 2</td>
<td align="center">(2^0) 1</td>
<td align="center">(2^2) 4</td>
<td align="center">(2^1) 2</td>
<td align="center">(2^0) 1</td>
</tr>
</tbody></table>
<p>也就是权限的每一组都由三个十进制的数字表示，该组的的权限就可以简单的用着三个十进制的数</p>
<p>字相加得到。</p>
<blockquote>
<p>一个权限为<code> rwxr-xr-x</code> 的文件，则它的权限可以使用 <code>755</code> 来表示。</p>
</blockquote>
<h2 id="11-与文件权限有关的命令"><a href="#11-与文件权限有关的命令" class="headerlink" title="11.与文件权限有关的命令"></a>11.<strong>与文件权限有关的命令</strong></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod <span class="comment">#更改文件权限 </span></span><br><span class="line">chown <span class="comment">#更改文件所属用户 </span></span><br><span class="line">chgrp <span class="comment">#更改文件所属组</span></span><br></pre></td></tr></table></figure>


<ul>
<li>chmod 的用法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod a+x file <span class="comment">#给file文件的ugo都赋予执行的权限</span></span><br><span class="line">chmod o-x file <span class="comment">#将file文件o减去执行权限</span></span><br><span class="line">chmod 755 file <span class="comment">#设置file文件的权限为rwxr-xr-x</span></span><br><span class="line">chmod u=rwx,go=rx file <span class="comment">#设置file文件的权限为rwxr-xr-x</span></span><br></pre></td></tr></table></figure>


<ul>
<li>chown 的用法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown guziqiu:apricity file <span class="comment">#修改file的所属用户是guziqiu,所属组为apricity</span></span><br><span class="line"> chown -R guziqiu:apricity directory </span><br><span class="line"> <span class="comment">#修改目录directory及目录下的所有文件的所属用户是guziqiu， 所属组为zpricity</span></span><br><span class="line"> chown guziqiu file <span class="comment">#修改file的所属用户为guziqiu</span></span><br></pre></td></tr></table></figure>


<ul>
<li>chgrp 的用法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chgrp root file <span class="comment">#修改file所属的组为root</span></span><br></pre></td></tr></table></figure>


<h2 id="12-用户"><a href="#12-用户" class="headerlink" title="12.用户"></a>12.用户</h2><blockquote>
<p><code>Linux</code>有两类用户,分别是 <code>root</code> 和 <code>普通用户</code> 。</p>
</blockquote>
<ul>
<li><p>超级管理员: <code>root</code></p>
<p><code>root</code> 拥有系统的完全控制权，所以在使用<code>Linux</code>系统的时候，需要慎重使用<code>root</code>用户，更多的自由 与权限同样也意味着更大的⻛险。</p>
</li>
<li><p>普通用户</p>
<p>普通用户拥有的权限就没有 <code>root</code> 用户那么大了，它只能做系统允许做的事。普通用户可以执行大 部分的命令，但是<code>root</code>专有的命令却不能执行。</p>
</li>
</ul>
<p>可以使用 su 命令来切换用户:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:~$ whoami</span><br><span class="line">guziqiu</span><br><span class="line">:~$ su - root</span><br><span class="line">Password:</span><br><span class="line">:~<span class="comment"># whoami</span></span><br><span class="line">root</span><br><span class="line">:~<span class="comment"># su - guziqiu</span></span><br><span class="line">:~$ whoami</span><br><span class="line">guziqiu</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>su - guziqiu</code></p>
<p><code>-</code>代表一次完整的重新登录</p>
</blockquote>
<p>退出</p>
<p><code>control +D</code></p>
<p><code>exit </code></p>
<p><code>logout</code></p>
<h2 id="13-其他命令"><a href="#13-其他命令" class="headerlink" title="13.其他命令"></a>13.其他命令</h2><p><code>id</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apricity@qiu ~ % id                                                                                                                                                 [0]</span><br><span class="line">uid=1000(apricity) gid=1000(apricity) groups=1000(apricity),27(sudo)</span><br><span class="line">//用户，组，其他组</span><br></pre></td></tr></table></figure>




<p>1.火车动画</p>
<p>​    <code>sl</code></p>
<p>2.<code>apt-build moo</code> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-build moo </span><br><span class="line"></span><br><span class="line">         (__)    ~</span><br><span class="line">         (oo)   /</span><br><span class="line">     _____\/___/</span><br><span class="line">    /  /\ / /</span><br><span class="line">   ~  /  * /</span><br><span class="line">     / ___/</span><br><span class="line">*----/\</span><br><span class="line">    /  \</span><br><span class="line">   /   /</span><br><span class="line">  ~    ~</span><br><span class="line">...<span class="string">&quot;Have you danced today? Discow!&quot;</span>...</span><br></pre></td></tr></table></figure>


<p>3.cowsay</p>
<p>用ASCII字符打印牛，羊等动物，还有个cowthink，这个是奶牛想，那个是奶牛说，哈哈，差不多</p>
<p><code>sudo apt-get install cowsay</code></p>
<p><code>cowsay -f tux &quot;坑爹啊&quot;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">________</span><br><span class="line">&lt; 坑爹啊 &gt;</span><br><span class="line"> --------</span><br><span class="line">   \</span><br><span class="line">    \</span><br><span class="line">        .--.</span><br><span class="line">       |o_o |</span><br><span class="line">       |:_/ |</span><br><span class="line">      //   \ \</span><br><span class="line">     (|     | )</span><br><span class="line">    /&#x27;\_   _/`\</span><br><span class="line">    \___)=(___/</span><br></pre></td></tr></table></figure>


<ol start="4">
<li><code>cmatrix</code> 命令</li>
</ol>
<p>这个很酷！《黑客帝国》那种矩阵风格的动画效果</p>
<p> <code>sudo apt-get install cmatrix</code></p>
<p><code>cmatrix</code></p>
<p><code>q</code>退出</p>
<h1 id="二、命令系统"><a href="#二、命令系统" class="headerlink" title="二、命令系统"></a>二、命令系统</h1><p>shell、termial、console</p>
<blockquote>
<p>shell是一种命令解析器，它给用户提供了一个输入命令并接受机器返回结果的界面。</p>
</blockquote>
<p>console控制台，一般console只能有一个</p>
<p>terminal,它是一个封装程序，一个terminal运行一个shell来扩充为一个具备shell功能的的程序。</p>
<blockquote>
<p>console 和 terminal的概念都源自大型机，console可以看作为一个特殊的terminal。现在用的一般都是引申义，一般情况下可以混用。</p>
</blockquote>
<p>命令返回值含义</p>
<p>[0]如果为 0，则表示命令执行成功，其它值则表示错误，</p>
<p>[1]Operation not permitted</p>
<p>[2]No such file or directory</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;OS error code   1:  Operation not permitted&quot;</span><br><span class="line"> &quot;OS error code   2:  No such file or directory&quot;</span><br><span class="line"> &quot;OS error code   3:  No such process&quot;</span><br><span class="line"> &quot;OS error code   4:  Interrupted system call&quot;</span><br><span class="line"> &quot;OS error code   5:  Input/output error&quot;</span><br><span class="line"> &quot;OS error code   6:  No such device or address&quot;</span><br><span class="line"> &quot;OS error code   7:  Argument list too long&quot;</span><br><span class="line"> &quot;OS error code   8:  Exec format error&quot;</span><br><span class="line"> &quot;OS error code   9:  Bad file descriptor&quot;</span><br><span class="line"> &quot;OS error code  10:  No child processes&quot;</span><br><span class="line"> &quot;OS error code  11:  Resource temporarily unavailable&quot;</span><br><span class="line"> &quot;OS error code  12:  Cannot allocate memory&quot;</span><br><span class="line"> &quot;OS error code  13:  Permission denied&quot;</span><br><span class="line"> &quot;OS error code  14:  Bad address&quot;</span><br><span class="line"> &quot;OS error code  15:  Block device required&quot;</span><br><span class="line"> &quot;OS error code  16:  Device or resource busy&quot;</span><br><span class="line"> &quot;OS error code  17:  File exists&quot;</span><br><span class="line"> &quot;OS error code  18:  Invalid cross-device link&quot;</span><br><span class="line"> &quot;OS error code  19:  No such device&quot;</span><br><span class="line"> &quot;OS error code  20:  Not a directory&quot;</span><br><span class="line"> &quot;OS error code  21:  Is a directory&quot;</span><br><span class="line"> &quot;OS error code  22:  Invalid argument&quot;</span><br><span class="line"> &quot;OS error code  23:  Too many open files in system&quot;</span><br><span class="line"> &quot;OS error code  24:  Too many open files&quot;</span><br><span class="line"> &quot;OS error code  25:  Inappropriate ioctl for device&quot;</span><br><span class="line"> &quot;OS error code  26:  Text file busy&quot;</span><br><span class="line"> &quot;OS error code  27:  File too large&quot;</span><br><span class="line"> &quot;OS error code  28:  No space left on device&quot;</span><br><span class="line"> &quot;OS error code  29:  Illegal seek&quot;</span><br><span class="line"> &quot;OS error code  30:  Read-only file system&quot;</span><br><span class="line"> &quot;OS error code  31:  Too many links&quot;</span><br><span class="line"> &quot;OS error code  32:  Broken pipe&quot;</span><br><span class="line"> &quot;OS error code  33:  Numerical argument out of domain&quot;</span><br><span class="line"> &quot;OS error code  34:  Numerical result out of range&quot;</span><br><span class="line"> &quot;OS error code  35:  Resource deadlock avoided&quot;</span><br><span class="line"> &quot;OS error code  36:  File name too long&quot;</span><br><span class="line"> &quot;OS error code  37:  No locks available&quot;</span><br><span class="line"> &quot;OS error code  38:  Function not implemented&quot;</span><br><span class="line"> &quot;OS error code  39:  Directory not empty&quot;</span><br><span class="line"> &quot;OS error code  40:  Too many levels of symbolic links&quot;</span><br><span class="line"> &quot;OS error code  42:  No message of desired type&quot;</span><br><span class="line"> &quot;OS error code  43:  Identifier removed&quot;</span><br><span class="line"> &quot;OS error code  44:  Channel number out of range&quot;</span><br><span class="line"> &quot;OS error code  45:  Level 2 not synchronized&quot;</span><br><span class="line"> &quot;OS error code  46:  Level 3 halted&quot;</span><br><span class="line"> &quot;OS error code  47:  Level 3 reset&quot;</span><br><span class="line"> &quot;OS error code  48:  Link number out of range&quot;</span><br><span class="line"> &quot;OS error code  49:  Protocol driver not attached&quot;</span><br><span class="line"> &quot;OS error code  50:  No CSI structure available&quot;</span><br><span class="line"> &quot;OS error code  51:  Level 2 halted&quot;</span><br><span class="line"> &quot;OS error code  52:  Invalid exchange&quot;</span><br><span class="line"> &quot;OS error code  53:  Invalid request descriptor&quot;</span><br><span class="line"> &quot;OS error code  54:  Exchange full&quot;</span><br><span class="line"> &quot;OS error code  55:  No anode&quot;</span><br><span class="line"> &quot;OS error code  56:  Invalid request code&quot;</span><br><span class="line"> &quot;OS error code  57:  Invalid slot&quot;</span><br><span class="line"> &quot;OS error code  59:  Bad font file format&quot;</span><br><span class="line"> &quot;OS error code  60:  Device not a stream&quot;</span><br><span class="line"> &quot;OS error code  61:  No data available&quot;</span><br><span class="line"> &quot;OS error code  62:  Timer expired&quot;</span><br><span class="line"> &quot;OS error code  63:  Out of streams resources&quot;</span><br><span class="line"> &quot;OS error code  64:  Machine is not on the network&quot;</span><br><span class="line"> &quot;OS error code  65:  Package not installed&quot;</span><br><span class="line"> &quot;OS error code  66:  Object is remote&quot;</span><br><span class="line"> &quot;OS error code  67:  Link has been severed&quot;</span><br><span class="line"> &quot;OS error code  68:  Advertise error&quot;</span><br><span class="line"> &quot;OS error code  69:  Srmount error&quot;</span><br><span class="line"> &quot;OS error code  70:  Communication error on send&quot;</span><br><span class="line"> &quot;OS error code  71:  Protocol error&quot;</span><br><span class="line"> &quot;OS error code  72:  Multihop attempted&quot;</span><br><span class="line"> &quot;OS error code  73:  RFS specific error&quot;</span><br><span class="line"> &quot;OS error code  74:  Bad message&quot;</span><br><span class="line"> &quot;OS error code  75:  Value too large for defined data type&quot;</span><br><span class="line"> &quot;OS error code  76:  Name not unique on network&quot;</span><br><span class="line"> &quot;OS error code  77:  File descriptor in bad state&quot;</span><br><span class="line"> &quot;OS error code  78:  Remote address changed&quot;</span><br><span class="line"> &quot;OS error code  79:  Can not access a needed shared library&quot;</span><br><span class="line"> &quot;OS error code  80:  Accessing a corrupted shared library&quot;</span><br><span class="line"> &quot;OS error code  81:  .lib section in a.out corrupted&quot;</span><br><span class="line"> &quot;OS error code  82:  Attempting to link in too many shared libraries&quot;</span><br><span class="line"> &quot;OS error code  83:  Cannot exec a shared library directly&quot;</span><br><span class="line"> &quot;OS error code  84:  Invalid or incomplete multibyte or wide character&quot;</span><br><span class="line"> &quot;OS error code  85:  Interrupted system call should be restarted&quot;</span><br><span class="line"> &quot;OS error code  86:  Streams pipe error&quot;</span><br><span class="line"> &quot;OS error code  87:  Too many users&quot;</span><br><span class="line"> &quot;OS error code  88:  Socket operation on non-socket&quot;</span><br><span class="line"> &quot;OS error code  89:  Destination address required&quot;</span><br><span class="line"> &quot;OS error code  90:  Message too long&quot;</span><br><span class="line"> &quot;OS error code  91:  Protocol wrong type for socket&quot;</span><br><span class="line"> &quot;OS error code  92:  Protocol not available&quot;</span><br><span class="line"> &quot;OS error code  93:  Protocol not supported&quot;</span><br><span class="line"> &quot;OS error code  94:  Socket type not supported&quot;</span><br><span class="line"> &quot;OS error code  95:  Operation not supported&quot;</span><br><span class="line"> &quot;OS error code  96:  Protocol family not supported&quot;</span><br><span class="line"> &quot;OS error code  97:  Address family not supported by protocol&quot;</span><br><span class="line"> &quot;OS error code  98:  Address already in use&quot;</span><br><span class="line"> &quot;OS error code  99:  Cannot assign requested address&quot;</span><br><span class="line"> &quot;OS error code 100:  Network is down&quot;</span><br><span class="line"> &quot;OS error code 101:  Network is unreachable&quot;</span><br><span class="line"> &quot;OS error code 102:  Network dropped connection on reset&quot;</span><br><span class="line"> &quot;OS error code 103:  Software caused connection abort&quot;</span><br><span class="line"> &quot;OS error code 104:  Connection reset by peer&quot;</span><br><span class="line"> &quot;OS error code 105:  No buffer space available&quot;</span><br><span class="line"> &quot;OS error code 106:  Transport endpoint is already connected&quot;</span><br><span class="line"> &quot;OS error code 107:  Transport endpoint is not connected&quot;</span><br><span class="line"> &quot;OS error code 108:  Cannot send after transport endpoint shutdown&quot;</span><br><span class="line"> &quot;OS error code 109:  Too many references: cannot splice&quot;</span><br><span class="line"> &quot;OS error code 110:  Connection timed out&quot;</span><br><span class="line"> &quot;OS error code 111:  Connection refused&quot;</span><br><span class="line"> &quot;OS error code 112:  Host is down&quot;</span><br><span class="line"> &quot;OS error code 113:  No route to host&quot;</span><br><span class="line"> &quot;OS error code 114:  Operation already in progress&quot;</span><br><span class="line"> &quot;OS error code 115:  Operation now in progress&quot;</span><br><span class="line"> &quot;OS error code 116:  Stale NFS file handle&quot;</span><br><span class="line"> &quot;OS error code 117:  Structure needs cleaning&quot;</span><br><span class="line"> &quot;OS error code 118:  Not a XENIX named type file&quot;</span><br><span class="line"> &quot;OS error code 119:  No XENIX semaphores available&quot;</span><br><span class="line"> &quot;OS error code 120:  Is a named type file&quot;</span><br><span class="line"> &quot;OS error code 121:  Remote I/O error&quot;</span><br><span class="line"> &quot;OS error code 122:  Disk quota exceeded&quot;</span><br><span class="line"> &quot;OS error code 123:  No medium found&quot;</span><br><span class="line"> &quot;OS error code 124:  Wrong medium type&quot;</span><br><span class="line"> &quot;OS error code 125:  Operation canceled&quot;</span><br><span class="line"> &quot;OS error code 126:  Required key not available&quot;</span><br><span class="line"> &quot;OS error code 127:  Key has expired&quot;</span><br><span class="line"> &quot;OS error code 128:  Key has been revoked&quot;</span><br><span class="line"> &quot;OS error code 129:  Key was rejected by service&quot;</span><br><span class="line"> &quot;OS error code 130:  Owner died&quot;</span><br><span class="line"> &quot;OS error code 131:  State not recoverable&quot;</span><br></pre></td></tr></table></figure>


<h2 id="1-Linux帮助系统"><a href="#1-Linux帮助系统" class="headerlink" title="1.Linux帮助系统"></a>1.Linux帮助系统</h2><p><code>man</code>手册</p>
<p><code>man ls</code></p>
<p><code>ls(1)ls</code>第一部分</p>
<p><code>user commands</code> 所属部分：用户命令</p>
<p><code>info</code>手册</p>
<p><code>ls --time =atime -l</code> </p>
<p><code>man scanf</code></p>
<p><code>linux porgrammer&#39;s manual</code>：所属部分:系统开发者</p>
<blockquote>
<p>在学习使用Linux的时候，我们会遇到很多以前没有用过的命令和功能，这个时候最好的解决办法就是求助于<strong>man</strong>.</p>
</blockquote>
<p><code>man</code>的使用方法很简单，例如查看<code>ls</code>的帮助手册，可以直接使用命令<code>man ls</code>即可查看<code>ls</code>的命令帮助。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LS(1)                                       User Commands                                LS(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NAME  <span class="comment">#命令全名，简单的说明及用法</span></span><br><span class="line">       ls - list directory contents</span><br><span class="line"></span><br><span class="line">SYNOPSIS <span class="comment">#基本语法</span></span><br><span class="line">       ls [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION <span class="comment">#详细说明语法中参数的用法</span></span><br><span class="line">       List information about the FILEs (the current directory by default).  Sort entries alphabeti‐</span><br><span class="line">       cally <span class="keyword">if</span> none of -cftuvSUX nor --sort is specified.</span><br><span class="line"></span><br><span class="line">       Mandatory arguments to long options are mandatory <span class="keyword">for</span> short options too.</span><br><span class="line"></span><br><span class="line">       -a, --all</span><br><span class="line">              <span class="keyword">do</span> not ignore entries starting with .</span><br><span class="line"></span><br><span class="line">       -A, --almost-all</span><br><span class="line">              <span class="keyword">do</span> not list implied . and ..</span><br><span class="line"></span><br><span class="line">       --author</span><br><span class="line">              with -l, <span class="built_in">print</span> the author of each file</span><br><span class="line"> <span class="comment">#中间省略</span></span><br><span class="line">       -1     list one file per line</span><br><span class="line"></span><br><span class="line">       --<span class="built_in">help</span> display this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">       --version</span><br><span class="line">              output version information and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">       SIZE  may be (or may be an <span class="built_in">integer</span> optionally followed by) one of following: KB 1000, K 1024,</span><br><span class="line">       MB 1000*1000, M 1024*1024, and so on <span class="keyword">for</span> G, T, P, E, Z, Y.</span><br><span class="line"></span><br><span class="line">       Using color to distinguish file types is disabled both by  default  and  with  --color=never.</span><br><span class="line">       With --color=auto, ls emits color codes only when standard output is connected to a terminal.</span><br><span class="line">       The LS_COLORS environment variable can change the settings.  Use the dircolors <span class="built_in">command</span> to <span class="built_in">set</span></span><br><span class="line">       it.</span><br><span class="line"></span><br><span class="line">   Exit status: <span class="comment">#错误返回值</span></span><br><span class="line">       0      <span class="keyword">if</span> OK,</span><br><span class="line"></span><br><span class="line">       1      <span class="keyword">if</span> minor problems (e.g., cannot access subdirectory),</span><br><span class="line"></span><br><span class="line">       2      <span class="keyword">if</span> serious trouble (e.g., cannot access command-line argument).</span><br><span class="line"></span><br><span class="line">AUTHOR  <span class="comment">#作者</span></span><br><span class="line">       Written by Richard M. Stallman and David MacKenzie.</span><br><span class="line"></span><br><span class="line">REPORTING BUGS <span class="comment">#bug提交联系方式</span></span><br><span class="line">       Report ls bugs to bug-coreutils@gnu.org</span><br><span class="line">       GNU coreutils home page: &lt;http://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">       General <span class="built_in">help</span> using GNU software: &lt;http://www.gnu.org/gethelp/&gt;</span><br><span class="line">       Report ls translation bugs to &lt;http://translationproject.org/team/&gt;</span><br><span class="line"></span><br><span class="line">COPYRIGHT  <span class="comment">#版权保护</span></span><br><span class="line">       Copyright  ©  2011 Free Software Foundation, Inc.  License GPLv3+: GNU GPL version 3 or later</span><br><span class="line">       &lt;http://gnu.org/licenses/gpl.html&gt;.</span><br><span class="line">       This is free software: you are free to change and redistribute it.  There is NO WARRANTY,  to</span><br><span class="line">       the extent permitted by law.</span><br><span class="line"></span><br><span class="line">SEE ALSO <span class="comment">##在哪里可以看到更多关于该命令的文档</span></span><br><span class="line">       The full documentation <span class="keyword">for</span> ls is maintained as a Texinfo manual.  If the info and ls programs</span><br><span class="line">       are properly installed at your site, the <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line">              info coreutils <span class="string">&#x27;ls invocation&#x27;</span></span><br><span class="line"></span><br><span class="line">       should give you access to the complete manual.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GNU coreutils 8.12.197-032bb               September 2011                                      LS(1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>眼尖的同学应该注意到了手册中开头和结尾的地方写的<code>LS(1)</code>了，那么这是什么意思呢？它代表的是一般用户可使用的命令。</p>
</blockquote>
<p>在man中，常见的几个数字的含义如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">代号</th>
<th align="left">代表的含义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">用户在shell环境下可以操作的命令或可执行文件</td>
<td><code>man 1 ls</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">系统内核可调用的函数和工具</td>
<td><code>man 2 reboot</code></td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">一些常用的函数与函数库，大部分C的函数库</td>
<td><code>man 3 readdir</code></td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">设备文件的说明，通常是在<code>/dev</code>下的设备</td>
<td><code>man 4 null</code></td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">配置文件或某些文件的格式</td>
<td><code>man 5 interfaces</code></td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">游戏</td>
<td><code>man 6 lol</code> 😂</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">惯例与协议等，例如Linux文件系统，网络协议等</td>
<td><code>man 7 tcp</code></td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">系统管理员可用的命令</td>
<td><code>man 8 reboot</code></td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">跟kernel有关的文件</td>
<td></td>
</tr>
<tr>
<td align="center">o</td>
<td align="left">旧文档</td>
<td></td>
</tr>
<tr>
<td align="center">n</td>
<td align="left">新文档</td>
<td></td>
</tr>
<tr>
<td align="center">l</td>
<td align="left">本地文档</td>
<td></td>
</tr>
</tbody></table>
<p>在man手册中，我们可以用到的快捷键如下：</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+f(orward)</td>
<td>向下翻一页</td>
<td>Ctrl+d(own)</td>
<td>向下翻半页</td>
</tr>
<tr>
<td>Ctrl+b(ackward)</td>
<td>向上翻一页</td>
<td>Ctrl+u(p)</td>
<td>向上翻半页</td>
</tr>
<tr>
<td>/</td>
<td>查找</td>
<td>q(uit)</td>
<td>退出</td>
</tr>
</tbody></table>
<p>随堂练习：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man -f            #whatis</span><br><span class="line">man -k            #apropos</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Linux中还有一种在线求助的方式<code>info</code>,有兴趣的可以了解一下。</p>
</blockquote>
<h2 id="2-linux常用命令"><a href="#2-linux常用命令" class="headerlink" title="2.linux常用命令"></a>2.linux常用命令</h2><p>1.文件及目录相关，文件内容的修改与查看</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code>查看目录下内容</td>
<td><code>cd</code>目录跳转</td>
</tr>
<tr>
<td><code>pwd</code>打印工作目录</td>
<td><code>cp</code>拷贝</td>
</tr>
<tr>
<td><code>mv</code>移动文件及目录</td>
<td><code>rm</code>删除文件及目录</td>
</tr>
<tr>
<td><code>mkdir</code>创建目录</td>
<td><code>tree</code>打印目录树</td>
</tr>
<tr>
<td><code>tar</code>文件归档与压缩</td>
<td><code>ln</code>创建链接文件</td>
</tr>
<tr>
<td><code>touch</code>创建空白文件</td>
<td><code>head</code>查看文件头部</td>
</tr>
<tr>
<td><code>cat</code>查看文件内容</td>
<td>tail查看文件尾部</td>
</tr>
<tr>
<td><code>vim</code>文本编辑器</td>
<td><code>diff</code>对比文件</td>
</tr>
<tr>
<td><code>echo</code>打印文本</td>
<td><code>grep</code>检索信息</td>
</tr>
<tr>
<td><code>more</code>分页查看文件</td>
<td><code>wc</code>计数</td>
</tr>
<tr>
<td><code>less</code>分页查看文件</td>
<td><code>find</code>查找文件</td>
</tr>
<tr>
<td><code>which</code>查找可执行文件</td>
<td><code>whereis</code>查找可执行、源码、帮助手册</td>
</tr>
<tr>
<td><code>locate</code>定位任何文件</td>
<td></td>
</tr>
</tbody></table>
<p>2.用户相关命令，进程相关命令</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>useradd</code>新建用户</td>
<td><code>chgrp</code>修改所属组</td>
</tr>
<tr>
<td><code>userdel</code>删除用户</td>
<td><code>chmod</code>修改文件权限</td>
</tr>
<tr>
<td><code>usermod</code>修改用户</td>
<td><code>chown</code>修改文件所属用户</td>
</tr>
<tr>
<td><code>passwd</code>修改密码</td>
<td><code>logout</code>退出用户</td>
</tr>
<tr>
<td><code>su</code>切换用户</td>
<td><code>exit</code>退出用户</td>
</tr>
<tr>
<td><code>sudo</code>获取管理员权限</td>
<td></td>
</tr>
<tr>
<td><code>ps</code>打印进程</td>
<td><code>ctrl+z</code>挂起前台任务</td>
</tr>
<tr>
<td><code>kill</code>杀死进程</td>
<td><code>fg</code>将进程调至前台运行</td>
</tr>
<tr>
<td><code>pkill</code>批量杀死进程</td>
<td><code>bg</code>让挂起的进程后台执行</td>
</tr>
<tr>
<td><code>killall</code>批量杀死进程</td>
<td><code>jobs</code>查看挂起和后台进程</td>
</tr>
<tr>
<td><code>crotab</code>定时任务</td>
<td></td>
</tr>
</tbody></table>
<p>3.系统信息命令获取</p>
<table>
<thead>
<tr>
<th><code>date</code> 查看时间</th>
<th><code>dstat</code>查看系统信息</th>
</tr>
</thead>
<tbody><tr>
<td><code>df</code>查看文件系统</td>
<td><code>nmon</code>查看系统信息</td>
</tr>
<tr>
<td><code>du</code>获取目录文件大小</td>
<td><code>ifconfig</code>查看IP信息</td>
</tr>
<tr>
<td><code>free</code>查看内存</td>
<td><code>uname</code>查看OS信息</td>
</tr>
<tr>
<td><code>top</code>查看系统信息</td>
<td><code>last</code>查看最近登录</td>
</tr>
<tr>
<td><code>htop</code>查看系统信息</td>
<td><code>who</code>查看当前登录</td>
</tr>
</tbody></table>
<p>4.其他命令</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>ssh</code>远程连接</td>
<td><code>poweroff</code>关机</td>
</tr>
<tr>
<td><code>scp</code>远程拷贝</td>
<td><code>reboot</code>重启</td>
</tr>
<tr>
<td><code>wget</code>获取<code>http</code>文件</td>
<td></td>
</tr>
<tr>
<td><code>ping</code>测试远程主机</td>
<td></td>
</tr>
</tbody></table>
<h1 id="三、zsh"><a href="#三、zsh" class="headerlink" title="三、zsh"></a>三、zsh</h1><h3 id="1-通配符"><a href="#1-通配符" class="headerlink" title="1.通配符"></a>1.通配符</h3><ul>
<li><p>？</p>
<p>代表<strong>单个任意字符</strong></p>
</li>
<li><p>*</p>
<p>代表<strong>任意几个任意字符</strong></p>
</li>
</ul>
<blockquote>
<p>请看下面的例子，并自己动手尝试一下通配符的使用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">suyelu@HaiZei-Tech:~$ ls</span><br><span class="line">a.log  code  HaiZei  helloworld  你好world</span><br><span class="line">suyelu@HaiZei-Tech:~$ ls *ld</span><br><span class="line">helloworld  你好world</span><br><span class="line">suyelu@HaiZei-Tech:~$ ls ??world</span><br><span class="line">你好world</span><br><span class="line">suyelu@HaiZei-Tech:~$ ls ?????world</span><br><span class="line">helloworld</span><br><span class="line">suyelu@HaiZei-Tech:~$</span><br></pre></td></tr></table></figure>
<p>除了*<strong>**和</strong>?**这两个通配符之外，Linux中还有下面几种通配符</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>[list]</td>
<td>匹配list中的任意单一字符</td>
<td>a[xyz]b  a与b之间有且只有一个字符, 且只能是x或y或z, 如: axb, ayb, azb。</td>
</tr>
<tr>
<td>[!list]</td>
<td>匹配除list中的任意单一字符</td>
<td>a[!0-9]b  a与b之间有且只有一个字符, 但不能是数字, 如axb, aab, a-b等</td>
</tr>
<tr>
<td>[c1-c2]</td>
<td>匹配c1-c2中的任意单一字符</td>
<td>a[0-9]b  a与b之间有且只有一个字符，该字符是0-9之间的数字，如a0b, a1b，… ，a9b。</td>
</tr>
<tr>
<td>{string1,string2,…}</td>
<td>匹配 sring1 或 string2 (或更多)其一字符串</td>
<td>a{abc,xyz,123}b    a与b之间只能是abc或xyz或123这三个字符串之一。</td>
</tr>
</tbody></table>
<h3 id="2-任务管理"><a href="#2-任务管理" class="headerlink" title="2.任务管理"></a>2.任务管理</h3><p><code>PATH=$&#123;PATH&#125;:.</code></p>
<p>locate</p>
<p>1.<code>&amp;</code></p>
<p>在命令的后面加上**<code>&amp;</code>**表示后台执行的意思</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command &amp;</span><br></pre></td></tr></table></figure>


<p>2.<code>;</code></p>
<p>在命令之间以**<code>;</code>**相连，表示顺序执行的意思</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command1;command2</span><br></pre></td></tr></table></figure>
<p>3.<strong><code>&amp;&amp;</code></strong></p>
<p>命令之间以**<code>&amp;&amp;</code>**相连时，只有第一个命令成功执行，第二个命令才会执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command1 &amp;&amp; command2</span><br></pre></td></tr></table></figure>


<p>4.<strong><code>||</code></strong></p>
<p>命令之间以**<code>||</code>**相连时，如果前一个命令执行失败，则执行第二个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command1 || command2</span><br></pre></td></tr></table></figure>
<p>5.<strong><code>``</code></strong></p>
<p>命令中如果包含另一个命令，则用符号**<code>** 将它包括起来，在执行的时候系统将优先执行**</code>**中的子命令，然后将其结果代入父命令继续执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command1 `command2`</span><br></pre></td></tr></table></figure>
<p>6.<strong><code>ctrl + z</code></strong></p>
<p>在shell中执行命令时，同时按下**<code>ctrl + z</code>**可以将暂时挂起</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">suyelu@HaiZei-Tech:~$ vim helloworld.c</span><br><span class="line"></span><br><span class="line">[1]+  Stopped                 vim helloworld.c</span><br><span class="line">suyelu@HaiZei-Tech:~$</span><br></pre></td></tr></table></figure>
<blockquote>
<p>什么是挂起？</p>
</blockquote>
<ol start="7">
<li><p><strong><code>bg</code></strong></p>
<p>执行**<code>bg</code>**命令，可以将挂起的命令后台运行</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">suyelu@HaiZei-Tech:~$ vim helloworld.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[1]+  Stopped                 vim helloworld.c</span><br><span class="line">suyelu@HaiZei-Tech:~$ bg</span><br><span class="line">[1]+ vim helloworld.c &amp;</span><br><span class="line">suyelu@HaiZei-Tech:~$</span><br></pre></td></tr></table></figure>


<ol start="8">
<li><p><strong><code>fg</code></strong></p>
<p>执行命令**<code>fg</code>**可以将后台执行的命令转为前台执行</p>
</li>
<li><p><strong><code>jobs</code></strong></p>
<p>在Linux系统中，执行**<code>jobs</code>**命令可以查看所有在后台执行和挂起的任务以及任务编号</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">suyelu@HaiZei-Tech:~/code$ jobs</span><br><span class="line">[1]-  Stopped                 vim a.c  (wd: ~)</span><br><span class="line">[2]+  Stopped                 vim b.c  (wd: ~)</span><br><span class="line">[3]   Running                 ./a.out &amp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>尝试执行<strong>fg</strong>和<strong>bg</strong>加上任务编号，看看是什么效果</p>
</blockquote>
<p>%没有输入换行符zsh输出一个%座位标记</p>
<p>/tmp零时文件夹</p>
<p>BIOS：开机检测</p>
<blockquote>
<p>检测硬件环境</p>
<p>Boot Loader读内核文件</p>
<p>/sbin/init 启动进程</p>
<p>加载磁盘</p>
</blockquote>
<p>guziqiu: x :</p>
<p>x代表密码占位符</p>
<h3 id="3-管道、重定向"><a href="#3-管道、重定向" class="headerlink" title="3.管道、重定向"></a>3.管道、重定向</h3><ol>
<li><p><code>&gt;</code></p>
<p>重定向符</p>
</li>
<li><p><code>&gt;&gt;</code></p>
<p>作用于**&gt;<strong>基本相同，不同的是</strong>&gt;&gt;<strong>将内容追加到文件的末尾，而</strong>&gt;**内容覆盖原文件</p>
</li>
<li><p><code>&lt;</code></p>
<p>与**&gt;**刚好相反，是从文件到命令的重定向。它将文件的内容输出到命令作为输入</p>
</li>
<li><p><code>&lt;&lt;</code> 标记文件结尾</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; &#x2F;etc&#x2F;sysconfig&#x2F;network &lt;&lt; EOF</span><br><span class="line">HOSTNAME&#x3D;$HOST_NAME</span><br><span class="line">EOF </span><br></pre></td></tr></table></figure>
<h3 id="4-转义符"><a href="#4-转义符" class="headerlink" title="4.转义符"></a>4.转义符</h3><blockquote>
<p>在Linux中转义符**<code>\</code><strong>的应用十分广泛，除此之外，转义符还包括</strong>“”<strong>和</strong>‘’**。</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>‘’</td>
<td>硬转义,硬引用，其内部所有的shell元字符、通配符都会被关掉。注意，硬转义中不允许出现’(单引号)。</td>
</tr>
<tr>
<td>“”</td>
<td>软转义，软引用，其内部只允许出现特定的shell元字符($,`,\)：$用于变量值替换、`用于命令替换、\用于转义单个字符</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠，转义，去除其后紧跟的元字符或通配符的特殊意义。</td>
</tr>
</tbody></table>
<p>下表是部分转义字符对应表：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>\\</td>
<td>代表一个反斜线字符’’&#39;</td>
<td>092</td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NULL)</td>
<td>000</td>
</tr>
<tr>
<td>\nnn</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td>\xnnn</td>
<td>1到3位十六进制所代表的任意字符</td>
<td>三位十六进制</td>
</tr>
</tbody></table>
<h4 id="转义符在Shell中的应用"><a href="#转义符在Shell中的应用" class="headerlink" title="转义符在Shell中的应用"></a>转义符在Shell中的应用</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">suyelu@HaiZei-Tech:~$ echo -e &quot;\044&quot;</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="bash">suyelu@HaiZei-Tech:~$ <span class="built_in">echo</span>  <span class="string">&quot;\044&quot;</span></span></span><br><span class="line">\044</span><br><span class="line">suyelu@HaiZei-Tech:~$ echo  $&#x27;\044&#x27;</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="bash">suyelu@HaiZei-Tech:~$ <span class="built_in">echo</span>  $<span class="string">&#x27;\44&#x27;</span></span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>




<h2 id="附录1-Shell元字符"><a href="#附录1-Shell元字符" class="headerlink" title="附录1 Shell元字符"></a>附录1 Shell元字符</h2><blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>变量名=值，为变量赋值。注意=左右紧跟变量名和值，中间不要有空格</td>
</tr>
<tr>
<td>``</td>
<td>取命令的执行结果，与下文的$有相似之处</td>
</tr>
<tr>
<td>$</td>
<td>变量值替换，$变量名替换为shell变量的值;为避免在文本连接时混淆，请使用${变量名};$0…$9 代表shell文件的参数。**$()<strong>同``;</strong>${}<strong>限定变量名的范围；</strong>$[]**整数计算；</td>
</tr>
<tr>
<td>&gt;</td>
<td>prog &gt; file 将标准输出重定向到文件。</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>prog &gt;&gt; file 将标准输出追加到文件。</td>
</tr>
<tr>
<td>&lt;</td>
<td>prog &lt; file 从文件file中获取标准输入</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td></td>
</tr>
<tr>
<td>|</td>
<td>管道命令，例：p1 | p2 将p1的标准输出作为p2的标准输入</td>
</tr>
<tr>
<td>&amp;</td>
<td>后台运行命令，最大好处是无需等待命令执行结束，就可以在同一命令行下继续输入命令</td>
</tr>
<tr>
<td>()</td>
<td>在子shell中执行命令,在子进程中执行</td>
</tr>
<tr>
<td>{}</td>
<td>在当前shell中执行命令，或用在变量替换的界定范围(例如上面的${变量名}用法)。</td>
</tr>
<tr>
<td>[]</td>
<td>字符通配，匹配括号内之一</td>
</tr>
<tr>
<td>;</td>
<td>命令结束符。例如p1;p2表示先执行p1,再执行p2</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>前一个命令执行成功后，才继续执行下一个命令。例：p1 &amp;&amp; p2 ;若p1执行成功后，才执行p2,反之，不执行p2;</td>
</tr>
<tr>
<td>||</td>
<td>前一个命令执行失败后，才继续执行下一个命令。例：p1 || p2 ;若p1执行成功后，不执行p2,反之，才执行p2;</td>
</tr>
<tr>
<td>!</td>
<td>执行历史记录中的命令**!731**;匹配最近的一次命令**!echo**;取非<strong>ls /dev/sda[!1]</strong>;结果取反**! echo ok ;echo $?**</td>
</tr>
<tr>
<td>%</td>
<td><strong>% 1</strong>相当于<strong>fg 1</strong></td>
</tr>
<tr>
<td>^</td>
<td>取非，和**!<strong>雷同；</strong><code>^string1^string2^</code>**将上一命令的string1替换为string2</td>
</tr>
<tr>
<td>~</td>
<td>home目录</td>
</tr>
<tr>
<td>#</td>
<td>注释</td>
</tr>
<tr>
<td>*</td>
<td>通配符，任意字符</td>
</tr>
<tr>
<td>?</td>
<td>通配符，任一字符</td>
</tr>
<tr>
<td>.</td>
<td>当前目录；source</td>
</tr>
<tr>
<td>-</td>
<td>减号；上次工作目录</td>
</tr>
<tr>
<td>:</td>
<td>真值；空命令</td>
</tr>
<tr>
<td>\</td>
<td>转义</td>
</tr>
<tr>
<td>/</td>
<td>目录分割符</td>
</tr>
</tbody></table>
<h2 id="附录2-ASCII码-对照表"><a href="#附录2-ASCII码-对照表" class="headerlink" title="附录2 ASCII码 对照表"></a>附录2 ASCII码 对照表</h2><table>
<thead>
<tr>
<th>Bin(二进制)</th>
<th>Oct(八进制)</th>
<th>Dec(十进制)</th>
<th>Hex(十六进制)</th>
<th>缩写/字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0000 0000</td>
<td>0</td>
<td>0</td>
<td>00</td>
<td>NUL(null)</td>
<td>空字符</td>
</tr>
<tr>
<td>0000 0001</td>
<td>1</td>
<td>1</td>
<td>01</td>
<td>SOH(start of headline)</td>
<td>标题开始</td>
</tr>
<tr>
<td>0000 0010</td>
<td>2</td>
<td>2</td>
<td>02</td>
<td>STX (start of text)</td>
<td>正文开始</td>
</tr>
<tr>
<td>0000 0011</td>
<td>3</td>
<td>3</td>
<td>03</td>
<td>ETX (end of text)</td>
<td>正文结束</td>
</tr>
<tr>
<td>0000 0100</td>
<td>4</td>
<td>4</td>
<td>04</td>
<td>EOT (end of transmission)</td>
<td>传输结束</td>
</tr>
<tr>
<td>0000 0101</td>
<td>5</td>
<td>5</td>
<td>05</td>
<td>ENQ (enquiry)</td>
<td>请求</td>
</tr>
<tr>
<td>0000 0110</td>
<td>6</td>
<td>6</td>
<td>06</td>
<td>ACK (acknowledge)</td>
<td>收到通知</td>
</tr>
<tr>
<td>0000 0111</td>
<td>7</td>
<td>7</td>
<td>07</td>
<td>BEL (bell)</td>
<td>响铃</td>
</tr>
<tr>
<td>0000 1000</td>
<td>10</td>
<td>8</td>
<td>08</td>
<td>BS (backspace)</td>
<td>退格</td>
</tr>
<tr>
<td>0000 1001</td>
<td>11</td>
<td>9</td>
<td>09</td>
<td>HT (horizontal tab)</td>
<td>水平制表符</td>
</tr>
<tr>
<td>0000 1010</td>
<td>12</td>
<td>10</td>
<td>0A</td>
<td>LF (NL line feed, new line)</td>
<td>换行键</td>
</tr>
<tr>
<td>0000 1011</td>
<td>13</td>
<td>11</td>
<td>0B</td>
<td>VT (vertical tab)</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>0000 1100</td>
<td>14</td>
<td>12</td>
<td>0C</td>
<td>FF (NP form feed, new page)</td>
<td>换页键</td>
</tr>
<tr>
<td>0000 1101</td>
<td>15</td>
<td>13</td>
<td>0D</td>
<td>CR (carriage return)</td>
<td>回车键</td>
</tr>
<tr>
<td>0000 1110</td>
<td>16</td>
<td>14</td>
<td>0E</td>
<td>SO (shift out)</td>
<td>不用切换</td>
</tr>
<tr>
<td>0000 1111</td>
<td>17</td>
<td>15</td>
<td>0F</td>
<td>SI (shift in)</td>
<td>启用切换</td>
</tr>
<tr>
<td>0001 0000</td>
<td>20</td>
<td>16</td>
<td>10</td>
<td>DLE (data link escape)</td>
<td>数据链路转义</td>
</tr>
<tr>
<td>0001 0001</td>
<td>21</td>
<td>17</td>
<td>11</td>
<td>DC1 (device control 1)</td>
<td>设备控制1</td>
</tr>
<tr>
<td>0001 0010</td>
<td>22</td>
<td>18</td>
<td>12</td>
<td>DC2 (device control 2)</td>
<td>设备控制2</td>
</tr>
<tr>
<td>0001 0011</td>
<td>23</td>
<td>19</td>
<td>13</td>
<td>DC3 (device control 3)</td>
<td>设备控制3</td>
</tr>
<tr>
<td>0001 0100</td>
<td>24</td>
<td>20</td>
<td>14</td>
<td>DC4 (device control 4)</td>
<td>设备控制4</td>
</tr>
<tr>
<td>0001 0101</td>
<td>25</td>
<td>21</td>
<td>15</td>
<td>NAK (negative acknowledge)</td>
<td>拒绝接收</td>
</tr>
<tr>
<td>0001 0110</td>
<td>26</td>
<td>22</td>
<td>16</td>
<td>SYN (synchronous idle)</td>
<td>同步空闲</td>
</tr>
<tr>
<td>0001 0111</td>
<td>27</td>
<td>23</td>
<td>17</td>
<td>ETB (end of trans. block)</td>
<td>结束传输块</td>
</tr>
<tr>
<td>0001 1000</td>
<td>30</td>
<td>24</td>
<td>18</td>
<td>CAN (cancel)</td>
<td>取消</td>
</tr>
<tr>
<td>0001 1001</td>
<td>31</td>
<td>25</td>
<td>19</td>
<td>EM (end of medium)</td>
<td>媒介结束</td>
</tr>
<tr>
<td>0001 1010</td>
<td>32</td>
<td>26</td>
<td>1A</td>
<td>SUB (substitute)</td>
<td>代替</td>
</tr>
<tr>
<td>0001 1011</td>
<td>33</td>
<td>27</td>
<td>1B</td>
<td>ESC (escape)</td>
<td>换码(溢出)</td>
</tr>
<tr>
<td>0001 1100</td>
<td>34</td>
<td>28</td>
<td>1C</td>
<td>FS (file separator)</td>
<td>文件分隔符</td>
</tr>
<tr>
<td>0001 1101</td>
<td>35</td>
<td>29</td>
<td>1D</td>
<td>GS (group separator)</td>
<td>分组符</td>
</tr>
<tr>
<td>0001 1110</td>
<td>36</td>
<td>30</td>
<td>1E</td>
<td>RS (record separator)</td>
<td>记录分隔符</td>
</tr>
<tr>
<td>0001 1111</td>
<td>37</td>
<td>31</td>
<td>1F</td>
<td>US (unit separator)</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>0010 0000</td>
<td>40</td>
<td>32</td>
<td>20</td>
<td>(space)</td>
<td>空格</td>
</tr>
<tr>
<td>0010 0001</td>
<td>41</td>
<td>33</td>
<td>21</td>
<td>!</td>
<td>叹号</td>
</tr>
<tr>
<td>0010 0010</td>
<td>42</td>
<td>34</td>
<td>22</td>
<td>“</td>
<td>双引号</td>
</tr>
<tr>
<td>0010 0011</td>
<td>43</td>
<td>35</td>
<td>23</td>
<td>#</td>
<td>井号</td>
</tr>
<tr>
<td>0010 0100</td>
<td>44</td>
<td>36</td>
<td>24</td>
<td>$</td>
<td>美元符</td>
</tr>
<tr>
<td>0010 0101</td>
<td>45</td>
<td>37</td>
<td>25</td>
<td>%</td>
<td>百分号</td>
</tr>
<tr>
<td>0010 0110</td>
<td>46</td>
<td>38</td>
<td>26</td>
<td>&amp;</td>
<td>和号</td>
</tr>
<tr>
<td>0010 0111</td>
<td>47</td>
<td>39</td>
<td>27</td>
<td>‘</td>
<td>闭单引号</td>
</tr>
<tr>
<td>0010 1000</td>
<td>50</td>
<td>40</td>
<td>28</td>
<td>(</td>
<td>开括号</td>
</tr>
<tr>
<td>0010 1001</td>
<td>51</td>
<td>41</td>
<td>29</td>
<td>)</td>
<td>闭括号</td>
</tr>
<tr>
<td>0010 1010</td>
<td>52</td>
<td>42</td>
<td>2A</td>
<td>*</td>
<td>星号</td>
</tr>
<tr>
<td>0010 1011</td>
<td>53</td>
<td>43</td>
<td>2B</td>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>0010 1100</td>
<td>54</td>
<td>44</td>
<td>2C</td>
<td>,</td>
<td>逗号</td>
</tr>
<tr>
<td>0010 1101</td>
<td>55</td>
<td>45</td>
<td>2D</td>
<td>-</td>
<td>减号/破折号</td>
</tr>
<tr>
<td>0010 1110</td>
<td>56</td>
<td>46</td>
<td>2E</td>
<td>.</td>
<td>句号</td>
</tr>
<tr>
<td>00101111</td>
<td>57</td>
<td>47</td>
<td>2F</td>
<td>/</td>
<td>斜杠</td>
</tr>
<tr>
<td>00110000</td>
<td>60</td>
<td>48</td>
<td>30</td>
<td>0</td>
<td>数字0</td>
</tr>
<tr>
<td>00110001</td>
<td>61</td>
<td>49</td>
<td>31</td>
<td>1</td>
<td>数字1</td>
</tr>
<tr>
<td>00110010</td>
<td>62</td>
<td>50</td>
<td>32</td>
<td>2</td>
<td>数字2</td>
</tr>
<tr>
<td>00110011</td>
<td>63</td>
<td>51</td>
<td>33</td>
<td>3</td>
<td>数字3</td>
</tr>
<tr>
<td>00110100</td>
<td>64</td>
<td>52</td>
<td>34</td>
<td>4</td>
<td>数字4</td>
</tr>
<tr>
<td>00110101</td>
<td>65</td>
<td>53</td>
<td>35</td>
<td>5</td>
<td>数字5</td>
</tr>
<tr>
<td>00110110</td>
<td>66</td>
<td>54</td>
<td>36</td>
<td>6</td>
<td>数字6</td>
</tr>
<tr>
<td>00110111</td>
<td>67</td>
<td>55</td>
<td>37</td>
<td>7</td>
<td>数字7</td>
</tr>
<tr>
<td>00111000</td>
<td>70</td>
<td>56</td>
<td>38</td>
<td>8</td>
<td>数字8</td>
</tr>
<tr>
<td>00111001</td>
<td>71</td>
<td>57</td>
<td>39</td>
<td>9</td>
<td>数字9</td>
</tr>
<tr>
<td>00111010</td>
<td>72</td>
<td>58</td>
<td>3A</td>
<td>:</td>
<td>冒号</td>
</tr>
<tr>
<td>00111011</td>
<td>73</td>
<td>59</td>
<td>3B</td>
<td>;</td>
<td>分号</td>
</tr>
<tr>
<td>00111100</td>
<td>74</td>
<td>60</td>
<td>3C</td>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>00111101</td>
<td>75</td>
<td>61</td>
<td>3D</td>
<td>=</td>
<td>等号</td>
</tr>
<tr>
<td>00111110</td>
<td>76</td>
<td>62</td>
<td>3E</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>00111111</td>
<td>77</td>
<td>63</td>
<td>3F</td>
<td>?</td>
<td>问号</td>
</tr>
<tr>
<td>01000000</td>
<td>100</td>
<td>64</td>
<td>40</td>
<td>@</td>
<td>电子邮件符号</td>
</tr>
<tr>
<td>01000001</td>
<td>101</td>
<td>65</td>
<td>41</td>
<td>A</td>
<td>大写字母A</td>
</tr>
<tr>
<td>01000010</td>
<td>102</td>
<td>66</td>
<td>42</td>
<td>B</td>
<td>大写字母B</td>
</tr>
<tr>
<td>01000011</td>
<td>103</td>
<td>67</td>
<td>43</td>
<td>C</td>
<td>大写字母C</td>
</tr>
<tr>
<td>01000100</td>
<td>104</td>
<td>68</td>
<td>44</td>
<td>D</td>
<td>大写字母D</td>
</tr>
<tr>
<td>01000101</td>
<td>105</td>
<td>69</td>
<td>45</td>
<td>E</td>
<td>大写字母E</td>
</tr>
<tr>
<td>01000110</td>
<td>106</td>
<td>70</td>
<td>46</td>
<td>F</td>
<td>大写字母F</td>
</tr>
<tr>
<td>01000111</td>
<td>107</td>
<td>71</td>
<td>47</td>
<td>G</td>
<td>大写字母G</td>
</tr>
<tr>
<td>01001000</td>
<td>110</td>
<td>72</td>
<td>48</td>
<td>H</td>
<td>大写字母H</td>
</tr>
<tr>
<td>01001001</td>
<td>111</td>
<td>73</td>
<td>49</td>
<td>I</td>
<td>大写字母I</td>
</tr>
<tr>
<td>01001010</td>
<td>112</td>
<td>74</td>
<td>4A</td>
<td>J</td>
<td>大写字母J</td>
</tr>
<tr>
<td>01001011</td>
<td>113</td>
<td>75</td>
<td>4B</td>
<td>K</td>
<td>大写字母K</td>
</tr>
<tr>
<td>01001100</td>
<td>114</td>
<td>76</td>
<td>4C</td>
<td>L</td>
<td>大写字母L</td>
</tr>
<tr>
<td>01001101</td>
<td>115</td>
<td>77</td>
<td>4D</td>
<td>M</td>
<td>大写字母M</td>
</tr>
<tr>
<td>01001110</td>
<td>116</td>
<td>78</td>
<td>4E</td>
<td>N</td>
<td>大写字母N</td>
</tr>
<tr>
<td>01001111</td>
<td>117</td>
<td>79</td>
<td>4F</td>
<td>O</td>
<td>大写字母O</td>
</tr>
<tr>
<td>01010000</td>
<td>120</td>
<td>80</td>
<td>50</td>
<td>P</td>
<td>大写字母P</td>
</tr>
<tr>
<td>01010001</td>
<td>121</td>
<td>81</td>
<td>51</td>
<td>Q</td>
<td>大写字母Q</td>
</tr>
<tr>
<td>01010010</td>
<td>122</td>
<td>82</td>
<td>52</td>
<td>R</td>
<td>大写字母R</td>
</tr>
<tr>
<td>01010011</td>
<td>123</td>
<td>83</td>
<td>53</td>
<td>S</td>
<td>大写字母S</td>
</tr>
<tr>
<td>01010100</td>
<td>124</td>
<td>84</td>
<td>54</td>
<td>T</td>
<td>大写字母T</td>
</tr>
<tr>
<td>01010101</td>
<td>125</td>
<td>85</td>
<td>55</td>
<td>U</td>
<td>大写字母U</td>
</tr>
<tr>
<td>01010110</td>
<td>126</td>
<td>86</td>
<td>56</td>
<td>V</td>
<td>大写字母V</td>
</tr>
<tr>
<td>01010111</td>
<td>127</td>
<td>87</td>
<td>57</td>
<td>W</td>
<td>大写字母W</td>
</tr>
<tr>
<td>01011000</td>
<td>130</td>
<td>88</td>
<td>58</td>
<td>X</td>
<td>大写字母X</td>
</tr>
<tr>
<td>01011001</td>
<td>131</td>
<td>89</td>
<td>59</td>
<td>Y</td>
<td>大写字母Y</td>
</tr>
<tr>
<td>01011010</td>
<td>132</td>
<td>90</td>
<td>5A</td>
<td>Z</td>
<td>大写字母Z</td>
</tr>
<tr>
<td>01011011</td>
<td>133</td>
<td>91</td>
<td>5B</td>
<td>[</td>
<td>开方括号</td>
</tr>
<tr>
<td>01011100</td>
<td>134</td>
<td>92</td>
<td>5C</td>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>01011101</td>
<td>135</td>
<td>93</td>
<td>5D</td>
<td>]</td>
<td>闭方括号</td>
</tr>
<tr>
<td>01011110</td>
<td>136</td>
<td>94</td>
<td>5E</td>
<td>^</td>
<td>脱字符</td>
</tr>
<tr>
<td>01011111</td>
<td>137</td>
<td>95</td>
<td>5F</td>
<td>_</td>
<td>下划线</td>
</tr>
<tr>
<td>01100000</td>
<td>140</td>
<td>96</td>
<td>60</td>
<td>`</td>
<td>开单引号</td>
</tr>
<tr>
<td>01100001</td>
<td>141</td>
<td>97</td>
<td>61</td>
<td>a</td>
<td>小写字母a</td>
</tr>
<tr>
<td>01100010</td>
<td>142</td>
<td>98</td>
<td>62</td>
<td>b</td>
<td>小写字母b</td>
</tr>
<tr>
<td>01100011</td>
<td>143</td>
<td>99</td>
<td>63</td>
<td>c</td>
<td>小写字母c</td>
</tr>
<tr>
<td>01100100</td>
<td>144</td>
<td>100</td>
<td>64</td>
<td>d</td>
<td>小写字母d</td>
</tr>
<tr>
<td>01100101</td>
<td>145</td>
<td>101</td>
<td>65</td>
<td>e</td>
<td>小写字母e</td>
</tr>
<tr>
<td>01100110</td>
<td>146</td>
<td>102</td>
<td>66</td>
<td>f</td>
<td>小写字母f</td>
</tr>
<tr>
<td>01100111</td>
<td>147</td>
<td>103</td>
<td>67</td>
<td>g</td>
<td>小写字母g</td>
</tr>
<tr>
<td>01101000</td>
<td>150</td>
<td>104</td>
<td>68</td>
<td>h</td>
<td>小写字母h</td>
</tr>
<tr>
<td>01101001</td>
<td>151</td>
<td>105</td>
<td>69</td>
<td>i</td>
<td>小写字母i</td>
</tr>
<tr>
<td>01101010</td>
<td>152</td>
<td>106</td>
<td>6A</td>
<td>j</td>
<td>小写字母j</td>
</tr>
<tr>
<td>01101011</td>
<td>153</td>
<td>107</td>
<td>6B</td>
<td>k</td>
<td>小写字母k</td>
</tr>
<tr>
<td>01101100</td>
<td>154</td>
<td>108</td>
<td>6C</td>
<td>l</td>
<td>小写字母l</td>
</tr>
<tr>
<td>01101101</td>
<td>155</td>
<td>109</td>
<td>6D</td>
<td>m</td>
<td>小写字母m</td>
</tr>
<tr>
<td>01101110</td>
<td>156</td>
<td>110</td>
<td>6E</td>
<td>n</td>
<td>小写字母n</td>
</tr>
<tr>
<td>01101111</td>
<td>157</td>
<td>111</td>
<td>6F</td>
<td>o</td>
<td>小写字母o</td>
</tr>
<tr>
<td>01110000</td>
<td>160</td>
<td>112</td>
<td>70</td>
<td>p</td>
<td>小写字母p</td>
</tr>
<tr>
<td>01110001</td>
<td>161</td>
<td>113</td>
<td>71</td>
<td>q</td>
<td>小写字母q</td>
</tr>
<tr>
<td>01110010</td>
<td>162</td>
<td>114</td>
<td>72</td>
<td>r</td>
<td>小写字母r</td>
</tr>
<tr>
<td>01110011</td>
<td>163</td>
<td>115</td>
<td>73</td>
<td>s</td>
<td>小写字母s</td>
</tr>
<tr>
<td>01110100</td>
<td>164</td>
<td>116</td>
<td>74</td>
<td>t</td>
<td>小写字母t</td>
</tr>
<tr>
<td>01110101</td>
<td>165</td>
<td>117</td>
<td>75</td>
<td>u</td>
<td>小写字母u</td>
</tr>
<tr>
<td>01110110</td>
<td>166</td>
<td>118</td>
<td>76</td>
<td>v</td>
<td>小写字母v</td>
</tr>
<tr>
<td>01110111</td>
<td>167</td>
<td>119</td>
<td>77</td>
<td>w</td>
<td>小写字母w</td>
</tr>
<tr>
<td>01111000</td>
<td>170</td>
<td>120</td>
<td>78</td>
<td>x</td>
<td>小写字母x</td>
</tr>
<tr>
<td>01111001</td>
<td>171</td>
<td>121</td>
<td>79</td>
<td>y</td>
<td>小写字母y</td>
</tr>
<tr>
<td>01111010</td>
<td>172</td>
<td>122</td>
<td>7A</td>
<td>z</td>
<td>小写字母z</td>
</tr>
<tr>
<td>01111011</td>
<td>173</td>
<td>123</td>
<td>7B</td>
<td>{</td>
<td>开花括号</td>
</tr>
<tr>
<td>01111100</td>
<td>174</td>
<td>124</td>
<td>7C</td>
<td>|</td>
<td>垂线</td>
</tr>
<tr>
<td>01111101</td>
<td>175</td>
<td>125</td>
<td>7D</td>
<td>}</td>
<td>闭花括号</td>
</tr>
<tr>
<td>01111110</td>
<td>176</td>
<td>126</td>
<td>7E</td>
<td>~</td>
<td>波浪号</td>
</tr>
<tr>
<td>01111111</td>
<td>177</td>
<td>127</td>
<td>7F</td>
<td>DEL (delete)</td>
<td>删除</td>
</tr>
</tbody></table>
<h1 id="四、linux系统信息获取"><a href="#四、linux系统信息获取" class="headerlink" title="四、linux系统信息获取"></a>四、linux系统信息获取</h1><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>update</code></td>
<td>打印系统运行时长和平均负载</td>
</tr>
<tr>
<td><code>who</code></td>
<td>显示当前系统登录的用户信息</td>
</tr>
<tr>
<td><code>last</code></td>
<td>显示用户最近登录信息</td>
</tr>
<tr>
<td><code>date</code></td>
<td>显示或设置系统时间与日期</td>
</tr>
<tr>
<td><code>w</code></td>
<td>当前登录用户列表及正在执行的任务</td>
</tr>
<tr>
<td><code>whoami</code></td>
<td>打印当前有效的用户名称</td>
</tr>
<tr>
<td><code>uname</code></td>
<td>打印当前系统信息</td>
</tr>
<tr>
<td><code>cal</code></td>
<td>显示日历</td>
</tr>
</tbody></table>
<p><code>uptime</code>系统运行时长</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu ~ % uptime</span><br><span class="line"> 14:28:15 up 6 days, 22:24,  1 user,  load average: 1.88, 1.19, 1.01</span><br></pre></td></tr></table></figure>


<p><code>w</code>获取当前用户和正在执行的进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu ~ % w                                                                                                        [127]</span><br><span class="line"> 14:33:51 up 6 days, 22:29,  1 user,  load average: 0.96, 0.95, 0.95</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">apricity pts/0    112.54.13.167    14:00    1.00s  3.35s  0.00s w</span><br></pre></td></tr></table></figure>


<p><code>tty</code>虚拟终端  <code>from</code> 从哪里登录，<code>loging</code>在什么时候登录</p>
<p><code> last | grep  -v &quot;wtmp begins&quot; | grep -v &quot;^$&quot; | grep -v &quot;reboot&quot; |ƒ |sort | uniq -c | sort -n -r  | head -n 2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">上一次登录停留了多长时间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>






<p><code>uname</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu linux基础 % uname -a</span><br><span class="line">Linux qiu 4.15.0-117-generic #118-Ubuntu SMP Fri Sep 4 20:02:41 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apricity@qiu linux % date +&quot;%Y-%m-%d %H:%M:%S&quot;                                                                        [0]</span><br><span class="line">2020-11-29 15:40:28</span><br></pre></td></tr></table></figure>




<p>cal日历</p>
<h1 id="五、shell编程"><a href="#五、shell编程" class="headerlink" title="五、shell编程"></a>五、shell编程</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">这是注释</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  ！不是注释，指定解释器,固定格式</span></span><br><span class="line">echo &#x27;hello&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释的代码...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>




<h2 id="1-变量与局部变量"><a href="#1-变量与局部变量" class="headerlink" title="1.变量与局部变量"></a>1.变量与局部变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">变量</span></span><br><span class="line">apricity@qiu 1.shell % a=123                                                                                          [0]</span><br><span class="line">apricity@qiu 1.shell % echo $a                                                                                        [0]</span><br><span class="line">123</span><br><span class="line"></span><br><span class="line">apricity@qiu 1.shell % a = 123</span><br><span class="line">zsh: command not found: a</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量的定义</p>
<p>​    a=12</p>
<p>局部变量</p>
<p>​    local a=12</p>
<p>特殊变量</p>
<ul>
<li><p>位置变量</p>
<p>$0:获取当前执行shell脚本文件名，包括路径</p>
<p>$*:获取当前shell的所有参数</p>
<p>$#：得到当前脚本的参数个数</p>
<p>$@：获取这个程序所有的参数</p>
</li>
</ul>
</blockquote>
<p>状态变量</p>
<p>​        $?：判断上一个指令是否执行成功，0为成功，非零不成功</p>
<p>​        $$:获取当前进程的PID</p>
<p>​        $!：上一个指令的PID</p>
<h2 id="2-输入输出"><a href="#2-输入输出" class="headerlink" title="2.输入输出"></a>2.输入输出</h2><p><code>echo</code></p>
<p><code>echo -e &quot;hello\n&quot;#开启转义</code></p>
<p><code>printf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">软转义</span></span><br><span class="line">apricity@qiu 1.shell % a=&quot;first.sh:$&#123;a&#125;&quot;                                                                                    [0]</span><br><span class="line">apricity@qiu 1.shell % echo $a                                                                                              [0]</span><br><span class="line">first.sh:first.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">硬转义</span></span><br><span class="line">apricity@qiu 1.shell % a=&#x27;first.sh:$&#123;a&#125;&#x27;                                                                                    [0]</span><br><span class="line">apricity@qiu 1.shell % echo $a                                                                                              [0]</span><br><span class="line">first.sh:$&#123;a&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e “\033[32m 绿色字 \033[0m” </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令替换符``，替换命令</span></span><br><span class="line">apricity@qiu 1.shell % a=`pwd`                                                                                              [0]</span><br><span class="line">apricity@qiu 1.shell % pwd                                                                                                  [0]</span><br><span class="line">/home/apricity/linux/1.shell</span><br><span class="line">apricity@qiu 1.shell % echo $a                                                                                              [0]</span><br><span class="line">/home/apricity/linux/1.shell</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu 1.shell % PATH=$&#123;PATH&#125;:first.sh                                                                                [0]</span><br><span class="line">apricity@qiu 1.shell % echo $PATH                                                                                           [0]</span><br><span class="line">/home/apricity/.autojump/bin:/home/apricity/.autojump/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:first.sh</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>特殊变量</p>
<p><code>echo $?</code>上一条命令的执行结果</p>
<p>read </p>
<p>​    -s静默模式输入密码</p>
<p>​    </p>
<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">__printf__</span></span>() &#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__printf__ <span class="string">&quot;hello guziqiu&quot;</span></span><br></pre></td></tr></table></figure>




<h2 id="4-流程控制语句"><a href="#4-流程控制语句" class="headerlink" title="4.流程控制语句"></a>4.流程控制语句</h2><h3 id="1-if"><a href="#1-if" class="headerlink" title="1.if"></a>1.<code>if</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> a</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> -gt 10 ]];<span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> &gt; 10&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> &lt;= 10&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> a</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;a&#125;</span> -gt 10 ]];<span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> &gt; 10&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="variable">$&#123;a&#125;</span> -eq 10 ]];<span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> = 10&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> &lt; 10&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>


<p><code>test</code>表达式</p>
<h3 id="2-while"><a href="#2-while" class="headerlink" title="2.while"></a>2.<code>while</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [[ condition ]]; do</span><br><span class="line">done</span><br></pre></td></tr></table></figure>




<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num=0</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$num</span> -lt 100 ]];<span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$&#123;num&#125;</span></span><br><span class="line">	num=$[ <span class="variable">$&#123;num&#125;</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>


<h3 id="3-case"><a href="#3-case" class="headerlink" title="3.case"></a>3.case</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">case words in</span><br><span class="line">		pattern)</span><br><span class="line">					;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> a</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$a</span> <span class="keyword">in</span></span><br><span class="line">	1)</span><br><span class="line">		<span class="built_in">echo</span> 1</span><br><span class="line">		;;</span><br><span class="line">	2)</span><br><span class="line">		<span class="built_in">echo</span> 2</span><br><span class="line">		;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> a</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$a</span> <span class="keyword">in</span></span><br><span class="line">	1)</span><br><span class="line">		<span class="built_in">echo</span> 1</span><br><span class="line">		;;</span><br><span class="line">	2)</span><br><span class="line">		<span class="built_in">echo</span> 2</span><br><span class="line">		;;</span><br><span class="line">	default)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;not found&quot;</span></span><br><span class="line">		;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>




<p>遍历当前目录所有文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `ls *.sh`;<span class="keyword">do</span>                                                                                [0]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">1.first.sh</span><br><span class="line">2.func.sh</span><br><span class="line">3.if.sh</span><br><span class="line">4.case.sh</span><br></pre></td></tr></table></figure>






<h3 id="4-for"><a href="#4-for" class="headerlink" title="4.for"></a>4.for</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for in in words; do</span><br><span class="line">done</span><br><span class="line">for (( i=0; i&lt;10; i++ )); do</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$@</span>;<span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1; i &lt;= 100; i++));<span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>






<h3 id="5-until"><a href="#5-until" class="headerlink" title="5.until"></a>5.until</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">until [[ condition ]];do</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">num=0</span><br><span class="line">until [[ <span class="variable">$num</span> -eq 100 ]];<span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$num</span></span><br><span class="line">	num=$[ <span class="variable">$&#123;num&#125;</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>






<p>100以内偶数求和</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">for</span> (( i=1; i&lt;=100; i++ ));<span class="keyword">do</span></span><br><span class="line">	<span class="keyword">if</span> [[ $[ <span class="variable">$&#123;i&#125;</span> % 2 ]  -eq 0 ]];<span class="keyword">then</span></span><br><span class="line">		sum=$[ <span class="variable">$&#123;sum&#125;</span> + <span class="variable">$&#123;i&#125;</span> ]</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;sum&#125;</span></span><br></pre></td></tr></table></figure>


<p>空格敏感，</p>
<p>=号左右不能加空格</p>
<p>$a变量名</p>
<p>$[ 整数计算 ]</p>
<p>[[ test表达式 ]]</p>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h2><p><code>declare -a a</code></p>
<blockquote>
<p>输出数组内容</p>
<p><code>$&#123;array[*]&#125;</code></p>
<p><code>$&#123;array[@]&#125;</code></p>
</blockquote>
<blockquote>
<p>确定数组元素个数</p>
<p><code>$&#123;#array[@]&#125;`



> 找到数组的下标
>
> `$&#123;!array[@]&#125;`



> 追加数组
>
> `array+=(a,b,c);`

> 数组排序
>
> `sort`

> 删除数组元素
>
> `unset`









<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apricity@qiu:~/linux/1.shell$ <span class="built_in">read</span> -a a</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ <span class="built_in">echo</span> <span class="variable">$&#123;a&#125;</span></span><br><span class="line">1</span><br><span class="line">apricity@qiu:~/linux/1.shell$ <span class="built_in">echo</span> <span class="variable">$&#123;a[1]&#125;</span></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ <span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ <span class="built_in">echo</span> <span class="variable">$&#123;a[*]&#125;</span></span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看数组下标</span></span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;!c[*]&#125;</span><br><span class="line">0 1 2</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;!c[@]&#125;</span><br><span class="line">0 1 2</span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ c+=(4 5 6)</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;c[@]&#125;</span><br><span class="line">0 1 3 4 5 6</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;c[@]&#125; | sort</span><br><span class="line">0 1 3 4 5 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ unset c</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;c[@]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu:~/linux/1.shell$ d=(1 2  3  4 5  6 7 8)</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;d[*]&#125;</span><br><span class="line">1 2 3 4 5 6 7 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;a[*]&#125;</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;a[1]&#125;</span><br><span class="line">2</span><br><span class="line">apricity@qiu:~/linux/1.shell$ unset a[1]</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;a[1]&#125;</span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;a[*]&#125;</span><br><span class="line">1 3 4 5 6 7</span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;!a[*]&#125;</span><br><span class="line">0 2 3 4 5 6</span><br></pre></td></tr></table></figure>






素数筛



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">if [[ $# -ne 2 ]];then</span><br><span class="line">	echo &quot;error&quot;</span><br><span class="line">	exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">start=$1</span><br><span class="line">end=$2</span><br><span class="line"></span><br><span class="line">declare -a prime</span><br><span class="line"></span><br><span class="line">function init_prime() &#123;</span><br><span class="line">	local end=$1</span><br><span class="line">	local i</span><br><span class="line">	prime[1]=1</span><br><span class="line">	for (( i=2; i &lt;= $&#123;end&#125;; i++ ));do</span><br><span class="line">		for (( j=$[ 2 * $&#123;i&#125; ]; j &lt;= $&#123;end&#125;; j+=i ));do</span><br><span class="line"><span class="meta">			prime[$</span><span class="bash">&#123;j&#125;]=1</span></span><br><span class="line">		done</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_prime $&#123;end&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (( i=$&#123;start&#125;; i&lt;=$&#123;end&#125;; i++ ));do</span><br><span class="line">	if [[ $&#123;prime[$i]&#125;x == x ]];then</span><br><span class="line">		sum=$[ $&#123;sum&#125; + $&#123;i&#125; ]</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $&#123;sum&#125;</span><br></pre></td></tr></table></figure>






# 六、文件及目录



### 1.目录

`cd`切换到当前目录

`cd ..`切换到上层目录

`cd.`  切换到当前目录

`cd~/cd` 回到自己家目录

`cd -`回到 上次工作目录

`cd ~guziqiu/`切换到guziqiu的目录





`pwd` 打印当前工作目录



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -ald run/                                                                                             [0]</span><br><span class="line">drwxr-xr-x 21 root root 660 Dec  2 18:14 run/</span><br></pre></td></tr></table></figure>




`pwd -L`显示逻辑工作目录

`pwd -P`显示物理工作目录

（链接文件）

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu run % pwd                                                                                                       [0]</span><br><span class="line">/var/run</span><br><span class="line">apricity@qiu run % pwd -L                                                                                                    [0]</span><br><span class="line">/var/run</span><br><span class="line">apricity@qiu run % pwd -P                                                                                                    [0]</span><br><span class="line">/run</span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln ./1.shell/test/ .                                                                                    [0]</span><br><span class="line">ln: ./1.shell/test/: hard link not allowed for directory</span><br><span class="line"><span class="meta">#</span><span class="bash">hard link硬链接</span></span><br></pre></td></tr></table></figure>


`mkdir -p`自动创建父目录





!加一个命令匹配命令或者history里面的行数会输出显示该命令



`./a.out`

`./`是当前目录的意思





### 2.文件及目录管理



`cp [irapdslu]`

> ➢选项
> ➢`-i`: 若文件存在，询问用户
> ➢`-r`:递归复制
> `-a`:pdr的集合
> ➢`-p`:连同文件属性一起拷贝
> ➢`-d`: 若源文件为连接文件的属性，则复制连接文件的属性
> ➢`-s`:拷贝为软连接
> ➢`-1`:拷贝为硬连接
> ➢`-u`:源文件比目的文件新才拷贝
> ➢尝试: `cp filel file2 . dir`



`rm`

> `rm [irf]``
>
> ``-i`:互动模式
>
> `-r`:递归删除
>
> `-f`:force
>
> 



`mv`

> `mv [ifu]`
>
> `-i`:互动模式
>
> `-u`: 源文件更新才会移动
>
> `-f`:force



### 3.文件内容查阅

`cat`正向连续读

> ➢`cat [-AbEnTv] <file>`
> ➢选项:
> ➢`-A`:相当于-vET
> ➢-`V`:列出看不出的字符
> `-E`:显示断行符为`$`
> ➢`-T`:显示TAB为`^I`
> ➢`-b`:列出行号
> ➢`-n`:列出行号，连同空行也编号







`tac`反向连续读

`nl`输出行号显示文件

>➢`nl [-bnw] <file>`
>➢选项
>➢`-b`:行号指定的方式
>		`-b a`:相当于cat -n
>		`-b t`:相当于cat -b
>➢`-n`:列出行号的表示方法
>		`-n ln`:行号在屏幕最左边显示
>		`-n rn`:行号在自己字段的最右边显示
>		`-n rz`:行号在自己字段的最右边显示，前面自动补全0
>➢`-w <num>`:行号所占位数







`more`一页一页的显示内容



>MORE按页查看
>`more file`
>➢`/string`向下查找string关键字
>➢`:f`显示文件名称和当前显示的行数
>➢`q`离开







`less`与相似但是可以上下翻看

>LESS按页查看
>
>➢`less file`
>➢`/string`向下查找  `n`:继续向下查找
>➢`/?string`反向查找`N`:继续反向查询







`head`只看头几行

> HEAD查看头几行
> ➢`head [-n num] <file>`
> ➢`-nnum`:显示前num行
> ➢`-n -num`:除了后num行外，其他的都显示





`tail`只看尾几行

>TAIL查看末尾几行
>➢`tail [-n num] <file>`
>➢`-n num`:显示文件后num行
>➢`-n +num`:除了前num行，其他的都显示





`od`以二进制形式查看文件内容

>OD二_进制文件查看
>➢`od [-t TYPE] <file>`
>➢`-t` :
>	➢`a`:默认字符输出
>	➢`c`:ASCII字符输出
>	➢`d[size]`:十进制输出，每个数占用size bytes
>	➢`f[size]`:浮点数输出...
>	➢`o[size]`:八进制输出....
>	➢`x[size]:`十六进制输出...



more和all





### 4.修改文件时间与新建文件

> ➢文件的三个时间
> 	➢`mtime`:内容数据改动时才更新这个时间;
> 	➢`ctime`:文件的权限，属性改动时更新这个时间
> 	➢`atime`:文件的内容被取用access时，更新这个时间
> ➢`ls -1 --time=ctime /etc/hostname`







> ➢`touch [ - -acdmt] <file>`
> ➢`-a`:仅修改访问时间
> ➢`-c`:仅修改文件的时间，若文件不存在，不新建
> ➢`-d`:修改文件日期
> `-m`:仅修改mtime
> ➢`-t`:修改文件时间[ yymmddhhmm]

### 5.文件隐藏属性

> ➢`chattr [+-=][ASacdistu] <file_ or_ dir>`
> ➢`A`:不修改atime
> ➢`S`:同步写入
> ➢`a`:只能增加数据
> ➢`c`:自动压缩，解压
> ➢`d`:不会被dump程序备份
> ➢`i`:不能删除，修改，建立连接
> ➢`s`:文件删除时，直接从磁盘删除
> ➢`u`:文件删除时，数据内容存在磁盘中





> ➢`lsattr [-adR] <file_ or_ dir>`
> ➢`-a`:打印隐藏文件的隐藏属性
> ➢`-d`:如果是目录，仅打印目录的信息
> ➢`-R`:递归





### 6.文件的特殊权限



`set_iuid`




| 权限         |      | 作用对象               | 效果                                   |
| ------------ | ---- | ---------------------- | -------------------------------------- |
| `set_uid`    | S    | 二进制程序文件，非脚本 | 用户在执行改程序时获得程序所有者权限   |
| `set_gid`    | s    | 目录和二进制文件       | 用户在该目录里，有效组变为目录所属组， |
| `sticky bit` | t    | 目录                   | 在该目录下，用户只能删除自己创建的内容 |

`chmod +t file`



### 7.命令与文件的查询



`whereis`寻找特定文件

>➢`whereis [ - .bmsu] <file_or_dir>`
>➢`-b`:只查找二进制文件
>➢`-m`: 只查找manual路径下的文件
>➢`-s`:只查找source源文件
>`-u`:查找其他文件

`which`寻找执行文件，查找path路径下所有可执行文件



`locate` 搜索文件（可部分查找）

>`LOCATE`模糊定位
>➢`locate [-ir] keyword`
>➢`-i`:忽略大小写
>➢`-r`:后面可接正则表达式
>➢相关文件: `/ect/updatedb . conf`
>➢`/var/lib/mlocate`



`find`多样化高级查找

>`FIND`高级査找
>
>find 目录 -name 目录名
>
>➢`find [PATH] [ option] [action ]`
>➢与用户或用户组相关的参数:
>➢`-uid n`:用户UID为n
>➢`-gid n`:群组Gid为n
>➢`-user name`: 用户名为name
>➢`-group name`:群组名为name
>➢`-nouser`:文件所有者不存在
>➢`nogroup`:文件所在组不存在
>
>
>
>➢与文件权限及名称有关的参数:
>➢`-name filename`: 文件名为filename
>➢`-size [+-] SIZE`:查找比SIZE大或小的
>➢`-type TYPE`: `f b c d l s p` 
>➢`-perm mode`: mode刚好等于的文件
>➢-`perm -mode`:全部包含mode的文件
>➢`find -exec ls -l &#123;&#125; \;`
>
>-exec 命令的开始
>
>\命令结尾
>
>
>
>〉`find [PATH] [option] [ action]`
>与时间相关的参数: -`atime, -ctime, -mtime`
>`-mtime n`: n天前的“一天之内’修改的文件amin
>〉`-mtime +n`: n天之前，不包含n，修改过的文件
>〉`-mtime - -n`: n天之内，包含n,修改过的文件
>》`-newer file`: 比file还要新的文件





<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> ls -al `which passwd`                                                                                                     [10]</span><br><span class="line">-rwsr-xr-x 1 root root 59640 Mar 23  2019 /usr/bin/passwd</span><br></pre></td></tr></table></figure>






## linux三剑客awk

awk文本数据处理

`awk [-Ffv] 'BEGIN&#123; commands&#125; pattern &#123; commands&#125; END &#123; commands&#125;' file`

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">last | grep -v &quot;^$&quot; | grep -v &quot;wtmp&quot; | grep -v &quot;still&quot;| head -5 | awk &#x27;BEGIN &#123;print &quot;start\n&quot;&#125; &#123;if ($1 == &quot;apricity&quot;) &#123;print $10&#125;&#125; END &#123;printf(&quot;%s\n&quot;,&quot;Bye&quot;)&#125;&#x27;| grep -v &quot;^$&quot; |cut -c 2-6 |awk -F: -v hour=0 -v min=0 &#x27;&#123;hour+=$1;min+=$2&#125; END &#123;if (min&gt;=60) &#123;hour+=min/60;min=min%60&#125; printf(&quot;%d hours, %d min&quot;,hour,min)&#125;&#x27;</span><br><span class="line">3 hours, 2 min%</span><br></pre></td></tr></table></figure>










# 七、数据提取操作







| 命令    | 说明             | 命令    | 说明                 |
| ------- | ---------------- | ------- | -------------------- |
| `cut`   | 切分             | `grep`  | 检索                 |
| `sort`  | 排序             | `wc`    | 统计字符、字数、行数 |
| `uniq`  | 去重             | `tee`   | 双向重导项           |
| `split` | 文件切分         | `xargs` | `参数代换`           |
| `tr`    | 替换、压缩和删除 |         |                      |



## 1.cut 切分

>`➢cut [-dfc] <file>`
>
>​	`-d c`:以c字符分割(c在字符中)
>
>​	`-f num`: 显示num字段的内容`[n- ; n-m;-m]`
>​    `-b num`: 字节
>​	`-c num`: 字符

`cut -d : -f 1`

## 2.grep检索

>`grep [-acinv] <string> <fi1e>`
>	`-a`:将二进制文件以普通文件的形式搜寻数据
>	`-c`:统计搜寻到的次数
>
>​	`-C`:统计
>
>​	`-i`:忽略大小写
>​	`-n`:顺序输出行号
>​	`-v`:反向输出(输出没找到的)

`grep -v "^$"` 过滤空白符

​	



`ps -ef`   linux下任务管理器





 



## 3.sort排序



>➢`sort [ - fbMnrtuk] <file_ or_ stdio>`
>➢`-f`:忽略大小写
>➢`-b`:忽略最前面的空格符
>➢`-M`:以月份名称排序
>➢`-n`:以纯数字方式排序
>`  -r`:反向排序
>➢`-u`:uniq
>➢`-t`:分割符，默认[TAB ]
>➢`-k`:以那个区间排序



## 4.WC统计字符,字数,行数

>`wc [ - lwm] <file_or_stdin>`
>➢`-1`:仅列出行号
>➢`-w`:仅列出多少字
>➢`-m`:仅列出多少字符



## 5.UNIQ去重

> ➢`uniq [-ic]`
> ➢`-i`:忽略大小写字符的不同
> ➢`-c`:进行计数





## 6.TEE 双向重导项

> `tee [-a] file`
> `-a`:append

 

## 7.SPLIT文件切分

> ➢`split [-bl] <file> PREFIX` 
> ➢`-b SIZE`: 切分为SIZE大小的文件
> ➢`-l num`: 以num行为大小切分

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /etc/ | split -l 10</span><br><span class="line">  ls                                                                     [0]</span><br><span class="line">xaa  xab  xac  xad  xae  xaf  xag  xah  xai  xaj  xak  xal  xam  xan  xao  xap  xaq  xar  xas</span><br></pre></td></tr></table></figure>


## 8.xargs参数代换

> ➢`xargs [ -0pne] <command>`
> ➢`-0`:将特殊字符还原为普通字符
> ➢`-eEOF`: 当xargs读到EOF时停止
> ➢`-p`:执行指令前询问
> ➢`-n num`: 每次执行command时需要的参数个数

<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/etc/&quot;</span> | xargs ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; . /bin /etc&quot;</span> | xargs -e<span class="string">&quot;/bin&quot;</span> ls                                [0]</span><br><span class="line">xaa  xab  xac  xad  xae  xaf  xag  xah	xai  xaj  xak  xal  xam  xan  xao  xap	xaq  xar  xas</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat /etc/passwd | cut -d : -f 1  |xargs -p -n 1 id</span><br><span class="line"></span><br></pre></td></tr></table></figure>




## 9.tr 对标准输入的字符替换,压缩,删除

> ➢`tr [cdst] <第一字符集> <第二字符集>`
> ➢`c` 用字符集二取代所有不属于第一字符集的字符
> ➢`d`删除所有属于第一字符集的字符
> ➢`s`将连续重复的字符以单独一个字符表示
> ➢`t`先删除第一字符集较第二字符集多出的字符

` man ls | tr -sc "a-zA-Z" " "`

`man ls | tr -sc "a-zA-Z" "\n" | sort | uniq -c | sort -nr | head -9`



## 10.数据提取练习



> 1.tr命令对文件的重命名，内容的替换操作



> #“1 2 3 4 5 6 7 9 a v 你好 . /8”
> #求以上字符串中所有数字之和

`echo "1 2 3 4 5 6 7 9 a v 你好 . /8" | tr -c "1-9" "\n" | grep -v "^$" | awk '&#123;sum+=$1&#125; END &#123;print sum&#125;'`
`45`

> #echo “ABCefg” >> test.log
>
> #请将该文件中所有大写字母转换为小写


 `echo  ABCefg | tr 'A-Z' 'a-z'`



> 2.找到`PATH`变量中的最后一个路径。



`echo $&#123;PATH&#125; | tr ":" "\n" | tail -1`



> 3.使用`last`命令,输出所有的关机信息。



`ast | grep "reboot"`



> 4.将`/etc/passwd`中的内容按照用户名排序。

`cat /etc/passwd | sort -t : -k 1`



> 5.将`/etc/passwd`中的内容按`uid`排序。

`cat /etc/passwd | sort -t : -k 3`



> 6.在云主机上查找系统登录用户的总人次。

`last | grep -v "^$" | grep -v "wtmp" | grep -v "reboot"  | wc -l`



> 7.将云主机中登录的所有用户名，按照次数排序，并输出次数。

`last | grep -v "^$" | grep -v "wtmp" | grep -v "reboot"  | cut -d " " -f 1 | sort | uniq  -c`
    105 apricity
     10 guziqiu
      9 root
      3 test

> 8.将本地的`/etc`目录下的文件及目录，每十条保存到一个文件中。

`ls /etc/ | split -l 10`

> 9.将`/etc/passwd`中存放的第10到20个用户，输出`uid`，`gid`和`groups`。

`cat /etc/passwd| head -n 20 | tail -n 10 | cut -d : -f 1 | xargs -n 1 id`

> 10.将按照用户名查看`/etc/passwd`中的用户，读到`'sync'`用户结束。

​		`cat /etc/passwd | cut -d : -f 1 | xargs -e"sync"`



> 11.词频统计

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用下面这个命令生成一个文本文件。</span><br><span class="line">cat &gt;&gt; a.txt &lt;&lt; <span class="string">xxx</span></span><br><span class="line"><span class="string">nihao hello hello 你好 </span></span><br><span class="line"><span class="string">nihao</span></span><br><span class="line"><span class="string">hello </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ls</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cd</span></span><br><span class="line"><span class="string">world</span></span><br><span class="line"><span class="string">pwd</span></span><br><span class="line"><span class="string">xxx</span></span><br></pre></td></tr></table></figure>
统计a.txt中各词的词频，并按照从大到小的顺序输出。

`cat a.txt | tr -s " " "\n" | sort | uniq -c | sort -n -r | awk '&#123;print $2, $1&#125;'`

`cat a.txt | tr  " " "\n" | grep -v "^$" | sort | uniq -c | sort -r`









# 八、软/硬链接



ext4文件系统将系统划分为inode、block、spuerblock（）

## 1.block

>文件是存储在硬盘上的，硬盘的最小存储单位叫做扇区`sector`，每个扇区存储`512字节`。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个块`block`。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是`4KB`，即连续八个`sector`组成一个`block`。



## 2.inode文件结点

> 文件数据存储在块中，那么还必须找到一个地方存储文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种存储文件元信息的区域就叫做`inode`，中文译名为`索引节点`，也叫`i节点`。因此，一个文件必须占用一个`inode`，但至少占用一个`block`。

- 元信息 → inode
- 数据 → block

------



>`inode`包含很多的文件元信息，但不包含文件名，例如：字节数、属主`UserID`、属组`GroupID`、读写执行权限、时间戳等。
>
>而文件名存放在目录当中，但`Linux`系统内部不使用文件名，而是使用`inode号码`识别文件。对于系统来说文件名只是`inode号码`便于识别的别称。





## 3.硬链接

> 通过文件系统的`inode`链接来产生的新的文件名，而不是产生新的文件，称为硬链接。
>
> 一般情况下，每个`inode`号码对应一个文件名，但是`Linux`允许多个文件名指向同一个`inode`号码。意味着可以使用不同的文件名访问相同的内容。



`ln 源文件 目标`



> 运行该命令以后，源文件与目标文件的`inode`号码相同，都指向同一个`inode`。`inode`信息中的链接数这时就会增加`1`。

> 当一个文件拥有多个硬链接时，对文件内容修改，会影响到所有文件名；但是删除一个文件名，不影响另一个文件名的访问。删除一个文件名，只会使得`inode`中的链接数减`1`。



> 需要注意的是不能对目录做硬链接。
>
> 通过`mkdir`命令创建一个新目录，其硬链接数应该有`2`个，因为常见的目录本身为`1`个硬链接，而目录下面的隐藏目录`.（点号）`是该目录的又一个硬链接，也算是`1`个连接数。
>
> 直观理解是，如果允许硬链接指向目录，假设目录.../d1/...与.../d2/...互为硬链接，那么在d1下必然包含目录项“..”，试问这个“..”应该指向d1还是d2?





## 4.软连接

类似于Windows的快捷方式功能的文件，可以快速连接到目标文件或目录，称为软链接。

`ln -s 源文件或目录 目标文件或目录`

>软链接就是再创建一个独立的文件，而这个文件会让数据的读取指向它连接的那个文件的文件名。
>
>例如，文件`A`和文件`B`的`inode`号码虽然不一样，但是文件`A`的内容是文件`B`的路径。读取文件`A`时，系统会自动将访问者导向文件`B`。这时，文件`A`就称为文件`B`的软链接`soft link`或者符号链接`symbolic link`。



>这意味着，文件`A`依赖于文件`B`而存在，如果删除了文件`B`，打开文件`A`就会报错。
>
>这是软链接与硬链接最大的不同：
>
>文件`A`指向文件`B`的文件名，而不是文件`B`的`inode`号码，
>
>文件`B`的`inode`链接数不会因此发生变化。







# 九、shell实现线性筛



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [[ $# -ne 2 ]];then</span><br><span class="line">	echo &quot;Usage: $0 start end&quot;</span><br><span class="line">	exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">start=$1</span><br><span class="line">end=$2</span><br><span class="line"></span><br><span class="line">declare -a prime</span><br><span class="line">sum=0</span><br><span class="line">for (( i=2; i&lt;=$&#123;end&#125;; i++ ));do</span><br><span class="line">	if [[ $&#123;prime[$i]&#125;x == x ]];then</span><br><span class="line">		prime[0]=$[ $&#123;prime[0]&#125; + 1 ]</span><br><span class="line"><span class="meta">		prime[$</span><span class="bash">&#123;prime[0]&#125;]=<span class="variable">$&#123;i&#125;</span></span></span><br><span class="line">	fi</span><br><span class="line">	for (( j=1; j&lt;=$&#123;prime[0]&#125;; j++ ));do</span><br><span class="line">		if [[ $[ $i * $&#123;prime[$j]&#125; ] -gt $&#123;end&#125; ]];then</span><br><span class="line">			break;</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">	done</span><br><span class="line">done</span><br><span class="line">for (( i=1; i&lt;=$&#123;prime[0]&#125;; i++ ));do</span><br><span class="line">	sum=$[ $&#123;sum&#125; + $&#123;prime[$i]&#125; ]</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure>






# 十、seq









1.替换文件每行中第一个出现的正则表达式，并打印结果:
`sed 's/&#123;&#123;regex&#125;&#125;/&#123;&#123;replace&#125;&#125;/&#39; &#123;&#123;filename&#125;&#125;</code></p>
</blockquote>
<p>2.***Replace all occurrences of an extended regular expression in a file, and print the result:<br><code>sed -r &#39;s/&#123;&#123;regex&#125;&#125;/&#123;&#123;replace&#125;&#125;/g&#39; &#123;&#123;filename&#125;&#125;</code></p>
<p><code>/g</code>全局替换</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">at a.log | sed <span class="string">&#x27;s/abc/123/&#x27;</span>                  </span><br><span class="line">123123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"> </span><br><span class="line">123</span><br><span class="line"></span><br><span class="line"> cat a.log | sed -r <span class="string">&#x27;s/abc/123/g&#x27;</span>                                         </span><br><span class="line">123123  123</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"> </span><br><span class="line">123</span><br></pre></td></tr></table></figure>


<p>3.Replace all occurrences of a string in a file, overwriting the file (i.e. in-place):<br><code>sed -i &#39;s/&#123;&#123;find&#125;&#125;/&#123;&#123;replace&#125;&#125;/g&#39; &#123;&#123;filename&#125;&#125;</code></p>
<p>4.- Replace only on lines matching the line pattern:<br>   <code>sed &#39;/&#123;&#123;line_pattern&#125;&#125;/s/&#123;&#123;find&#125;&#125;/&#123;&#123;replace&#125;&#125;/&#39; &#123;&#123;filename&#125;&#125;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed  &#x27;/1/s/abc/123/&#x27; a.log                                                                          </span><br><span class="line">123123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">cat a.log                                                                                         </span><br><span class="line">abc123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abc</span><br></pre></td></tr></table></figure>


<p>替换常用</p>
<ol start="5">
<li>***Delete lines matching the line pattern:<br><code>sed &#39;/&#123;&#123;line_pattern&#125;&#125;/d&#39; &#123;&#123;filename&#125;&#125;</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除5-7行</span></span><br><span class="line">apricity@Apricity test % cat a.log | sed &quot;5,7d&quot;                         </span><br><span class="line">abc123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apricity@Apricity test % cat a.log                                       </span><br><span class="line">abc123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">script</span></span><br><span class="line">echo &quot;abc&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">END</span></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">只删一行</span></span><br><span class="line">apricity@Apricity test % cat a.log | sed &quot;/script/d&quot;                                                                          [0]</span><br><span class="line">abc123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"></span><br><span class="line">echo &quot;abc&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">END</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure>


<p>6.***Replace separator / by any other character not used in the find or replace patterns, e.g., #: </p>
<p><code>sed &#39;s#&#123;&#123;find&#125;&#125;#&#123;&#123;replace&#125;&#125;#&#39; &#123;&#123;filename&#125;&#125;</code></p>
<p>可以用<code>#.,</code>代替<code>/</code></p>
<p>7.Print the first 11 lines of a file:<br><code>sed 11q &#123;&#123;filename&#125;&#125;</code></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-08%20%E4%B8%8A%E5%8D%8811.53.06.png" alt="截屏2020-12-08 上午11.53.06"></p>
<p>将123全部替换为abc</p>
<p>8.将行首替换为<code>$</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/^/\$/g&#x27; a.log                                                       </span><br><span class="line"><span class="meta">$</span><span class="bash">abc123  abc</span></span><br><span class="line"><span class="meta">$</span><span class="bash">frrrrrrtyd</span></span><br><span class="line"><span class="meta">$</span><span class="bash">axcvrewgfdddddds</span></span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="bash"><span class="variable">$#script</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;abc&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="comment">#END</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">abc</span></span><br></pre></td></tr></table></figure>




<p>9.找到//里面的内容并且删除直到行尾</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> cat a.log | sed &#x27;/script/,$d&#x27;                                           </span><br><span class="line">abc123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"></span><br></pre></td></tr></table></figure>








<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><h2 id="1-vim"><a href="#1-vim" class="headerlink" title="1.vim"></a>1.vim</h2><p>快速跳转：</p>
<blockquote>
<p>行首                    0</p>
<p>行尾                    $</p>
<p>文件开始      gg</p>
<p>文件末尾        GG</p>
<p>任意行                :12,12G</p>
</blockquote>
<p>复制</p>
<blockquote>
<p>拷贝         yy</p>
<p>剪切            dd</p>
<p>多行操作   3yy/dd</p>
</blockquote>
<p>删除</p>
<blockquote>
<p>x  删除</p>
<p>2dd</p>
<p>d2G         删除两行</p>
</blockquote>
<p>vimtuter帮助手册</p>
<p>linux</p>
<blockquote>
<p>linux历史     </p>
<p>linux本质：linux内核操作系统，其他功能是各开发商开发</p>
<p>unix：云计算后开始减少</p>
</blockquote>
<h2 id="2-shell"><a href="#2-shell" class="headerlink" title="2.shell"></a>2.shell</h2><p>zsh</p>
<blockquote>
<p>zsh相关文件</p>
<blockquote>
<p>zshenv：一般放环境变量</p>
<p>zprofile：用于用户login时读入（执行）的配置</p>
<p>zshrc：用户开启交互是命令行时读入的配置</p>
</blockquote>
<p>环境变量概念:</p>
<p>环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。</p>
<p>执行命令的本质：从文件系统调用执行文件，返回结果</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-15%20%E4%B8%8A%E5%8D%8811.47.50.png" alt="截屏2020-12-15 上午11.47.50"></p>
<p>僵尸进程，父亲生了孩子，孩子没有被回收</p>
<p>man手册</p>
<blockquote>
<p>man  </p>
<p>tldr</p>
<p>man -k</p>
<p>检索   前后移动</p>
<p>Baidu</p>
<p>查找命令</p>
<p>tab          自动补全命令</p>
<p>man -k</p>
<ul>
<li>man -k：根据关键字搜索联机帮助，是一种模糊搜索。例如要查找”passwd”相关的信息，使用man -k passwd会找到很多和passwd相关的帮助页。</li>
<li>man -f：关键字精确搜索，与-k不同，它只搜索与关键字完全匹配的帮助页</li>
</ul>
</blockquote>
<h2 id="3-linux具体使用"><a href="#3-linux具体使用" class="headerlink" title="3.linux具体使用"></a>3.linux具体使用</h2><p>文件及目录</p>
<p>远程拷贝ssh  、sshfs、scp</p>
<p>sshfs:远程挂载</p>
<p>文件查阅  <a href="#3.%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E9%98%85">查阅</a></p>
<blockquote>
<p><code>cat</code></p>
<p><code>head</code></p>
<ul>
<li>-n&lt;行数&gt; 显示的行数。</li>
</ul>
<p><code>tail</code></p>
<ul>
<li>-n&lt;行数&gt; 显示文件的尾部 n 行内容</li>
</ul>
<p><code>tail -f</code></p>
<ul>
<li><p>-f 循环读取</p>
</li>
<li><pre><code>tail -f notes.log
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  此命令显示 notes.log 文件的最后 10 行。当将某些行添加至 notes.log 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。</span><br><span class="line"></span><br><span class="line">&#96;more&#96; </span><br><span class="line"></span><br><span class="line">&#96;less&#96;可回看、检索信息高亮显示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">移动和复制</span><br><span class="line"></span><br><span class="line">&#96;cp&#96;</span><br><span class="line"></span><br><span class="line">&#96;mv&#96;</span><br><span class="line"></span><br><span class="line">&#96;ln&#96;硬链接，软链接</span><br><span class="line"></span><br><span class="line">&#96;rm&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件类型及权限  </span><br><span class="line"></span><br><span class="line">七种：</span><br><span class="line"></span><br><span class="line">普通文件</span><br><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">字符</span><br><span class="line"></span><br><span class="line">块</span><br><span class="line"></span><br><span class="line">管道</span><br><span class="line"></span><br><span class="line">链接</span><br><span class="line"></span><br><span class="line">socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">权限 &#96;rwx&#96;   </span><br><span class="line"></span><br><span class="line">&gt;目录&#96;x&#96;可以&#96;cd&#96;进去</span><br><span class="line"></span><br><span class="line">&gt;用户分组 &#96;ugo&#96;</span><br><span class="line"></span><br><span class="line">&gt;命令</span><br><span class="line"></span><br><span class="line">&gt;&#96;chmod、chgrp、chown、usermod&#96;</span><br><span class="line"></span><br><span class="line">&gt;特殊权限：</span><br><span class="line"></span><br><span class="line">&gt;&#96;set uid&#96;</span><br><span class="line"></span><br><span class="line">&gt;只能改自己的权限</span><br><span class="line"></span><br><span class="line">&gt;&#96;set gid&#96;		用户临时进入目录时，创建一个文件时，该用户会临时变成目录所属组</span><br><span class="line"></span><br><span class="line">&gt;&#96;sed uid&#96;		当用户执行文件时，用户临时拥有此文件，如密码文件</span><br><span class="line"></span><br><span class="line">&gt;&#96;sbit&#96;黏着位		目录下的文件只能被所属者删掉</span><br><span class="line"></span><br><span class="line">&gt;隐藏属性  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.文件时间</span><br><span class="line"></span><br><span class="line">&#96;atime&#96;		访问时间，跟新过于频繁也不好，耗时</span><br><span class="line"></span><br><span class="line">&#96;ctime&#96;		修改时间</span><br><span class="line"></span><br><span class="line">&#96;mtime&#96;		修正时间   ls默认</span><br><span class="line"></span><br><span class="line">&#96;touch&#96;       创建文件，修改时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件定位：</span><br><span class="line"></span><br><span class="line">特殊文件：</span><br><span class="line"></span><br><span class="line">&#96;which&#96;</span><br><span class="line"></span><br><span class="line">&#96;whereis&#96;</span><br><span class="line"></span><br><span class="line">普通文件</span><br><span class="line"></span><br><span class="line">&#96;locate&#96;  	db updatedb(基于数据库)</span><br><span class="line"></span><br><span class="line">&#96;find&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据处理[数据提取操作](#七、数据提取操作)</span><br><span class="line"></span><br><span class="line">cut		</span><br><span class="line"></span><br><span class="line">tr</span><br><span class="line"></span><br><span class="line">sort</span><br><span class="line"></span><br><span class="line">uniq</span><br><span class="line"></span><br><span class="line">grep</span><br><span class="line"></span><br><span class="line">awk</span><br><span class="line"></span><br><span class="line">sed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重定向</span><br><span class="line"></span><br><span class="line">\&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&gt;&gt;</span><br><span class="line"></span><br><span class="line">&lt;</span><br><span class="line"></span><br><span class="line">&lt;&lt;</span><br><span class="line"></span><br><span class="line">&#x2F;\&#96;a\&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读入数据:read</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">vim 1.sh</span><br><span class="line">read a</span><br><span class="line">read b</span><br><span class="line">echo$[ $a + $b ]</span><br><span class="line"></span><br><span class="line">vim 1.in</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">bash 1.sh &lt; 1.in</span><br><span class="line">5</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim 2.sh</span><br><span class="line">str=&#x27;&#x27;</span><br><span class="line">read str</span><br><span class="line">echo $&#123;str&#125;</span><br><span class="line">vim 2.in</span><br><span class="line">guziqiu is 18years old.</span><br><span class="line"></span><br><span class="line">bash 2.sh &lt; 2.in</span><br></pre></td></tr></table></figure>






<p>进程管理</p>
<blockquote>
<p><code>fg</code></p>
<p><code>bg</code></p>
<p><code>jobs</code></p>
</blockquote>
<p>定时任务</p>
<blockquote>
<p>crontab -e</p>
</blockquote>
<p>系统信息获取</p>
<blockquote>
<p><code>unname</code></p>
<p><code>top</code></p>
<p><code>free</code></p>
<p><code>dstat</code></p>
<p><code>htop</code></p>
<p><code>nmon</code></p>
<p><code>uptime</code></p>
</blockquote>
<h2 id="4-shell编程"><a href="#4-shell编程" class="headerlink" title="4.shell编程"></a>4.shell编程</h2><p>变量</p>
<blockquote>
<p>命令替换符</p>
<p>特殊变量</p>
<p><code>$0￥</code></p>
<p><code>$#</code></p>
<p><code>$?</code></p>
<p><code>$@</code></p>
<p><code>$*</code></p>
</blockquote>
<p>=两边没有空格</p>
<p>输入输出</p>
<blockquote>
<p>read </p>
<p>echo </p>
<p>printf </p>
</blockquote>
<p>分支</p>
<blockquote>
<p>test表达式 </p>
<p>​        man test</p>
<p>整数判断：整数计算</p>
<p>字符串     ==</p>
</blockquote>
<blockquote>
<p>if [[  ]]</p>
</blockquote>
<blockquote>
<p>case</p>
</blockquote>
<p>循环 for </p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in `seq 1 100`</span><br></pre></td></tr></table></figure>

<p><code>for (( i =1;  i&lt;= 100;i++ ))</code>(推荐)</p>
<p><code>while</code></p>
<p><code>until</code></p>
</blockquote>
<p>函数</p>
<p>数组</p>
<blockquote>
<p>数组初始化</p>
<p>unset</p>
<p>遍历</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/1.png" alt="1"></p>
]]></content>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>高级数据结构</title>
    <url>/2021/01/18/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>2020.12.22</p>
<h1 id="1-BS二叉排序树"><a href="#1-BS二叉排序树" class="headerlink" title="1.BS二叉排序树"></a>1.BS二叉排序树</h1><p>二叉排序树、二叉搜索树、二叉查找树 、Binary Search Tree</p>
<p>数据结构定义一种性质,并且维护这种性质</p>
<a id="more"></a>

<h2 id="1-性质"><a href="#1-性质" class="headerlink" title="1.性质"></a>1.性质</h2><blockquote>
<p>1.左子树 &lt; 根节点</p>
<p>2.根节点 &lt; 右子树</p>
<p>3.中序遍历的结果，是一个有序序列</p>
</blockquote>
<blockquote>
<p>用途：解决与排名相关的检索需求</p>
</blockquote>
<blockquote>
<p>树型结构：边代表关系，点代表集合</p>
</blockquote>
<h2 id="2-BS插入操作"><a href="#2-BS插入操作" class="headerlink" title="2.BS插入操作"></a>2.BS插入操作</h2><blockquote>
<p>1.插入新节点，一定会作为叶子节点</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%886.39.38.png" alt="截屏2020-12-19 下午6.39.38"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;data) root-&gt;lchild = insert(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, val);</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-BS删除操作"><a href="#3-BS删除操作" class="headerlink" title="3.BS删除操作"></a>3.BS删除操作</h2><blockquote>
<p>1.删除叶子节点:直接删除，</p>
<p>2.删除度为1的节点：把孤儿树挂到父节点上面</p>
<p>（更新孩子节点的和父亲节点）</p>
<p>3.删除度为2的结点：找到前驱或者后继替换后转换为度为 0或1的结点问题</p>
</blockquote>
<p>对于度为2 的节点：</p>
<blockquote>
<p>1.前驱：左子树中的最大值</p>
<p>2.后继：右子树中的最小值</p>
</blockquote>
<p>前驱没有右子树，后驱没有左子树，前驱和者后继度为0或1</p>
<p>节点查找次数的期望值：</p>
<blockquote>
<p>平均查找效率：总查找次数(1 + 2 * 节点数 + 3 * 节点数… )/总节点数(n) </p>
<p>$\frac{总查找次数}{节点数}$</p>
<p>假设每个结点等概率被查找</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%8811.15.08.png" alt="截屏2020-12-19 下午11.15.08"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%8811.19.16.png" alt="截屏2020-12-19 下午11.19.16"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%884.46.47.png" alt="截屏2020-12-21 下午4.46.47"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;rchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//找到结点</span></span><br><span class="line">       <span class="comment">/* if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) &#123;</span></span><br><span class="line"><span class="comment">            free(root);</span></span><br><span class="line"><span class="comment">            return NULL;</span></span><br><span class="line"><span class="comment">        &#125; else */</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;<span class="comment">//返回删除节点的孩子节点，将孩子结点挂载到被删除节点的父亲节点上</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//将两个结点的情况转换为一个结点</span></span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-BS代码演示"><a href="#4-BS代码演示" class="headerlink" title="4.BS代码演示"></a>4.BS代码演示</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;data : 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = _data;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) <span class="keyword">return</span> search(root-&gt;lchild, value);</span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;data) root-&gt;lchild = insert(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//前驱</span></span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span>(temp &amp;&amp; temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;rchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//找到结点</span></span><br><span class="line">       <span class="comment">/* if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) &#123;</span></span><br><span class="line"><span class="comment">            free(root);</span></span><br><span class="line"><span class="comment">            return NULL;</span></span><br><span class="line"><span class="comment">        &#125; else */</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;<span class="comment">//返回删除节点的孩子节点，将孩子结点挂载到被删除节点的父亲节点上</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//将两个结点的情况转换为一个结点</span></span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, root-&gt;data);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output1</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output1(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d,%d)\n&quot;</span>, KEY(root), KEY(root-&gt;lchild), KEY(root-&gt;rchild));</span><br><span class="line">    output1(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;<span class="comment">//!!!!!!!!!!!!!!!</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="comment">//0：查找 1：插入 2： 删除</span></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d \n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;insert: %d \n&quot;</span>, val);</span><br><span class="line">                   root = insert(root, val);</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">               &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;erase: %d \n&quot;</span>, val);</span><br><span class="line">                   root = erase(root, val);</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\ntree ==&gt; [&quot;</span>);</span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op) output1(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="5-BS解决排名相关的需求"><a href="#5-BS解决排名相关的需求" class="headerlink" title="5.BS解决排名相关的需求"></a>5.BS解决排名相关的需求</h2><p>输出第k大的元素</p>
<ol>
<li>修改二叉排序树的结构定义，增加 size 字段，记录每棵树的节点数量</li>
<li>$k - 1= LS$，根节点就是排名第 k 位的元素</li>
<li>$k \le LS$，排名第 k 位的元素在左子树中</li>
<li>$k \gt LS，search_k(root-&gt;rchild, k - LS - 1)$</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;data : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(n) (n ? n-&gt;size : 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = _data;</span><br><span class="line">    p-&gt;size = <span class="number">1</span>;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) <span class="keyword">return</span> search(root-&gt;lchild, value);</span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (SIZE(root-&gt;lchild) == k - <span class="number">1</span>) <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(root-&gt;lchild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> search_k(root-&gt;lchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search_k(root-&gt;rchild, k - SIZE(root-&gt;lchild) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_size</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;size = SIZE(root-&gt;lchild)  + SIZE(root-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;data) root-&gt;lchild = insert(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, val);</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//前驱</span></span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span>(temp &amp;&amp; temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;rchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//找到结点</span></span><br><span class="line">       <span class="comment">/* if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) &#123;</span></span><br><span class="line"><span class="comment">            free(root);</span></span><br><span class="line"><span class="comment">            return NULL;</span></span><br><span class="line"><span class="comment">        &#125; else */</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;<span class="comment">//返回删除节点的孩子节点，将孩子结点挂载到被删除节点的父亲节点上</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//将两个结点的情况转换为一个结点</span></span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d[%d] &quot;</span>, root-&gt;data, SIZE(root));</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output1</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output1(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d],%d,%d)\n&quot;</span>, KEY(root), SIZE(root), KEY(root-&gt;lchild), KEY(root-&gt;rchild));</span><br><span class="line">    output1(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="comment">//0：查找 1：插入 2： 删除</span></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d \n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;insert: %d \n&quot;</span>, val);</span><br><span class="line">                   root = insert(root, val);</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">               &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;erase: %d \n&quot;</span>, val);</span><br><span class="line">                   root = erase(root, val);</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;search k = %d, result : %d\n&quot;</span>,</span><br><span class="line">                    val, search_k(root, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\ntree ==&gt; [&quot;</span>);</span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op) output1(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">insert: <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">insert: <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">2</span>] <span class="number">2</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"> <span class="number">1</span> <span class="number">3</span></span><br><span class="line">insert: <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">3</span>] <span class="number">2</span>[<span class="number">2</span>] <span class="number">3</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">3</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line">insert: <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">4</span>] <span class="number">2</span>[<span class="number">3</span>] <span class="number">3</span>[<span class="number">2</span>] <span class="number">4</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">4</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">3</span>],<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line">insert: <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">5</span>] <span class="number">2</span>[<span class="number">4</span>] <span class="number">3</span>[<span class="number">3</span>] <span class="number">4</span>[<span class="number">2</span>] <span class="number">5</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">5</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">4</span>],<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>[<span class="number">3</span>],<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="number">5</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line">search k = <span class="number">1</span>, result : <span class="number">1</span></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">5</span>] <span class="number">2</span>[<span class="number">4</span>] <span class="number">3</span>[<span class="number">3</span>] <span class="number">4</span>[<span class="number">2</span>] <span class="number">5</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">5</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">4</span>],<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>[<span class="number">3</span>],<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="number">5</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line">search k = <span class="number">2</span>, result : <span class="number">2</span></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">5</span>] <span class="number">2</span>[<span class="number">4</span>] <span class="number">3</span>[<span class="number">3</span>] <span class="number">4</span>[<span class="number">2</span>] <span class="number">5</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">5</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">4</span>],<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>[<span class="number">3</span>],<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="number">5</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line">search k = <span class="number">4</span>, result : <span class="number">4</span></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">5</span>] <span class="number">2</span>[<span class="number">4</span>] <span class="number">3</span>[<span class="number">3</span>] <span class="number">4</span>[<span class="number">2</span>] <span class="number">5</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">5</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">4</span>],<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>[<span class="number">3</span>],<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="number">5</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br></pre></td></tr></table></figure>




<h2 id="6-BS解决Top-K-问题"><a href="#6-BS解决Top-K-问题" class="headerlink" title="6.BS解决Top-K 问题"></a>6.BS解决Top-K 问题</h2><p>（找到小于第 k 位的所有元素）</p>
<ol>
<li>根节点就是第 k 位元素的话，就把左子树中的值全部输出出来</li>
<li>第 k 位在左子树中，前 k 位元素全都在左子树中</li>
<li>第 k 位在右子树中，说明根节点和左子树中的元素，都是前 k 位元素里面的值</li>
</ol>
<p>所谓算法设计及分析能力：分类讨论及归纳总结的能力</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;data : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(n) (n ? n-&gt;size : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(n) (n ? n-&gt;lchild : NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = _data;</span><br><span class="line">    p-&gt;size = <span class="number">1</span>;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) <span class="keyword">return</span> search(root-&gt;lchild, value);</span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (SIZE(root-&gt;lchild) == k - <span class="number">1</span>) <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(root-&gt;lchild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> search_k(root-&gt;lchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search_k(root-&gt;rchild, k - SIZE(root-&gt;lchild) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_size</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;size = SIZE(root-&gt;lchild)  + SIZE(root-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;data) root-&gt;lchild = insert(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, val);</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//前驱</span></span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild =  erase(root-&gt;lchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;rchild =  erase(root-&gt;rchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//找到结点</span></span><br><span class="line">       <span class="comment">/* if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) &#123;</span></span><br><span class="line"><span class="comment">            free(root);</span></span><br><span class="line"><span class="comment">            return NULL;</span></span><br><span class="line"><span class="comment">        &#125; else */</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;<span class="comment">//返回删除节点的孩子节点，将孩子结点挂载到被删除节点的父亲节点上</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//将两个结点的情况转换为一个结点</span></span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d[%d] &quot;</span>, root-&gt;data, SIZE(root));</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d], %d, %d)\n&quot;</span>,</span><br><span class="line">           KEY(root), SIZE(root),</span><br><span class="line">           KEY(root-&gt;lchild), KEY(root-&gt;rchild)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output1</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output1(root-&gt;lchild);</span><br><span class="line">    print(root);</span><br><span class="line">    output1(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span> || root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(root-&gt;lchild)) output_k(root-&gt;lchild, k);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        output1(root-&gt;lchild);</span><br><span class="line">        print(root);</span><br><span class="line">        output_k(root-&gt;rchild, k - SIZE(root-&gt;lchild) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="comment">//0：查找 1：插入 2： 删除</span></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d \n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;insert: %d \n&quot;</span>, val);</span><br><span class="line">                   root = insert(root, val);</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">               &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;erase: %d \n&quot;</span>, val);</span><br><span class="line">                   root = erase(root, val);</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;search k = %d, result : %d\n&quot;</span>,</span><br><span class="line">                    val, search_k(root, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;output top-%d elements\n&quot;</span>, val);</span><br><span class="line">                output_k(root, val);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;------------\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\ntree ==&gt; [&quot;</span>);</span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op) output1(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="7-二叉排序树和快排的关系"><a href="#7-二叉排序树和快排的关系" class="headerlink" title="7.二叉排序树和快排的关系"></a>7.二叉排序树和快排的关系</h2><ol>
<li><p>二叉排序树是快速排序在思维逻辑结构层面用的数据结构</p>
</li>
<li><p>思考1：快速排序的时间复杂度和二叉排序树建树时间复杂度之间的关系</p>
</li>
</ol>
<ol start="3">
<li>思考2：快速选择算法和二叉排序树之间的关系</li>
</ol>
<ol start="4">
<li>程序=算法+数据结构</li>
</ol>
<h1 id="2-AVL平衡二叉查找树"><a href="#2-AVL平衡二叉查找树" class="headerlink" title="2.AVL平衡二叉查找树"></a>2.AVL平衡二叉查找树</h1><p>1962年（58）</p>
<p>==<strong>AVL树</strong>==</p>
<h2 id="0-AVL树原理"><a href="#0-AVL树原理" class="headerlink" title="0.AVL树原理"></a>0.AVL树原理</h2><blockquote>
<p>AVL树原理</p>
<p>自平衡条件、旋转操作、旋转的触发</p>
</blockquote>
<p>数据机构：定义一种性质并且维护一种性质</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1.左右子树高度差 小于等于 1</p>
<p>2.平衡二叉排序树，本质上也是二叉排序树，所以拥有二叉排序树的所有性质</p>
<p>3.平衡二叉排序树的学习重点：平衡条件以及平衡调整</p>
<blockquote>
<p>高度为H的BS树所包含的结点数量在什么范围内： $H \le SIZE \le 2^H-1$</p>
<p>高度为H的AVL树所包含的结点数量在什么范围内:  $1.5^H \le SIZE \le 2^H-1$</p>
<p>$low(H) \le SIZE \le 2^H-1$</p>
<p>$low(H-1) + low(H - 2) + 1\le SIZE \le 2^H-1$（斐波那契数列）</p>
<p>$1.5^H \le SIZE \le 2^H-1$</p>
</blockquote>
<p>二叉树性质：二叉树第i层最多有2^i-1^个结点，深度为k最多有2^k^-1个结点</p>
<p>==&gt;AVL节点数n和树高h的关系:h = logn</p>
<p>思考：</p>
<ol>
<li>AVL 树改进的是节点数量的下限</li>
<li>树高 = 生命长度，节点数量 = 生命财富，不同的算法，达到的结果是不同的</li>
<li>教育提升的是底限，而不是上限，上限取决于能力和运气</li>
</ol>
<h2 id="1-自平衡条件"><a href="#1-自平衡条件" class="headerlink" title="1.自平衡条件"></a>1.自平衡条件</h2><h3 id="1-平衡因子"><a href="#1-平衡因子" class="headerlink" title="1.平衡因子"></a>1.平衡因子</h3><p>每个平衡因子的是指左子树最大高度和右子树最大高度差，平衡因子为-1，0，1被认为是平衡的</p>
<h3 id="2-失衡类型"><a href="#2-失衡类型" class="headerlink" title="2.失衡类型"></a>2.失衡类型</h3><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.08.06.png" alt="截屏2020-12-23 下午6.08.06" style="zoom:67%;" />

<h2 id="2-旋转操作：单旋和多旋"><a href="#2-旋转操作：单旋和多旋" class="headerlink" title="2.旋转操作：单旋和多旋"></a>2.旋转操作：单旋和多旋</h2><h3 id="1-单旋"><a href="#1-单旋" class="headerlink" title="1.单旋"></a>1.单旋</h3><p>分为左旋和右旋。AVL树通过一系列的左旋和右旋操作，将不平衡的树调整为二叉查找树</p>
<h4 id="左旋："><a href="#左旋：" class="headerlink" title="左旋："></a>左旋：</h4><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.03.51.png" alt="截屏2020-12-23 下午6.03.51" style="zoom:50%;" />

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.32.31.png" alt="截屏2020-12-21 下午6.32.31" style="zoom: 67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.32.25.png" alt="截屏2020-12-21 下午6.32.25" style="zoom:67%;" />



<h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.03.57.png" alt="截屏2020-12-23 下午6.03.57" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.37.45.png" alt="截屏2020-12-21 下午6.37.45" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.37.41.png" alt="截屏2020-12-21 下午6.37.41" style="zoom:67%;" />



<h3 id="2-多旋："><a href="#2-多旋：" class="headerlink" title="2.多旋："></a>2.多旋：</h3><p>由两次单旋操作组合而成</p>
<h4 id="1-左旋加右旋LR"><a href="#1-左旋加右旋LR" class="headerlink" title="1.左旋加右旋LR"></a>1.左旋加右旋LR</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8812.38.14.png" alt="截屏2020-12-24 下午12.38.14" style="zoom:75%;" /></h4><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.10.27.png" alt="截屏2020-12-23 下午6.10.27" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/26252FD93F9BE46395BB71A8E8888D4A.jpg" alt="26252FD93F9BE46395BB71A8E8888D4A" style="zoom:67%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.45.05.png" alt="截屏2020-12-21 下午6.45.05" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.45.01.png" alt="截屏2020-12-21 下午6.45.01" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.45.10.png" alt="截屏2020-12-21 下午6.45.10" style="zoom:67%;" />



<h4 id="2-右旋加左旋RL"><a href="#2-右旋加左旋RL" class="headerlink" title="2.右旋加左旋RL"></a>2.右旋加左旋RL</h4><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.47.47.png" alt="截屏2020-12-21 下午6.47.47" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.47.42.png" alt="截屏2020-12-21 下午6.47.42" style="zoom:67%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.47.52.png" alt="截屏2020-12-21 下午6.47.52" style="zoom:67%;" />



<h4 id="3-LL"><a href="#3-LL" class="headerlink" title="3. LL"></a>3. LL</h4><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.10.21.png" alt="截屏2020-12-23 下午6.10.21" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/209777F2C379C9542061B8B56572755E.jpg" alt="209777F2C379C9542061B8B56572755E" style="zoom:67%;" />









<h4 id="4-RR与LL对称"><a href="#4-RR与LL对称" class="headerlink" title="4.RR与LL对称"></a>4.RR与LL对称</h4><h2 id="3-旋转的触发"><a href="#3-旋转的触发" class="headerlink" title="3.旋转的触发"></a>3.旋转的触发</h2><p>插入操作：</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.58.33.png" alt="截屏2020-12-21 下午6.58.33"></p>
<p>删除操作：</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.58.42.png" alt="截屏2020-12-21 下午6.58.42"></p>
<blockquote>
<p>平衡调整策略/方法</p>
<ol>
<li>发生在回溯阶段的，第一个失衡节点处</li>
<li>理解平衡调整策略的关键在于：分析清楚四种情况下，ABCD 四棵子树树高的关系</li>
<li>LL，大右旋</li>
<li>LR，先小左旋，再大右旋</li>
<li>RL，先小右旋，再大左旋</li>
<li>RR，大左旋</li>
</ol>
</blockquote>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.22.17.png" alt="截屏2020-12-23 下午6.22.17" style="zoom:67%;" />







<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;<span class="comment">//假的空节点</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL-&gt;data = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;height = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;</span><br><span class="line">    Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = _data;</span><br><span class="line">    node-&gt;lchild = node-&gt;rchild = NIL;</span><br><span class="line">    node-&gt;height = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_height</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;height = (root-&gt;lchild-&gt;height &gt; root-&gt;rchild-&gt;height ? root-&gt;lchild-&gt;height : root-&gt;rchild-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    update_height(root);</span><br><span class="line">    update_height(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//对称</span></span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    update_height(root);</span><br><span class="line">    update_height(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(root-&gt;lchild-&gt;height - root-&gt;rchild-&gt;height) &lt;= <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;height &gt; root-&gt;rchild-&gt;height) &#123;<span class="comment">//L大左旋</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;lchild-&gt;height &lt; root-&gt;lchild-&gt;rchild-&gt;height)<span class="comment">//LR小右旋</span></span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;rchild-&gt;height &lt; root-&gt;lchild-&gt;rchild-&gt;height)<span class="comment">//RL小左旋</span></span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;lchild);<span class="comment">//小右旋</span></span><br><span class="line">        root = left_rotate(root);<span class="comment">//大左旋</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == val) <span class="keyword">return</span> root;<span class="comment">//不需要插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = insert(root-&gt;lchild, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;rchild = insert(root-&gt;rchild, val);</span><br><span class="line">    &#125;</span><br><span class="line">    update_height(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp &amp;&amp; temp-&gt;lchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> NIL;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;rchild = erase(root-&gt;rchild, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild != NIL ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_height(root);</span><br><span class="line">    <span class="keyword">return</span> maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d],%d,%d)\n&quot;</span>,</span><br><span class="line">           root-&gt;data, root-&gt;height,</span><br><span class="line">           root-&gt;lchild-&gt;data,</span><br><span class="line">           root-&gt;rchild-&gt;data);</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: root = erase(root, val);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: root = insert(root, val);</span><br><span class="line">        &#125;</span><br><span class="line">        output(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


















<h1 id="3-SBTree"><a href="#3-SBTree" class="headerlink" title="3*.SBTree"></a>3*.SBTree</h1><p>Size Balanced Tree</p>
<h2 id="1-平衡原理"><a href="#1-平衡原理" class="headerlink" title="1.平衡原理"></a>1.平衡原理</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.20.58.png" alt="截屏2020-12-22 上午10.20.58"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.21.30.png" alt="截屏2020-12-22 上午10.21.30"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.25.01.png" alt="截屏2020-12-22 上午10.25.01"></p>
<h2 id="2-旋转操作"><a href="#2-旋转操作" class="headerlink" title="2.旋转操作"></a>2.旋转操作</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.26.35.png" alt="截屏2020-12-22 上午10.26.35"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.26.45.png" alt="截屏2020-12-22 上午10.26.45"></p>
<h2 id="3-旋转的触发-1"><a href="#3-旋转的触发-1" class="headerlink" title="3.旋转的触发"></a>3.旋转的触发</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.28.20.png" alt="截屏2020-12-22 上午10.28.20"></p>
<h2 id="4-代码实现-1"><a href="#4-代码实现-1" class="headerlink" title="4.代码实现"></a>4.代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SBTNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Type data;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    SBTNode&lt;Type&gt; *lchild, *rchild, *father;</span><br><span class="line">    SBTNode(Type init_data, <span class="keyword">int</span> init_size = <span class="number">0</span>, SBTNode&lt;Type&gt; *init_father = <span class="literal">NULL</span>);</span><br><span class="line">    ~SBTNode();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Type value)</span></span>;</span><br><span class="line">    <span class="function">SBTNode&lt;Type&gt;* <span class="title">search</span><span class="params">(Type value)</span></span>;</span><br><span class="line">    <span class="function">SBTNode&lt;Type&gt;* <span class="title">predecessor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">SBTNode&lt;Type&gt;* <span class="title">successor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_node</span><span class="params">(SBTNode&lt;Type&gt; *delete_node)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(Type value)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SBTNode&lt;Type&gt;* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinaryTree();</span><br><span class="line">    ~BinaryTree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Type value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(Type value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(Type value)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SBTNode&lt;<span class="keyword">int</span>&gt; <span class="title">ZERO</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">SBTNode&lt;<span class="keyword">int</span>&gt;* NIL = &amp;ZERO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">SBTNode&lt;Type&gt;::SBTNode(Type init_data, <span class="keyword">int</span> init_size, SBTNode&lt;Type&gt;* init_father) &#123;</span><br><span class="line">    data = init_data;</span><br><span class="line">    size = init_size;</span><br><span class="line">    lchild = NIL;</span><br><span class="line">    rchild = NIL;</span><br><span class="line">    father = init_father;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">SBTNode&lt;Type&gt;::~SBTNode() &#123;</span><br><span class="line">    <span class="keyword">if</span> (lchild != NIL) &#123;</span><br><span class="line">        <span class="keyword">delete</span> lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rchild != NIL) &#123;</span><br><span class="line">        <span class="keyword">delete</span> rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">SBTNode&lt;Type&gt;* <span class="title">left_rotate</span><span class="params">(SBTNode&lt;Type&gt;* node)</span> </span>&#123;</span><br><span class="line">	SBTNode&lt;Type&gt; *temp =  node-&gt;rchild;</span><br><span class="line">    node-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild-&gt;father = node;</span><br><span class="line">    temp-&gt;lchild = node;</span><br><span class="line">    temp-&gt;father = node-&gt;father;</span><br><span class="line">    node-&gt;father = temp;</span><br><span class="line">    temp-&gt;size = node-&gt;size;</span><br><span class="line">    node-&gt;size = node-&gt;lchild-&gt;size + node-&gt;rchild-&gt;size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">SBTNode&lt;Type&gt;* <span class="title">right_rotate</span><span class="params">(SBTNode&lt;Type&gt;* node)</span> </span>&#123;</span><br><span class="line">  	SBTNode&lt;Type&gt; *temp = node-&gt;lchild;</span><br><span class="line">    node-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild-&gt;father = node;</span><br><span class="line">    temp-&gt;rchild = node;</span><br><span class="line">    temp-&gt;father = node-&gt;father;</span><br><span class="line">    node-&gt;father = temp;</span><br><span class="line">    temp-&gt;size = node-&gt;size;</span><br><span class="line">    node-&gt;size = node-&gt;lchild-&gt;size + node-&gt;rchild-&gt;size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">SBTNode&lt;Type&gt;* <span class="title">maintain</span><span class="params">(SBTNode&lt;Type&gt;* node, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">SBTNode&lt;Type&gt;* <span class="title">insert</span><span class="params">(SBTNode&lt;Type&gt;* node, Type value)</span> </span>&#123;</span><br><span class="line">    node-&gt;size++;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; node-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;rchild == NIL) &#123;</span><br><span class="line">            node-&gt;rchild = <span class="keyword">new</span> SBTNode&lt;Type&gt;(value, <span class="number">1</span>, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;rchild = insert(node-&gt;rchild, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;lchild == NIL) &#123;</span><br><span class="line">            node-&gt;lchild = <span class="keyword">new</span> SBTNode&lt;Type&gt;(value, <span class="number">1</span>, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;lchild = insert(node-&gt;lchild, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maintain(node, value &gt; node-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">SBTNode&lt;Type&gt;* SBTNode&lt;Type&gt;::search(Type value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rchild == NIL) &#123;</span><br><span class="line">            <span class="keyword">return</span> NIL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rchild-&gt;search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lchild == NIL) &#123;</span><br><span class="line">            <span class="keyword">return</span> NIL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lchild-&gt;search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">SBTNode&lt;Type&gt;* SBTNode&lt;Type&gt;::predecessor() &#123;</span><br><span class="line">    SBTNode&lt;Type&gt;* temp = lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp != NIL &amp;&amp; temp-&gt;rchild != NIL) &#123;</span><br><span class="line">        temp = temp-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">SBTNode&lt;Type&gt;* SBTNode&lt;Type&gt;::successor() &#123;</span><br><span class="line">    SBTNode&lt;Type&gt;* temp = rchild;</span><br><span class="line">    <span class="keyword">while</span> (temp != NIL &amp;&amp; temp-&gt;lchild != NIL) &#123;</span><br><span class="line">        temp = temp-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">void</span> SBTNode&lt;Type&gt;::remove_node(SBTNode&lt;Type&gt;* delete_node) &#123;</span><br><span class="line">    SBTNode&lt;Type&gt;* temp = NIL;</span><br><span class="line">    <span class="keyword">if</span> (delete_node-&gt;lchild != NIL) &#123;</span><br><span class="line">        temp = delete_node-&gt;lchild;</span><br><span class="line">        temp-&gt;father = delete_node-&gt;father;</span><br><span class="line">        delete_node-&gt;lchild = NIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delete_node-&gt;rchild != NIL) &#123;</span><br><span class="line">        temp = delete_node-&gt;rchild;</span><br><span class="line">        temp-&gt;father = delete_node-&gt;father;</span><br><span class="line">        delete_node-&gt;rchild = NIL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (delete_node-&gt;father-&gt;lchild == delete_node) &#123;</span><br><span class="line">        delete_node-&gt;father-&gt;lchild = temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delete_node-&gt;father-&gt;rchild = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = delete_node;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp-&gt;size--;</span><br><span class="line">        temp = temp-&gt;father;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> delete_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">bool</span> SBTNode&lt;Type&gt;::remove(Type value) &#123;</span><br><span class="line">    SBTNode&lt;Type&gt; *delete_node, *current_node;</span><br><span class="line">    current_node = search(value);</span><br><span class="line">    <span class="keyword">if</span> (current_node == NIL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current_node-&gt;lchild != NIL) &#123;</span><br><span class="line">        delete_node = current_node-&gt;predecessor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_node-&gt;rchild != NIL) &#123;</span><br><span class="line">        delete_node = current_node-&gt;successor();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delete_node = current_node;</span><br><span class="line">    &#125;</span><br><span class="line">    current_node-&gt;data = delete_node-&gt;data;</span><br><span class="line">    remove_node(delete_node);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">BinaryTree&lt;Type&gt;::BinaryTree() &#123;</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">BinaryTree&lt;Type&gt;::~BinaryTree() &#123;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;Type&gt;::insert(Type value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> SBTNode&lt;Type&gt;(value, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;search(value) == NIL) &#123;</span><br><span class="line">        root = ::insert(root, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">bool</span> BinaryTree&lt;Type&gt;::find(Type value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;search(value) == NIL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">bool</span> BinaryTree&lt;Type&gt;::remove(Type value) &#123;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;remove(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












<h1 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4.红黑树"></a>4.红黑树</h1><h2 id="1-平衡条件"><a href="#1-平衡条件" class="headerlink" title="1.平衡条件"></a>1.平衡条件</h2><ol>
<li>节点非黑既红</li>
<li>根节点是黑色</li>
<li>叶子（NIL）结点是黑色</li>
<li>如果一个节点是红色，则它的两个子节点都是黑色</li>
<li>从根节点到叶子结点路径上，黑色节点数量相同</li>
</ol>
<p>==&gt;最长边和最短边之间的关系：最长边是最短边的二倍</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%889.44.56.png" alt="截屏2020-12-23 下午9.44.56" style="zoom: 33%;" />





<blockquote>
<p>第4条和第5条条件，注定了，红黑树中最长路径是最短路径的长度的 2 倍。</p>
<p>本质上，红黑树也是通过树高来控制平衡的。</p>
<p>红黑树比 AVL 树树高控制条件要更松散，红黑树在发生节点插入和删除以后，发生调整的概率，比 AVL 树要更小。</p>
</blockquote>
<h2 id="2-平衡调整策略"><a href="#2-平衡调整策略" class="headerlink" title="2.平衡调整策略"></a>2.平衡调整策略</h2><p>1.插入调整站在祖父节点看</p>
<p>2.删除调整站在父亲节点看</p>
<p>3.插入和删除的情况处理，一共五种</p>
<blockquote>
<p>理解</p>
<ol>
<li>理解红黑树的插入调整，要站在==祖父节点==向下进行调整</li>
<li>理解红黑树的删除调整，要站在==父节点==向下进行调整</li>
<li>插入调整，主要就是为了解决双红情况</li>
<li>新插入的节点一定是红色，插入黑色节点一定会产生冲突，违反条件5，插入红色节点，不一定产生冲突</li>
<li>把每一种情况，想象成一棵大的红黑树中的局部子树</li>
<li>局部调整的时候，为了不影响全局，调整前后的路径上黑色节点数量相同</li>
</ol>
</blockquote>
<h2 id="3-插入方法"><a href="#3-插入方法" class="headerlink" title="3.插入方法"></a>3.插入方法</h2><p>​                                                                                                                             </p>
<p>1.叔叔节点为红色的时候，修改三元组小帽子，改成红黑黑(4种情况)</p>
<p>x有4个位置，4种情况，但是处理方法一样</p>
<p>根节点必定为黑色，否则插入前已经冲突</p>
<p>eg:1,20修改成黑色，15修改成红色(红色上顶)</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8A%E5%8D%8811.16.48.png" alt="截屏2020-12-24 上午11.16.48"></p>
<p>2.叔叔节点为黑色的时候，有四种情况LL,LR，RL,RR</p>
<p>参考 AVL 树的失衡情况，分成 $LL,LR,RL,RR$, 先参考 AVL 树的旋转调整策略，然后再修改三元组的颜色，有两种调整策略：红色上浮，红色下沉。</p>
<p>eg:LL型进行大右旋，<strong>20</strong>调整成红色，<strong>15</strong>调整成⿊色，即可搞定问题(红色上浮)，</p>
<p>或者调整10为黑色，红色上浮</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8A%E5%8D%8811.17.02.png" alt="截屏2020-12-24 上午11.17.02" style="zoom: 70%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8A%E5%8D%8811.29.58.png" alt="截屏2020-12-24 上午11.29.58" style="zoom:67%;" />

<p>3.两大类情况，包含 8 种小情况</p>
<h2 id="4-插入代码演示"><a href="#4-插入代码演示" class="headerlink" title="4.插入代码演示"></a>4.插入代码演示</h2><ol>
<li>插入调整，发正在递归的回溯阶段</li>
<li>插入调整代码中，使用 goto 语句，8行代码，变成了4行</li>
<li>处理根节点一定是黑色，通过代码封装，$insert-&gt;__insert$</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> color;<span class="comment">//0 red, 1 black 2double black</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL-&gt;data = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;color = <span class="number">1</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;</span><br><span class="line">    Node *root = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    root-&gt;data = _data;</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;</span><br><span class="line">    root-&gt;lchild = root-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">has_red_child</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//判断根节点是否有红色的子孩子</span></span><br><span class="line">    <span class="keyword">return</span> root-&gt;lchild-&gt;color == <span class="number">0</span> || root-&gt;rchild-&gt;color == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!has_red_child(root)) <span class="keyword">return</span> root;<span class="comment">//没有红色的孩子，不需要调整</span></span><br><span class="line">    <span class="comment">//没有判断是否发生双红冲突</span></span><br><span class="line">    <span class="comment">//不冲突的话，更改颜色不影响结果，如果发生冲突，更改颜色，解决冲突，root必定为黑色，因为孩子为红色</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; root-&gt;rchild-&gt;color == <span class="number">0</span>) <span class="keyword">goto</span> insert_end;</span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">       <span class="comment">// root-&gt;color = 0;</span></span><br><span class="line">       <span class="comment">// root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = 1;</span></span><br><span class="line">        <span class="comment">//return root;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;lchild)) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;rchild)) flag = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;rchild-&gt;color == <span class="number">0</span>)<span class="comment">//LR,需要小左旋，大右旋</span></span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">        <span class="comment">//root-&gt;color = 0;//红色上浮，红色下沉也可</span></span><br><span class="line">       <span class="comment">// root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = 1;</span></span><br><span class="line">       <span class="comment">// return root;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);</span><br><span class="line">        <span class="comment">//root-&gt;color = 0;</span></span><br><span class="line">       <span class="comment">// root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">insert_end:</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;<span class="comment">//红色上浮，红色下沉也可</span></span><br><span class="line">    root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *__insert(Node *root, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(value);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) root-&gt;lchild = __insert(root-&gt;lchild, value);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = __insert(root-&gt;rchild, value);</span><br><span class="line">    <span class="keyword">return</span> insert_maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    root = __insert(root, data);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d| %d, %d, %d)\n&quot;</span>,</span><br><span class="line">        root-&gt;color, root-&gt;data,</span><br><span class="line">        root-&gt;lchild-&gt;data,</span><br><span class="line">        root-&gt;rchild-&gt;data</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">0</span>| <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">1</span>| <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">1</span>| <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">0</span>| <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 -60</span><br><span class="line">2 -95</span><br><span class="line">1 47</span><br><span class="line">1 -65</span><br><span class="line">1 18</span><br><span class="line">3 -53</span><br></pre></td></tr></table></figure>




<h2 id="5-删除调整的触发"><a href="#5-删除调整的触发" class="headerlink" title="5.删除调整的触发"></a>5.删除调整的触发</h2><ol>
<li>删除红色节点，不会对红黑树的平衡产生影响</li>
<li>度为1的黑色节点，唯一子孩子一定是红色，因为到叶子结点的黑色节点相同，如果为黑色则会违背平衡条件</li>
<li>所以删除度为1的黑色节点，不会产生删除调整，</li>
<li>删除度为0的黑色节点，会产生一个双重黑的 NIL 节点(color=2)</li>
<li>所以删除调整的关键，就是为了干掉双重黑</li>
</ol>
<p>==&gt;双重黑结点触发删除调整</p>
<h2 id="7-删除调整分类"><a href="#7-删除调整分类" class="headerlink" title="7.删除调整分类"></a>7.删除调整分类</h2><blockquote>
<p>1.双重黑节点的兄弟节点是黑色，兄弟节点下面的两个子节点也是黑色，</p>
</blockquote>
<p>调整方法:父节点增加一重黑色，双重黑与兄弟节点，分别减少一重黑色。</p>
<p>情况一</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%884.25.58.png" alt="图一" style="zoom: 85%;" />

<blockquote>
<p>2.双黑结点的兄弟节点是黑色，并且，兄弟节点中有==红色子节点==,有四种情况</p>
</blockquote>
<p> 1).R（兄弟）==R==（右子节点），==左==旋，新根结点改成原根结点的颜色，将新根的两个子节点，改成黑色,双重黑改成一重黑</p>
<p>情况三（双黑左旋之后被干掉）兄弟的右子树结点为红色，左子树结点不一定</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%884.29.06.png" alt="截屏2020-12-24 下午4.29.06" style="zoom:90%;" />

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%885.04.12.png" alt="截屏2020-12-24 下午5.04.12" style="zoom:50%;" />





<p>2).R（兄弟）==L==（左子节点）(红色)，先小==右==旋，对调新根与原根的颜色，转成上一种情况(RL→RR)</p>
<p>(情况二)RL，兄弟右子树一定为黑色，左子树为红色</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8811.02.27.png" alt="截屏2020-12-24 下午11.02.27" style="zoom:80%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8810.06.55.png" alt="截屏2020-12-24 下午10.06.55" style="zoom:50%;" />

<p>3).LL 同理 RR</p>
<p>4).LR 同理 RL</p>
<blockquote>
<p>4.兄弟节点是红色，通过旋转，转变成兄弟节点是黑色的情况</p>
</blockquote>
<p>  左旋，原根节点改红，新根节点改黑，双黑-1</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8810.22.04.png" alt="截屏2020-12-24 下午10.22.04" style="zoom:50%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8810.25.28.png" alt="截屏2020-12-24 下午10.25.28" style="zoom:50%;" />







<h2 id="6-删除代码实现"><a href="#6-删除代码实现" class="headerlink" title="6.删除代码实现"></a>6.删除代码实现</h2><p>进行 LR/RL 类型判断的时候，不能判断 LL 子树是否为黑色，LL 子树有可能是 NIL 节点，在某些特殊情况下，读到的颜色可能是双重黑，取而代之的判断方法就是【LL 子树不是红色】。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> color;<span class="comment">//0 red, 1 black 2double black</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL-&gt;data = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;color = <span class="number">1</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;</span><br><span class="line">    Node *root = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    root-&gt;data = _data;</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;</span><br><span class="line">    root-&gt;lchild = root-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">has_red_child</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//判断根节点是否有红色的孩子结点</span></span><br><span class="line">    <span class="keyword">return</span> root-&gt;lchild-&gt;color == <span class="number">0</span> || root-&gt;rchild-&gt;color == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!has_red_child(root)) <span class="keyword">return</span> root;<span class="comment">//没有红色的孩子，不需要调整</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; root-&gt;rchild-&gt;color == <span class="number">0</span>) <span class="keyword">goto</span> insert_end;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;lchild)) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;rchild)) flag = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;rchild-&gt;color == <span class="number">0</span>)<span class="comment">//LR,需要小左旋，大右旋</span></span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">insert_end:</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;<span class="comment">//红色上浮，红色下沉也可，这里选择红色上浮</span></span><br><span class="line">    root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *__insert(Node *root, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(value);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) root-&gt;lchild = __insert(root-&gt;lchild, value);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = __insert(root-&gt;rchild, value);</span><br><span class="line">    <span class="keyword">return</span> insert_maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    root = __insert(root, data);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild != NIL) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color != <span class="number">2</span> &amp;&amp; root-&gt;rchild-&gt;color != <span class="number">2</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (has_red_child(root)) &#123;<span class="comment">//兄弟节点是红色，通过旋转，转变成兄弟节点是黑色的情况</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//1：右旋，2：左旋</span></span><br><span class="line">        root-&gt;color = <span class="number">0</span>;<span class="comment">//原根节点改红</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;<span class="comment">//左孩子为红色，右孩子为双黑结点，减掉一重黑色，右旋</span></span><br><span class="line">            root-&gt;rchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">            root = right_rotate(root);</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//右孩子为红色,左孩子为双黑结点，双黑结点减掉一重黑色，左旋</span></span><br><span class="line">            root-&gt;lchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">            root = left_rotate(root);</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;color = <span class="number">1</span>;<span class="comment">//新根节点改黑</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) root-&gt;rchild = erase_maintain(root-&gt;rchild);<span class="comment">//若发生右旋，已经转变成兄弟结点为黑色的情况，递归检查右边是否平衡,</span></span><br><span class="line">        <span class="keyword">else</span> root-&gt;lchild = erase_maintain(root-&gt;lchild);<span class="comment">//检查左边是否平衡</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((root-&gt;lchild-&gt;color == <span class="number">2</span> &amp;&amp; !has_red_child(root-&gt;rchild)) ||</span><br><span class="line">        (root-&gt;rchild-&gt;color == <span class="number">2</span> &amp;&amp; !has_red_child(root-&gt;lchild)) ) &#123;</span><br><span class="line">        <span class="comment">//双重黑节点的兄弟节点是黑色，兄弟节点下面的两个子节点也是黑色(即无红色)</span></span><br><span class="line">            root-&gt;lchild-&gt;color -= <span class="number">1</span>;<span class="comment">//父节点增加一重黑色，双重黑与兄弟节点，分别减少一重黑色</span></span><br><span class="line">            root-&gt;rchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">            root-&gt;color += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双黑结点的兄弟节点是黑色，并且，兄弟节点中有红色子节点</span></span><br><span class="line">    <span class="comment">//R（兄弟）R（右子节点），左旋，新根结点改成原根结点的颜色，将新根的两个子节点，改成黑色，双重黑减1</span></span><br><span class="line">    <span class="comment">//R（兄弟）L（左子节点）(红色)，先小右旋，对调新根与原根的颜色，转成RR(RL→RR)</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">2</span>) &#123;<span class="comment">//左兄弟为双黑结点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;rchild-&gt;color != <span class="number">0</span>) &#123;<span class="comment">//---- != root-&gt;rchild-&gt;rchild-&gt;color == 1(NIL)</span></span><br><span class="line">            <span class="comment">//------------不是红色</span></span><br><span class="line">            root-&gt;rchild-&gt;color = <span class="number">0</span>;</span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">            root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);<span class="comment">//大左旋</span></span><br><span class="line">        root-&gt;color = root-&gt;lchild-&gt;color;<span class="comment">//新根结点改成原根结点的颜色</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//右兄弟结点为双黑结点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;lchild-&gt;color != <span class="number">0</span>) &#123;</span><br><span class="line">            root-&gt;lchild-&gt;color = <span class="number">0</span>;</span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">            root-&gt;lchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">            root-&gt;lchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        root = right_rotate(root);<span class="comment">//大右旋</span></span><br><span class="line">        root-&gt;color = root-&gt;rchild-&gt;color;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *__erase(Node *root, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> NIL;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) root-&gt;lchild = __erase(root-&gt;lchild, value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) root-&gt;rchild = __erase(root-&gt;rchild, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild != NIL ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            temp-&gt;color += root-&gt;color;</span><br><span class="line">            <span class="comment">//若根节点为红色，值不变，若为黑色，子孩子一定为红色，</span></span><br><span class="line">            <span class="comment">//temp == NIL，root度为0，则，color=2,产生双黑结点</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = __erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> erase_maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    root = __erase(root, value);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d| %d, %d, %d)\n&quot;</span>,</span><br><span class="line">        root-&gt;color, root-&gt;data,</span><br><span class="line">        root-&gt;lchild-&gt;data,</span><br><span class="line">        root-&gt;rchild-&gt;data</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: output(root);</span><br><span class="line">        &#125;</span><br><span class="line">        output(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">0</span>| <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">1</span>| <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">0</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">(1| 1, 0, 0)</span><br><span class="line">------------</span><br><span class="line">1 2</span><br><span class="line">(1| 1, 0, 2)</span><br><span class="line">(0| 2, 0, 0)</span><br><span class="line">------------</span><br><span class="line">1 3</span><br><span class="line">(1| 2, 1, 3)</span><br><span class="line">(1| 1, 0, 0)</span><br><span class="line">(1| 3, 0, 0)</span><br><span class="line">------------</span><br><span class="line">1 -5</span><br><span class="line">(1| 2, 1, 3)</span><br><span class="line">(1| 1, -5, 0)</span><br><span class="line">(0| -5, 0, 0)</span><br><span class="line">(1| 3, 0, 0)</span><br><span class="line">------------</span><br><span class="line">2 3</span><br><span class="line">(1| 1, -5, 2)</span><br><span class="line">(1| -5, 0, 0)</span><br><span class="line">(1| 2, 0, 0)</span><br><span class="line">------------</span><br></pre></td></tr></table></figure>


<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-25%20%E4%B8%8A%E5%8D%881.47.12.png" alt="截屏2020-12-25 上午1.47.12" style="zoom:50%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-25%20%E4%B8%8A%E5%8D%881.49.37.png" alt="截屏2020-12-25 上午1.49.37" style="zoom:50%;" />





<h2 id="7-红黑树代码实现"><a href="#7-红黑树代码实现" class="headerlink" title="7.红黑树代码实现"></a>7.红黑树代码实现</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%884.53.06.png" alt="截屏2021-01-05 下午4.53.06"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> color;<span class="comment">//0 red, 1 black 2double black</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;<span class="comment">//空节点</span></span><br><span class="line">    NIL-&gt;data = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;color = <span class="number">1</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;<span class="comment">//初始化一个新节点</span></span><br><span class="line">    Node *root = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    root-&gt;data = data;</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;</span><br><span class="line">    root-&gt;lchild = root-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">has_red_child</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//判断根节点的孩子结点是否有红色</span></span><br><span class="line">    <span class="keyword">return</span> root-&gt;lchild-&gt;color == <span class="number">0</span> || root-&gt;rchild-&gt;color == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左旋，旧根节点的右孩子变成根节点，旧根节点的右孩子变成新根节点的左孩子，新根节点左孩子变成旧根节点</span></span><br><span class="line">    Node *temp = root-&gt;rchild;<span class="comment">//新根节点</span></span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;<span class="comment">//旧根节点的右孩子变成新根节点的左孩子</span></span><br><span class="line">    temp-&gt;lchild = root;<span class="comment">//新根节点左孩子是旧根节点</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//右旋，旧根节点左孩子变成新根节点，旧根节点的左孩子变成新根节点的右孩子，新根节点的右孩子变成旧根节点</span></span><br><span class="line">    Node *temp = root-&gt;lchild;<span class="comment">//新根节点为旧根节点的左孩子</span></span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;<span class="comment">//旧根节点的左孩子变成新根节点的右孩子</span></span><br><span class="line">    temp-&gt;rchild = root;<span class="comment">//新根节点的右孩子变成旧根节点</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert_maintain</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> (!has_red_child(root)) <span class="keyword">return</span> root;<span class="comment">//没有红色的孩子，不需要调整</span></span><br><span class="line">    <span class="comment">//没有判断是否发生双红冲突</span></span><br><span class="line">    <span class="comment">//不冲突的话，更改颜色不影响结果，如果发生冲突，更改颜色，解决冲突，root必定为黑色，因为孩子为红色</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//分为两种情况 1.根节点的孩子中都是红色结点，2.根节点的孩子中有一个是红色</span></span><br><span class="line">    <span class="comment">// 1.根节点的孩子中都是红色结点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; root-&gt;rchild-&gt;color == <span class="number">0</span> &amp;&amp; </span><br><span class="line">    (has_red_child(root-&gt;lchild) || has_red_child(root-&gt;rchild))) <span class="keyword">goto</span> insert_end;</span><br><span class="line">    <span class="comment">// 2.根节点的孩子中有一个是红色,使用flag标记两种情况</span></span><br><span class="line">    <span class="comment">// 2.1 根节点的左孩子是红色，且左孩子的子树中有红色结点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;lchild)) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 2.2 根结点的右孩子是红色，且右孩子的子树中有红色结点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;rchild)) flag = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="comment">// 2.1 根节点的左孩子是红色，且左孩子的子树中有红色结点</span></span><br><span class="line">        <span class="comment">// 2.1.1 根节点的左孩子的右孩子为红色，为LR型，需要小左旋大右旋，</span></span><br><span class="line">        <span class="comment">// 2.1.2 根节点的左孩子的左孩子为红色，为LL型，需要大右旋，</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;rchild-&gt;color == <span class="number">0</span>)<span class="comment">//LR,需要小左旋，大右旋</span></span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.2 根结点的右孩子是红色，且右孩子的子树中有红色结点</span></span><br><span class="line">        <span class="comment">// 2.2.1 根节点的右孩子的左孩子为红色，为RL型，需要小右旋大左旋，</span></span><br><span class="line">        <span class="comment">// 2.2.2 根节点的左孩子的左孩子为红色，为RR型，需要大右旋，</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;<span class="comment">//RL,需要小右旋，大左旋</span></span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">insert_end:</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;<span class="comment">//这里选择红色上浮，其实红色上浮，红色下沉均可，</span></span><br><span class="line">    root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node *__insert(Node *root, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(value);<span class="comment">//根节点为空或者找到插入位置，插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> root;<span class="comment">//新插入的结点已经存在，不需要操作</span></span><br><span class="line">    <span class="comment">//在左子树中插入</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) root-&gt;lchild = __insert(root-&gt;lchild, value);</span><br><span class="line">    <span class="comment">//在右子树中插入</span></span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = __insert(root-&gt;rchild, value);</span><br><span class="line">    <span class="comment">//插入完之后进行平衡调整，然后 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> insert_maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//插入</span></span><br><span class="line">    root = __insert(root, value);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild != NIL) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root-&gt;rchild-&gt;color != <span class="number">2</span> &amp;&amp; root-&gt;lchild-&gt;color !=  <span class="number">2</span>) <span class="keyword">return</span> root;</span><br><span class="line">     <span class="keyword">if</span> (!has_red_child(root)) &#123;<span class="comment">//1.双黑兄弟无红色</span></span><br><span class="line">         <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">2</span>) &#123;<span class="comment">//1.2左双黑结点</span></span><br><span class="line">             <span class="keyword">if</span> (!has_red_child(root-&gt;rchild)) &#123;<span class="comment">//1.2.1双黑结点在左，且右兄弟子结点无红色</span></span><br><span class="line">                 <span class="comment">//父结点增加1重黑，双重黑结点与兄弟结点减少1重黑</span></span><br><span class="line">                 root-&gt;color += <span class="number">1</span>;</span><br><span class="line">                 root-&gt;lchild-&gt;color -=<span class="number">1</span>;</span><br><span class="line">                 root-&gt;rchild-&gt;color -=<span class="number">1</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;<span class="comment">//1.2.2双黑结点在左，且右兄弟有红色子结点，分为RL,RR</span></span><br><span class="line">                 root-&gt;lchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">if</span> (root-&gt;rchild-&gt;rchild-&gt;color != <span class="number">0</span>) &#123;<span class="comment">// 1.2.2.3右兄弟结点，其右孩子不为红色,左孩子为红色，RL</span></span><br><span class="line">                     <span class="comment">//小右旋，原兄弟结点改成红色，新兄弟结点改成黑色，转变成RR型</span></span><br><span class="line">                     <span class="comment">//root-&gt;rchild-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color;//=1改黑**</span></span><br><span class="line">                     root-&gt;rchild-&gt;color = <span class="number">0</span>;<span class="comment">//改红</span></span><br><span class="line">                     root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">                     root-&gt;rchild-&gt;color = <span class="number">1</span>;<span class="comment">//改黑**</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//大左旋，新根结点等于原根结点 [双黑结点的父结点] 的颜色，两个新的子结点改为黑色，双黑结点减少1重黑</span></span><br><span class="line">                 root-&gt;rchild-&gt;color = root-&gt;color;</span><br><span class="line">                 root = left_rotate(root);</span><br><span class="line">                 root-&gt;rchild-&gt;color = root-&gt;lchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;rchild-&gt;color == <span class="number">2</span>)&#123;<span class="comment">//1.3右双黑结点</span></span><br><span class="line">             <span class="keyword">if</span> (!has_red_child(root-&gt;lchild)) &#123;<span class="comment">//1.3.1双黑结点在右，且左兄弟子结点无红色,</span></span><br><span class="line">                 <span class="comment">//父结点增加1重黑，双重黑结点与兄弟结点减少1重黑</span></span><br><span class="line">                 root-&gt;color += <span class="number">1</span>;</span><br><span class="line">                 root-&gt;lchild-&gt;color -=<span class="number">1</span>;</span><br><span class="line">                 root-&gt;rchild-&gt;color -=<span class="number">1</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;<span class="comment">//1.3.2双黑结点在右，且左兄弟有红色子结点，分为LR,LL</span></span><br><span class="line">                 root-&gt;rchild-&gt;color = <span class="number">1</span>;<span class="comment">//双重黑减一重黑</span></span><br><span class="line">                 <span class="keyword">if</span> (root-&gt;lchild-&gt;lchild-&gt;color != <span class="number">0</span>) &#123;<span class="comment">// 1.3.2.3左兄弟结点，其右孩子不为红色,即左孩子为红色,LL</span></span><br><span class="line">                     <span class="comment">//小左旋，原兄弟结点改成红色，新兄弟结点改成黑色，转变成LL型</span></span><br><span class="line">                     <span class="comment">//root-&gt;lchild-&gt;rchild-&gt;color = root-&gt;lchild-&gt;color;//=1</span></span><br><span class="line">                     root-&gt;lchild-&gt;color = <span class="number">0</span>;<span class="comment">//改红</span></span><br><span class="line">                     root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">                     root-&gt;lchild-&gt;color = <span class="number">1</span>;<span class="comment">//改黑</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//大右旋，新根结点等于原根结点 [双黑结点的父结点] 的颜色，两个新的子结点改为黑色，双黑结点减少1重黑</span></span><br><span class="line">                 root-&gt;lchild-&gt;color = root-&gt;color;</span><br><span class="line">                 root = right_rotate(root);</span><br><span class="line">                 root-&gt;rchild-&gt;color = root-&gt;lchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//2.双黑兄弟结点有红色,抓着双黑结点的父结点，向双黑结点旋转，原根结点改为红色，新根结点改为黑色</span></span><br><span class="line">         <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;<span class="comment">//2.2右双黑,左为红,向右旋转,原根结点改为红色，新根结点改为黑色</span></span><br><span class="line">            <span class="comment">//root-&gt;lchild-&gt;color = root-&gt;color;</span></span><br><span class="line">            root-&gt;color = <span class="number">0</span>;</span><br><span class="line">            root = right_rotate(root);</span><br><span class="line">            root-&gt;color = <span class="number">1</span>;</span><br><span class="line">            root-&gt;rchild = erase_maintain(root-&gt;rchild);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;<span class="comment">//2.3左双黑,右为红,向左旋转,原根结点改为红色，新根结点改为黑色</span></span><br><span class="line">            <span class="comment">//root-&gt;rchild-&gt;color = root-&gt;color;</span></span><br><span class="line">            root-&gt;color = <span class="number">0</span>;</span><br><span class="line">            root = left_rotate(root);</span><br><span class="line">            root-&gt;color = <span class="number">1</span>;</span><br><span class="line">            root-&gt;lchild = erase_maintain(root-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *__erase(Node *root, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="comment">//删除有两种情况，删除度为2，和删除度为0和1</span></span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> NIL;<span class="comment">//没有要删除的值</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) root-&gt;lchild = __erase(root-&gt;lchild, value);<span class="comment">// 要删除的值在左子树中</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) root-&gt;rchild = __erase(root-&gt;rchild, value);<span class="comment">// 要删除的值在右子树中</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 找到要删除的值，有4种情况</span></span><br><span class="line">        <span class="comment">// 1.要删除的结点的孩子结点有空节点，即删除度为1或者度为0的结点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild != NIL ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            temp-&gt;color += root-&gt;color;</span><br><span class="line">            <span class="comment">// 1.1删除度为1的结点，分两种情况</span></span><br><span class="line">            <span class="comment">// 1.1.1若删除的根节点为红色，不会对红黑树的平衡产生影响，</span></span><br><span class="line">            <span class="comment">// 1.1.2若删除的根节点为黑色，他的子孩子一定为红色，如果为黑色，树不会平衡；删除根节点为黑色，temp-&gt;color = 2;产生双重黑结点</span></span><br><span class="line">            <span class="comment">// 1.2删除度为0的结点，分两种情况</span></span><br><span class="line">            <span class="comment">// 1.2.1删除度为0的红色结点，不会产生影响</span></span><br><span class="line">            <span class="comment">// 1.2.2删除度为0的黑色结点，temp = NIL,color=2,产生双黑结点</span></span><br><span class="line">            <span class="built_in">free</span>(root);<span class="comment">//释放要删除的结点</span></span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        <span class="comment">// 2.删除度为2的结点，转换成度为1或0的结点，转换的方法是和他的前驱结点交换 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = __erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root = erase_maintain(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//删除结点</span></span><br><span class="line">    root = __erase(root, value);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;<span class="comment">//根节点为黑色</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,</span><br><span class="line">        root-&gt;data, </span><br><span class="line">        root-&gt;color,</span><br><span class="line">        root-&gt;lchild-&gt;data,</span><br><span class="line">        root-&gt;rchild-&gt;data</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: output(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//output(root);</span></span><br><span class="line">        <span class="comment">//printf(&quot;------------\n&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


















<h1 id="5-哈夫曼树"><a href="#5-哈夫曼树" class="headerlink" title="5.哈夫曼树"></a>5.哈夫曼树</h1><h2 id="1-编码"><a href="#1-编码" class="headerlink" title="1.编码"></a>1.编码</h2><h3 id="什么是编码"><a href="#什么是编码" class="headerlink" title="什么是编码"></a>什么是编码</h3><p>‘a’ = 97 = $(0110\ 0001)_2$</p>
<p>‘0’ = 48 = $(0011\ 0000)_2$</p>
<p>注意：任何信息，在计算机中，都是二进制存储的</p>
<p>信息：”aa00” = $01100001、01100001、00110000、00110000$</p>
<p>一台计算机   传输到  另外一台计算机，传输 32 个比特位</p>
<p>假设：计算机的网络是 32bit/s。所以用时：1 s</p>
<p>特定场静：只有 a,b,0,1 四种字符需要传输</p>
<p>海贼班编码：a:00, b: 01, 0: 10, 1: 11</p>
<p>“aa00” = 00001010</p>
<p>在带宽不变的情况下，当前只需要传输 0.25s</p>
<h3 id="定长与变长编码"><a href="#定长与变长编码" class="headerlink" title="定长与变长编码"></a>定长与变长编码</h3><ol start="2">
<li>Ascii编码和特定场景下的编码，都属于定长编码</li>
<li>对于每一个字符，编码长度相同，这就是定长编码</li>
<li>UTF-8编码是变长编码，UTF-16是定长编码</li>
<li>对于每一个字符，编码长度不同，这就是变长编码</li>
<li>将定长编码，看成是变长编码的特例</li>
<li>变长编码，一定不差于定长编码</li>
</ol>
<h3 id="变长编码应用场景"><a href="#变长编码应用场景" class="headerlink" title="变长编码应用场景"></a>变长编码应用场景</h3><p>特定场静：</p>
<ol>
<li>只有四种字符 : ab01</li>
<li>a: 0.8, b: 0.05, 0: 0.1, 1: 0.05</li>
</ol>
<p>平均编码长度：</p>
<p>$l_i$：第 i 种字符，编码长度</p>
<p>$p_i$：第 i 种字符，出现概率</p>
<p>$avg(l) = \sum{l_i}\times{p_i}$</p>
<p>假设，平均编码长度：1.16，估算传输100个字符，需要传输116个比特位</p>
<p>海贼班编码的平均编码长度：$avg(l) = 2\times\sum{p_i}=2$</p>
<p>平均编码长度就是编码的定长</p>
<p>新·海贼班编码：</p>
<p>a: 1</p>
<p>b: 01</p>
<p>0: 000</p>
<p>1: 001</p>
<p>平均编码长度：$1<em>0.8+2</em>0.05+3<em>0.1+3</em>0.05=1.35$</p>
<p>100个字符，传输135个比特位</p>
<p>==&gt;将定长编码看成变长编码的特例，变长编码不差于定长编码</p>
<h2 id="2-哈夫曼编码"><a href="#2-哈夫曼编码" class="headerlink" title="2.哈夫曼编码"></a>2.哈夫曼编码</h2><ol>
<li>首先，统计得到每一种字符的概率</li>
<li>将 n 个字符，建立成一棵哈弗曼树</li>
<li>每一个字符，都落在叶子结点上</li>
<li>按照左0，右1的形式，将编码读取出来</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8A%E5%8D%8810.14.23.png" alt="截屏2020-12-29 上午10.14.23"></p>
<p>得到新编码：</p>
<p>a: 0 | b: 110 | 0: 10 | 1: 111</p>
<p>平均编码长度：$1<em>0.8+3</em>0.05+2<em>0.1+3</em>0.05=1.3$</p>
<p>结论：哈弗曼编码，是最优的变长编码</p>
<h2 id="4-公式证明"><a href="#4-公式证明" class="headerlink" title="4.公式证明"></a>4.公式证明</h2><ol>
<li>首先表示平均编码长度，求解公式最优解</li>
<li>最终，和熵与交叉熵之间的关系</li>
</ol>
<p> 证明$\sum{l_i}\times{p_i}$最小，令$l = -l’$，即证明$-\sum{l_i}\times{p_i}$最小</p>
<p>约束$\sum{l_i}\times{p_i} &lt;=  1$</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%8812.28.35.png" alt="截屏2020-12-29 下午12.28.35" style="zoom: 33%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%8812.45.54.png" alt="截屏2020-12-29 下午12.45.54" style="zoom: 33%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%881.02.11.png" alt="截屏2020-12-29 下午1.02.11" style="zoom:33%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-30%20%E4%B8%8A%E5%8D%889.35.56.png" alt="截屏2020-12-30 上午9.35.56" style="zoom:33%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-30%20%E4%B8%8A%E5%8D%889.51.45.png" alt="截屏2020-12-30 上午9.51.45" style="zoom:33%;" />





<h2 id="5-代码演示"><a href="#5-代码演示" class="headerlink" title="5.代码演示"></a>5.代码演示</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123; \</span></span><br><span class="line">    __typeof(a) __c = a; \</span><br><span class="line">    a = b, b = __c; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> p;<span class="comment">//概率值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">char</span> _ch, <span class="keyword">double</span> _per)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;ch = _ch;</span><br><span class="line">    p-&gt;p = _per;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">CombinNode</span><span class="params">(Node *a, Node *b)</span> </span>&#123;<span class="comment">//合并成新结点</span></span><br><span class="line">    Node *p = getNewNode(<span class="number">0</span>, a-&gt;p + b-&gt;p);</span><br><span class="line">    p-&gt;lchild = a;</span><br><span class="line">    p-&gt;rchild = b;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pick_min</span><span class="params">(Node **arr, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//找到概率最小的结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[n]-&gt;p &gt; arr[j]-&gt;p) &#123;</span><br><span class="line">            swap(arr[n], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getHaffmanTree</span><span class="params">(Node **arr, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//生成n个结点的哈夫曼树，n个结点循环n-1次形成树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pick_min(arr, n - i);<span class="comment">//最小的放在最后面，次之放倒数第二</span></span><br><span class="line">        pick_min(arr, n - i - <span class="number">1</span>);</span><br><span class="line">        arr[n - i - <span class="number">1</span>] = CombinNode(arr[n - i], arr[n - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __output_encode(Node *root, <span class="keyword">char</span> *str, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    str[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) &#123;<span class="comment">//根节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %s\n&quot;</span>, root-&gt;ch, str);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    str[k] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    __output_encode(root-&gt;lchild, str, k + <span class="number">1</span>);<span class="comment">//左0右1</span></span><br><span class="line">    str[k] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    __output_encode(root-&gt;rchild, str, k + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_encode</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    __output_encode(root, str, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Node **arr;<span class="comment">//数组</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//要输节点数量</span></span><br><span class="line">    arr = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">double</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%lf&quot;</span>, ch, &amp;p);<span class="comment">//输入节点</span></span><br><span class="line">        arr[i] = getNewNode(ch[<span class="number">0</span>], p);</span><br><span class="line">    &#125;</span><br><span class="line">    Node *root = getHaffmanTree(arr, n);<span class="comment">//获取哈夫曼树</span></span><br><span class="line">    output_encode(root);<span class="comment">//输出哈夫曼树</span></span><br><span class="line">    clear(root);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h1 id="6-单调栈和单调队列"><a href="#6-单调栈和单调队列" class="headerlink" title="6.单调栈和单调队列"></a>6.单调栈和单调队列</h1><h2 id="6-1课前热身"><a href="#6-1课前热身" class="headerlink" title="6.1课前热身"></a>6.1课前热身</h2><h3 id="6-1HZOJ-261-数据结构"><a href="#6-1HZOJ-261-数据结构" class="headerlink" title="6.1HZOJ-261-数据结构"></a>6.1HZOJ-261-数据结构</h3><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8B%E5%8D%889.40.35.png" alt="截屏2021-01-14 下午9.40.35"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8B%E5%8D%889.40.47.png" alt="截屏2021-01-14 下午9.40.47"></p>
<ol>
<li><p>关键就是新造一个数据结构，结构定义 + 结构操作</p>
</li>
<li><p>模拟光标的功能，左移动、右移动、插入、删除，用对顶栈模拟</p>
</li>
<li><p>实现对顶栈，用数组模拟、用链表模拟</p>
</li>
<li><p>题目中的 BUG：Query K 中，K 可能大于当前位置</p>
<hr>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewStruct</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NewStruct() &#123;</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//sum[0] = 0;</span></span><br><span class="line">        ans[<span class="number">0</span>] = INT64_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//插入元素</span></span><br><span class="line">        s1.push(x);<span class="comment">//在s1中插入</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> val = s1.top() + sum[s1.size() - <span class="number">1</span>];</span><br><span class="line">        sum[s1.size()] = val;<span class="comment">//前i项和</span></span><br><span class="line">        ans[s1.size()] = max(ans[s1.size() - <span class="number">1</span>], val);<span class="comment">//前i项和的最大值，在前i项和sum和前i-1项和中的最大值做比较</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.empty()) <span class="keyword">return</span> ;</span><br><span class="line">        s1.pop();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move_left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.empty()) <span class="keyword">return</span> ;</span><br><span class="line">        s2.push(s1.top());</span><br><span class="line">        del();</span><br><span class="line">        <span class="comment">//s1.pop();</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move_right</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.empty()) <span class="keyword">return</span> ;</span><br><span class="line">        insert(s2.top());</span><br><span class="line">        <span class="comment">//s1.push(s2.top());</span></span><br><span class="line">        s2.pop();</span><br><span class="line">        <span class="comment">//sum.pop_back(s2.top());</span></span><br><span class="line">        <span class="comment">//ans.push_back(s1.top() + sum[sum.size() - 1]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans[k];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s1, s2;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum[<span class="number">1005</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">1005</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;<span class="comment">//输入第一行为操作数 𝑁。</span></span><br><span class="line">    <span class="built_in">string</span> op;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    NewStruct s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">switch</span>(op[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="built_in">cin</span> &gt;&gt; val; s.insert(val); <span class="keyword">break</span>;<span class="comment">//在当前位置插入 𝑥 元素；</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: s.del(); <span class="keyword">break</span>;<span class="comment">// 删除当前位置的元素；</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: s.move_left(); <span class="keyword">break</span>;<span class="comment">//将当前位置左移一位，除非它已经是第一个元素；</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: s.move_right(); <span class="keyword">break</span>;<span class="comment">//将当前位置右移一位，除非它已经是最后一个元素</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="built_in">cin</span> &gt;&gt; val; <span class="built_in">cout</span> &lt;&lt; s.query(val) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;<span class="comment">//𝑘  在当前位置之前，找到一个最大的 𝑆𝑖(1≤𝑖≤𝑘,𝑆𝑖=𝑎1+𝑎2+...+𝑎𝑖)</span></span><br><span class="line">        <span class="keyword">default</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-2HZOJ-263-火车进栈"><a href="#6-2HZOJ-263-火车进栈" class="headerlink" title="6.2HZOJ-263-火车进栈"></a>6.2HZOJ-263-火车进栈</h3><hr>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8A%E5%8D%8810.56.08.png" alt="截屏2021-01-15 上午10.55.49"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8A%E5%8D%8810.56.08.png" alt="截屏2021-01-15 上午10.56.08"></p>
<hr>
<ol>
<li><p>当前要进栈的最大数字是 x，序列中当前待出栈的数字是 y</p>
</li>
<li><p>$y &lt;= x$，说明 y 一定是栈顶元素</p>
</li>
<li><p>$y &gt; x$，将 $[x + 1, y]$ 入栈，此时栈顶元素一定是 y</p>
<p>a[i]=3421</p>
<p>要进栈的1，待出3</p>
<p>3&gt;1,123进栈，stack=123</p>
<p>4进栈：stack=123，待出栈3(y)，待进栈4(x)，4&gt;3==&gt;3是栈顶，3出栈，4进栈</p>
<p>stack=124,a[i]=3421</p>
<p>依次出栈</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">30</span>], <span class="built_in">stack</span>[<span class="number">30</span>], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_valid</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//要进栈元素</span></span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; a[i]) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span> || <span class="built_in">stack</span>[top] - a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        --top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">20</span>;;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_valid(a, n)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        --ans;</span><br><span class="line">    &#125; <span class="keyword">while</span>(ans &amp;&amp; next_permutation(a, a + n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-2-单调队列"><a href="#6-2-单调队列" class="headerlink" title="6.2.单调队列"></a>6.2.单调队列</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.11.28.png" alt="截屏2021-01-15 下午2.11.28"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.14.28.png" alt="截屏2021-01-15 下午2.14.28"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.16.34.png" alt="截屏2021-01-15 下午2.16.34"></p>
<ol>
<li>本质问题是：固定查询结尾的 RMQ 问题，例如 $RMQ(x, 7)$</li>
<li>问题性质：维护滑动窗口最值问题</li>
<li>入队：将队尾违反单调性的元素淘汰出局，再将当前元素入队</li>
<li>出队：如果队首元素超出了滑动窗口的范围，队首出队</li>
<li>队首元素：滑动窗口内的最值</li>
<li>均摊时间复杂度：$O(1)$</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.18.02.png" alt="截屏2021-01-15 下午2.18.02"></p>
<p>注：单调队列维护的区间最小值一定在队首</p>
<p>入队操作：</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.28.58.png" alt="截屏2021-01-15 下午2.28.58"></p>
<h2 id="6-3单调队列例题HZOJ-271-滑动窗口"><a href="#6-3单调队列例题HZOJ-271-滑动窗口" class="headerlink" title="6.3单调队列例题HZOJ-271-滑动窗口"></a>6.3单调队列例题HZOJ-271-滑动窗口</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.43.25.png" alt="截屏2021-01-15 下午2.43.25"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.43.34.png" alt="截屏2021-01-15 下午2.43.34"></p>
<p>单调队列的裸题,主要要学习代码实现</p>
<p><strong>思考：</strong>单调队列中是记录值还是记录下标的问题</p>
<p><strong>结论：</strong>==记录下标，因为有了下标可以索引到值，记录值则反向不可查==</p>
<h2 id="6-4单调队列及HZOJ271代码实现"><a href="#6-4单调队列及HZOJ271代码实现" class="headerlink" title="6.4单调队列及HZOJ271代码实现"></a>6.4单调队列及HZOJ271代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 300000</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">queue</span>[MAX_N + <span class="number">5</span>];<span class="comment">//维护数组的单调队列，存储数组下标</span></span><br><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;<span class="comment">//头指针，尾指针</span></span><br><span class="line"><span class="keyword">int</span> val[MAX_N + <span class="number">5</span>];<span class="comment">//数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;<span class="comment">//给出一个长度为 𝑁 的数组,一个长为 𝐾 的滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//滑动窗口最小值，用单调递增队列</span></span><br><span class="line">        <span class="keyword">while</span> ((tail - head) &amp;&amp; val[<span class="built_in">queue</span>[tail - <span class="number">1</span>]] &gt; val[i]) --tail;</span><br><span class="line">        <span class="comment">//队列中有元素，并且当前队尾元素的值&gt;要入队的元素，大于要入队的元素全部出队</span></span><br><span class="line">      <span class="comment">//维护单调队列的单调性</span></span><br><span class="line">        <span class="built_in">queue</span>[tail++] = i;<span class="comment">//存储下标</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[head] &lt;= i - k) head++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">            i &gt; k &amp;&amp; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; val[<span class="built_in">queue</span>[head]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    head = tail = <span class="number">0</span>;<span class="comment">//队列清空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//滑动窗口最大值，用单调递减队列</span></span><br><span class="line">        <span class="keyword">while</span> ((tail - head) &amp;&amp; val[<span class="built_in">queue</span>[tail - <span class="number">1</span>]] &lt; val[i]) --tail;</span><br><span class="line">        <span class="comment">//队列中有元素，并且当前队尾元素的值 &lt; 要入队的元素，小于要入队的元素全部出队</span></span><br><span class="line">        <span class="built_in">queue</span>[tail++] = i;<span class="comment">//存储下标</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[head] &lt;= i - k) head++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">            i &gt; k &amp;&amp; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; val[<span class="built_in">queue</span>[head]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="6-5单调栈"><a href="#6-5单调栈" class="headerlink" title="6.5单调栈"></a>6.5单调栈</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-151%20%E4%B8%8B%E5%8D%884.34.26.png" alt="截屏2021-01-151 下午4.34.26"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.34.59.png" alt="截屏2021-01-15 下午4.34.59"></p>
<ol>
<li>单调栈保留了单调队列的『入队』操作</li>
<li>单调栈依然是维护了一种单调性</li>
<li>问题性质：最近（大于/小于）关系</li>
<li>入栈之前，符合单调性的栈顶元素，就是我们要找的最近（大于/小于）关系</li>
<li>均摊时间复杂度：$O(1)$</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.30.37.png" alt="截屏2021-01-15 下午4.30.37"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.30.50.png" alt="截屏2021-01-15 下午4.30.50"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.31.08.png" alt="截屏2021-01-15 下午4.31.08"></p>
<h2 id="6-6单调栈例题HZOJ-264-最大矩形面积"><a href="#6-6单调栈例题HZOJ-264-最大矩形面积" class="headerlink" title="6.6单调栈例题HZOJ-264-最大矩形面积"></a>6.6单调栈例题HZOJ-264-最大矩形面积</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.56.33.png" alt="截屏2021-01-15 下午4.56.22"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.56.33.png" alt="截屏2021-01-15 下午4.56.33"></p>
<ol>
<li>分析最优解的性质，是解决问题的第一步</li>
<li>最大矩形的性质：一定是以其所在区域中最矮的木板为高度的</li>
<li>以每一块木板做为矩形高度，求能得到的最大矩形面积，最后在所有面积中，取一个最大值</li>
<li>需要求解：每一块木板最近的高度小于当前木板的位置，所以需要用单调栈</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.57.45.png" alt="截屏2021-01-15 下午4.57.18"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.57.45.png" alt="截屏2021-01-15 下午4.57.45"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">stack</span>[MAX_N + <span class="number">5</span>];<span class="comment">//单调栈，记录下标</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> h[MAX_N + <span class="number">5</span>];<span class="comment">//记录每一块木板的长度</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l[MAX_N + <span class="number">5</span>],r[MAX_N + <span class="number">5</span>];<span class="comment">//l</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; n;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="comment">//输入共一行，第一个数表示矩形的个数 𝑁。接下来 𝑁 个数表示矩形的大小。（1≤𝑁≤100000）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, h + i);</span><br><span class="line">        <span class="comment">//cin &gt;&gt; h[i];</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    h[<span class="number">0</span>] = h[n + <span class="number">1</span>] = <span class="number">-1</span>;<span class="comment">//最边上的两块木板,即边界木板</span></span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//求最近小于关系，单调递增栈</span></span><br><span class="line">    <span class="comment">//左边木板</span></span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="number">0</span>;<span class="comment">//0坐标先压栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; h[<span class="built_in">stack</span>[top]] &gt;= h[i]) --top;<span class="comment">//出栈</span></span><br><span class="line">        l[i] = <span class="built_in">stack</span>[top];</span><br><span class="line">      <span class="comment">//第i块木板左边离他最近的且高度小于他的木板编号</span></span><br><span class="line">        <span class="built_in">stack</span>[++top] = i;<span class="comment">//入栈</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右边木板</span></span><br><span class="line">    top = <span class="number">-1</span>;<span class="comment">//清空栈</span></span><br><span class="line">    <span class="comment">//求最近小于关系，单调递增栈</span></span><br><span class="line">    <span class="built_in">stack</span>[++top] = n + <span class="number">1</span>;<span class="comment">//最右边坐标先压栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; h[<span class="built_in">stack</span>[top]] &gt;= h[i]) --top;<span class="comment">//出栈</span></span><br><span class="line">        r[i] = <span class="built_in">stack</span>[top];</span><br><span class="line">      <span class="comment">//第i块木板右边离他最近的且高度小于他的木板编号</span></span><br><span class="line">        <span class="built_in">stack</span>[++top] = i;<span class="comment">//入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = max(ans, h[i] * (r[i] - l[i] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="7-单调队列和单调栈习题"><a href="#7-单调队列和单调栈习题" class="headerlink" title="7.单调队列和单调栈习题"></a>7.单调队列和单调栈习题</h1><h2 id="7-1HAIZEIOJ51矩形"><a href="#7-1HAIZEIOJ51矩形" class="headerlink" title="7.1HAIZEIOJ51矩形"></a>7.1HAIZEIOJ51矩形</h2><p><img src="Desktop/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%888.29.41.png" alt="截屏2021-01-15 下午8.29.41"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%888.29.51.png" alt="截屏2021-01-15 下午8.29.51"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%889.46.36.png" alt="截屏2021-01-17 上午9.46.36"></p>
<ol>
<li>左上角坐标和右下角坐标可以唯一确定一个子矩形</li>
<li>确定一行，将问题转换成子问题，右下角坐标落在固定的一行上，求每个点能构成的合法子矩形数量</li>
<li>通过观察，将问题变成两部分子问题</li>
<li>$f(x)$ 代表以 X 做为右下角坐标所能构成的合法子矩形数量</li>
<li>首先找到左侧离 X 点最近的，小于 X 点的位置 i</li>
<li>$f(x) = h_x\times (x-i) + f(i)$</li>
<li>因为需要求解离 X 最近的小于 X 的位置，所以要用到单调栈</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD_NUM 100007</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAX_N + <span class="number">5</span>], top;</span><br><span class="line"><span class="keyword">int</span> c[MAX_N + <span class="number">5</span>][MAX_N + <span class="number">5</span>];<span class="comment">//c[i][j]从[i,j]向上数，有多少个连续的白色格子，即矩形高</span></span><br><span class="line"><span class="keyword">int</span> f[MAX_N + <span class="number">5</span>];<span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;<span class="comment">//第一行输入两个数字 𝑛,𝑚（2≤𝑛,𝑚≤1000），代表矩形的长和宽。</span></span><br><span class="line">    <span class="comment">//接下来 𝑛 行，每行 𝑚 个数字，0 代表黑色格子，1 代表白色格子。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c[i][j];</span><br><span class="line">            <span class="keyword">if</span> (c[i][j] == <span class="number">1</span>) c[i][j] += c[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//n行</span></span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">stack</span>[++top] = <span class="number">0</span>;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;<span class="comment">//每行m个数字</span></span><br><span class="line">            <span class="keyword">while</span>(top != <span class="number">-1</span> &amp;&amp; c[i][<span class="built_in">stack</span>[top]] &gt; c[i][j]) --top;<span class="comment">//出栈，找到第一个比c[i][j]矮的</span></span><br><span class="line">            f[j] = c[i][j] * (j - <span class="built_in">stack</span>[top]) + f[<span class="built_in">stack</span>[top]];<span class="comment">//子矩形个数=矩形高x宽(即f(i)右边的子矩形个数) + f(i)左边的子矩形个数</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;f[j]&quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; f[j] &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">stack</span>[++top] = j;</span><br><span class="line">            f[j] %= MOD_NUM;</span><br><span class="line">            ans += f[j];</span><br><span class="line">            ans %= MOD_NUM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="7-2HZOJ-52-古老的打字机"><a href="#7-2HZOJ-52-古老的打字机" class="headerlink" title="7.2HZOJ-52-古老的打字机"></a>7.2HZOJ-52-古老的打字机</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.00.47.png" alt="截屏2021-01-17 上午11.00.47"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.00.58.png" alt="截屏2021-01-17 上午11.00.58"></p>
<h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><p>$dp[i]$ 代表打印前 i 个字符的最小消耗值</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>定义： $s_i = \sum_{k=1}^{i}c_k$</p>
<p>$dp[i] = min(dp[j] + (s_i - s_j)^2 + M)$</p>
<p><strong>时间复杂度：</strong>$O(n^2)$</p>
<h3 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h3><p>假设从 j 转移要优于从 k 转移</p>
<p>$dp[j] + (s_i-s_j)^2+M &lt; dp[k] + (s_i-s_k)^2+M$</p>
<p>$dp[j] + s_j^2-2s_is_j &lt; dp[k] + s_k^2-2s_is_k$</p>
<p>$(dp[j] + s_j^2) -(dp[k] + s_k^2)&lt; 2s_i(s_j-s_k)$</p>
<p>$\frac{(dp[j] + s_j^2) -(dp[k] + s_k^2)}{s_j-s_k}&lt; 2s_i$</p>
<p>设：$f(i) = dp[i] + s_i^2$</p>
<p>$\frac{f(j) - f(k)}{s_j-s_k}&lt; 2s_i$ ，这东西就是一个斜率</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.08.58.png" alt="截屏2021-01-17 上午11.08.30"></p>
<p><img src="Desktop/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.09.10.png" alt="截屏2021-01-17 上午11.09.10"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.09.25.png" alt="截屏2021-01-17 上午11.09.25"></p>
<p>==&gt;$\frac{f(j) - f(k)}{s_j-s_k}&lt; 2s_i$ 意味着从j点转移比从k点转移更优秀</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.09.34.png" alt="截屏2021-01-17 上午11.09.34"></p>
<p>1.从k转移优于从j转移，从l转移优于从k转移，所以选择从l转移</p>
<p>2.。</p>
<p>3..</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.09.39.png" alt="截屏2021-01-17 上午11.09.39"></p>
<p>经过斜率优化以后，时间复杂度优化成了：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(a) ((a) * (a))</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  dp[MAX_N + <span class="number">5</span>], c[MAX_N + <span class="number">5</span>], s[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, M;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> q[MAX_N + <span class="number">5</span>], head, tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//求斜率</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (f[i] - f[j])/(s[i] - s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; M;</span><br><span class="line">    <span class="comment">//第一行输入两个数字，𝑛,𝑀(1≤𝑛≤106,1≤𝑀≤104) 代表文章中字符数量和打字机单次启动的固定磨损值。</span></span><br><span class="line">    <span class="comment">//第二行输入 𝑛 个数字，第 𝑖 个数字代表文章中第 𝑖 个字符的磨损值 𝐶𝑖(1≤𝐶𝑖≤100)。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c[i];<span class="comment">//cin &gt;&gt; s[i];</span></span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + c[i];<span class="comment">//s[i] = s[i - 1] + s[i];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//从i点转移到j点</span></span><br><span class="line">    dp[i] = dp[j] + S(s[i] - s[j]) + M;</span><br><span class="line">    f[i] = dp[i] + S(s[i]);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    q[tail++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tail - head &gt;= <span class="number">2</span> &amp;&amp; slope(q[head + <span class="number">1</span>], q[head]) &lt; <span class="number">2</span> * s[i]) ++head;<span class="comment">//</span></span><br><span class="line">        set_dp(i, q[head]);</span><br><span class="line">        <span class="keyword">while</span> (tail - head &gt;= <span class="number">2</span> &amp;&amp; slope(i, q[tail - <span class="number">1</span>]) &lt; slope(q[tail - <span class="number">2</span>], q[tail - <span class="number">1</span>])) --tail;</span><br><span class="line">        q[tail++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="三、HZOJ-372-双生序列"><a href="#三、HZOJ-372-双生序列" class="headerlink" title="三、HZOJ-372-双生序列"></a>三、HZOJ-372-双生序列</h2><ol>
<li>因为两个序列的每个区间的 RMQ 值都相等，等价于两个序列的单调队列长得一样</li>
<li>将两个序列，依次插入到单调队列中，过程中判断单调队列是否一样，如果不一样，就退出</li>
<li>所以，需要使用单调队列</li>
</ol>
<h2 id="四、HZOJ-270-最大子序和"><a href="#四、HZOJ-270-最大子序和" class="headerlink" title="四、HZOJ-270-最大子序和"></a>四、HZOJ-270-最大子序和</h2><ol>
<li>有个限制条件：子序列的长度不超过 M</li>
<li>转换成前缀和数组上的问题，就是 $S_i - S_j$，其中$i-j &lt;= M$</li>
<li>在前缀和数组上，维护一个大小为 M 的滑动窗口中的最小值</li>
<li>所以，采用单调队列维护区间最小值</li>
</ol>
<p><img src="../guanghu/Library/Application%20Support/typora-user-images/image-20210110214945169.png" alt="image-20210110214945169"></p>
<h1 id="0-00000"><a href="#0-00000" class="headerlink" title="0.00000"></a>0.00000</h1><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h1 id="0000000000"><a href="#0000000000" class="headerlink" title="0000000000"></a>0000000000</h1>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
</search>
