<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面试笔试算法上</title>
    <url>/2020/12/29/09.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="1-编码能力提升"><a href="#1-编码能力提升" class="headerlink" title="1.编码能力提升"></a>1.编码能力提升</h1><h1 id="2-二分专题"><a href="#2-二分专题" class="headerlink" title="2.二分专题"></a>2.二分专题</h1><a id="more"></a>

<h1 id="3-OJ题目讲解"><a href="#3-OJ题目讲解" class="headerlink" title="3.OJ题目讲解"></a>3.OJ题目讲解</h1><h1 id="4-leetcode题目"><a href="#4-leetcode题目" class="headerlink" title="4.leetcode题目"></a>4.leetcode题目</h1><h1 id="5-STL容器使用与练习"><a href="#5-STL容器使用与练习" class="headerlink" title="5.STL容器使用与练习"></a>5.STL容器使用与练习</h1><h2 id="5-1queue与stack的操作"><a href="#5-1queue与stack的操作" class="headerlink" title="5.1queue与stack的操作"></a>5.1queue与stack的操作</h2><h3 id="使用queue"><a href="#使用queue" class="headerlink" title="使用queue"></a>使用queue</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.push(<span class="number">5</span>);<span class="comment">//入队向队列添加5</span></span><br><span class="line">que.pop();<span class="comment">//出队</span></span><br><span class="line">que.front();<span class="comment">//队首</span></span><br><span class="line">que.size();<span class="comment">//队列中的元素个数</span></span><br><span class="line">que.empty();<span class="comment">//判断队列是否为空，true false</span></span><br></pre></td></tr></table></figure>


<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.push();</span><br><span class="line">s.pop();</span><br><span class="line">s.top();<span class="comment">//获得栈顶元素</span></span><br><span class="line">s.size();</span><br><span class="line">s.empty();</span><br></pre></td></tr></table></figure>


<p>底层是由双端队列实现的，本质上不是容器，</p>
<h2 id="5-2queue代码演示"><a href="#5-2queue代码演示" class="headerlink" title="5.2queue代码演示"></a>5.2queue代码演示</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">4</span>; i--) &#123;</span><br><span class="line">        que.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="comment">//queue.size();</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;que.front() = &quot;</span> &lt;&lt; que.front() &lt;&lt; <span class="string">&quot;\t que.size() = &quot;</span> &lt;&lt; que.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">    Node node;</span><br><span class="line">    node.x = <span class="number">1</span>;</span><br><span class="line">    node.y = <span class="number">2</span>;</span><br><span class="line">    q.push(node);</span><br><span class="line">    q.push((Node)&#123;<span class="number">7</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; q.front().x &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line">    q.pop();</span><br><span class="line">    Node temp = q.front();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; temp.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">que.front() &#x3D; 9	 que.size() &#x3D; 5</span><br><span class="line">que.front() &#x3D; 8	 que.size() &#x3D; 4</span><br><span class="line">que.front() &#x3D; 7	 que.size() &#x3D; 3</span><br><span class="line">que.front() &#x3D; 6	 que.size() &#x3D; 2</span><br><span class="line">que.front() &#x3D; 5	 que.size() &#x3D; 1</span><br><span class="line">1</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure>


<h2 id="5-3stack代码演示"><a href="#5-3stack代码演示" class="headerlink" title="5.3stack代码演示"></a>5.3stack代码演示</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">4</span>; i--) &#123;</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (s.size()) &#123;</span><br><span class="line">        <span class="comment">//!s.empty()</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s.top() = &quot;</span> &lt;&lt; s.top() &lt;&lt; <span class="string">&quot;\t s.size() = &quot;</span> &lt;&lt; s.size() &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">s.top() = 5	 s.size() = 5</span><br><span class="line">s.top() = 6	 s.size() = 4</span><br><span class="line">s.top() = 7	 s.size() = 3</span><br><span class="line">s.top() = 8	 s.size() = 2</span><br><span class="line">s.top() = 9	 s.size() = 1</span><br></pre></td></tr></table></figure>


<h2 id="5-4vector-动态数组priority-queue-优先队列"><a href="#5-4vector-动态数组priority-queue-优先队列" class="headerlink" title="5.4vector()动态数组priority_queue()优先队列"></a>5.4vector()动态数组priority_queue()优先队列</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">v(<span class="number">2</span>);<span class="comment">//2个</span></span><br><span class="line">v(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//1个2</span></span><br><span class="line">v.push_back(<span class="number">5</span>);<span class="comment">//在结尾加入5，O(1)</span></span><br><span class="line">v.size();<span class="comment">//</span></span><br><span class="line">v.insert(<span class="number">1</span>, <span class="number">6</span>);<span class="comment">//第1个位置插入6,O(n)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v1;<span class="comment">//二维数组，C++11之前必须有空格</span></span><br><span class="line">v(<span class="number">2</span>);</span><br><span class="line">v(<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;<span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>底层</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; que;<span class="comment">//默认是大的</span></span><br><span class="line">que.push(<span class="number">3</span>);</span><br><span class="line">que.pop();</span><br><span class="line">que.top();<span class="comment">//堆顶元素</span></span><br><span class="line">que.size();</span><br><span class="line">que.empty();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="comment">//自定义序列无法排序，需要重载小于号</span></span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node b) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x&gt;b.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>底层堆实现</p>
<h2 id="5-5vector-代码演示"><a href="#5-5vector-代码演示" class="headerlink" title="5.5vector()代码演示"></a>5.5vector()代码演示</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">105</span>; i &lt;= <span class="number">110</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v.size() = &quot;</span>&lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;v[%d] = %d\n&quot;</span>, i, v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;==========&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v1;</span><br><span class="line">    v1.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());<span class="comment">//插入一个空的vector()</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">66</span>; i &lt;= <span class="number">70</span>; i++) &#123;</span><br><span class="line">        v1[<span class="number">0</span>].push_back(i);<span class="comment">//在第一行插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    v1.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">55</span>));<span class="comment">// 5个值为55的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    v2.push_back(<span class="number">5</span>);</span><br><span class="line">    v2.push_back(<span class="number">6</span>);</span><br><span class="line">    v2.push_back(<span class="number">7</span>);</span><br><span class="line">    v2.push_back(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    v1.push_back(v2);</span><br><span class="line">    v1.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)v.size(); i++) &#123;<span class="comment">//打印数组</span></span><br><span class="line">        <span class="comment">//整体作为二维数组输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)v1[i].size(); j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;v1[%d][%d] = %d &quot;</span>,i, j, v1[i][j]);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; v1[i][j] &lt;&lt; &quot;\t&quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v.size() &#x3D; 1</span><br><span class="line">v.size() &#x3D; 2</span><br><span class="line">v.size() &#x3D; 3</span><br><span class="line">v.size() &#x3D; 4</span><br><span class="line">v.size() &#x3D; 5</span><br><span class="line">v.size() &#x3D; 6</span><br><span class="line">v[0] &#x3D; 105</span><br><span class="line">v[1] &#x3D; 106</span><br><span class="line">v[2] &#x3D; 107</span><br><span class="line">v[3] &#x3D; 108</span><br><span class="line">v[4] &#x3D; 109</span><br><span class="line">v[5] &#x3D; 110</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">v1[0][0] &#x3D; 66 v1[0][1] &#x3D; 67 v1[0][2] &#x3D; 68 v1[0][3] &#x3D; 69 v1[0][4] &#x3D; 70</span><br><span class="line">v1[1][0] &#x3D; 55 v1[1][1] &#x3D; 55 v1[1][2] &#x3D; 55 v1[1][3] &#x3D; 55 v1[1][4] &#x3D; 55</span><br><span class="line">v1[2][0] &#x3D; 5 v1[2][1] &#x3D; 6 v1[2][2] &#x3D; 7 v1[2][3] &#x3D; 8</span><br><span class="line">v1[3][0] &#x3D; 1 v1[3][1] &#x3D; 1 v1[3][2] &#x3D; 1 v1[3][3] &#x3D; 1 v1[3][4] &#x3D; 1 v1[3][5] &#x3D; 1 v1[3][6] &#x3D; 1 v1[3][7] &#x3D; 1 v1[3][8] &#x3D; 1 v1[3][9] &#x3D; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>








<h1 id="6-排列组合与搜索走地图问题"><a href="#6-排列组合与搜索走地图问题" class="headerlink" title="6.排列组合与搜索走地图问题"></a>6.排列组合与搜索走地图问题</h1><h1 id="7-搜索综合问题"><a href="#7-搜索综合问题" class="headerlink" title="7.搜索综合问题"></a>7.搜索综合问题</h1>]]></content>
      <categories>
        <category>面试笔试算法上</category>
      </categories>
      <tags>
        <tag>面试笔试算法上</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构</title>
    <url>/2020/12/22/03.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="0、预习2020-12-22"><a href="#0、预习2020-12-22" class="headerlink" title="0、预习2020.12.22"></a>0、预习2020.12.22</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请在下面实现哈希表类 HashTable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> *elem;<span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">//哈希表的容量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HashTable() &#123;<span class="comment">//无参构造函数</span></span><br><span class="line">        size = <span class="number">1000</span>;<span class="comment">//初始化哈希表长度</span></span><br><span class="line">        elem = <span class="keyword">new</span> <span class="built_in">string</span>[size];<span class="comment">//动态分配内存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            elem[i] = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            <span class="comment">//给每个元素赋初值，在哈希查找时判断该位置是否已有字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~HashTable() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] elem;<span class="comment">//释放内存，避免内存泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashTable hashtable;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<a id="more"></a>


















<h1 id="1-顺序表与链表"><a href="#1-顺序表与链表" class="headerlink" title="1.顺序表与链表"></a>1.顺序表与链表</h1><h2 id="1-顺序表"><a href="#1-顺序表" class="headerlink" title="1.顺序表"></a>1.顺序表</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8A%E5%8D%8810.17.04.png" alt="截屏2020-11-02 上午10.17.04"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8A%E5%8D%8810.19.36.png" alt="截屏2020-11-02 上午10.19.36"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8A%E5%8D%8810.24.28.png" alt="截屏2020-11-02 上午10.24.28"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8A%E5%8D%8810.39.19.png" alt="截屏2020-11-02 上午10.39.19"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8A%E5%8D%8810.40.05.png" alt="截屏2020-11-02 上午10.40.05"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8B%E5%8D%883.42.57.png" alt="截屏2020-11-02 下午3.42.57"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8B%E5%8D%883.43.57.png" alt="截屏2020-11-02 下午3.43.57"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8B%E5%8D%883.45.11.png" alt="截屏2020-11-02 下午3.45.11"></p>
<p>算法：在cpu资源有限的情况下，执行更多的命令</p>
<p>数据结构=结构定义+结构操作</p>
<p>顺序表：更高级的数组，连续的存储空间，可以存储任意类型</p>
<blockquote>
<p>malloc 仅开辟空间，calloc 开辟空间并且初始化，清空原来的值，realloc 重新划分空间<br>realloc(地址,字节数)，返回值为新开辟空间的首地址，<br>首先会在原来地址的后面开辟一倍的地址，并且返回原来的首地址，<br>如果后面的取件无法扩建，找一个其他地方，为原来的两倍，将原来的内容拷贝到新开辟的空间，返回首地址<br>不一定开辟成功，降低需求开1/2，如果无法开辟空间返回值为NULL,</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR(a,b) <span class="meta-string">&quot;\033[&quot;</span> #b <span class="meta-string">&quot;m&quot;</span> a <span class="meta-string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN(a) COLOR(a, 32)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;<span class="comment">//存储数据，记录连续开辟的存储空间的首地址</span></span><br><span class="line">    <span class="keyword">int</span> size, length;<span class="comment">//</span></span><br><span class="line">&#125; Vec;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     Vec *v = (Vec *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Vec));<span class="comment">//动态开辟空间</span></span><br><span class="line">     v-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);<span class="comment">//data指向开辟空间的首地址</span></span><br><span class="line">     v-&gt;size = n;<span class="comment">//</span></span><br><span class="line">     v-&gt;length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Vec *v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//malloc 仅开辟空间，calloc 开辟空间并且初始化，清空原来的值，realloc 重新划分空间</span></span><br><span class="line">    <span class="comment">//realloc(地址,字节数)，返回值为新开辟空间的首地址，</span></span><br><span class="line">    <span class="comment">//首先会在原来地址的后面开辟一倍的地址，并且返回原来的首地址，</span></span><br><span class="line">    <span class="comment">//如果后面的取件无法扩建，找一个其他地方，为原来的两倍，将原来的内容拷贝到新开辟的空间，返回首地址</span></span><br><span class="line">    <span class="comment">//不一定开辟成功，降低需求开1/2，如果无法开辟空间返回值为NULL,</span></span><br><span class="line">    <span class="keyword">int</span> extr_size = v-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">while</span> (extr_size) &#123;</span><br><span class="line">        p = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(v-&gt;data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (v-&gt;size + extr_size));<span class="comment">//开辟原来的2倍</span></span><br><span class="line">        <span class="keyword">if</span> (p) <span class="keyword">break</span>;<span class="comment">//开辟空间成功</span></span><br><span class="line">        extr_size &gt;&gt;= <span class="number">1</span>;<span class="comment">//开辟空间失败,降低需求，开辟1/2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (extr_size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    v-&gt;data = p;</span><br><span class="line">    v-&gt;size += extr_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Vec *v, <span class="keyword">int</span> value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在v中的index位置插入值value</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; v-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//插入位置不合法</span></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;length == v-&gt;size) &#123;<span class="comment">//顺序表已满,扩容</span></span><br><span class="line">        <span class="keyword">if</span> (!expand(v)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(GREEN(<span class="string">&quot;success to expand! the Vector size is %d\n&quot;</span>), v-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = v-&gt;length; i &gt; index; i--) &#123;</span><br><span class="line">        v-&gt;data[i] = v-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;data[index] = value;</span><br><span class="line">    v-&gt;length +=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除顺序表中第index位置的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(Vec *v, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= v-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//插入位置不合法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; v-&gt;length; i++) &#123;</span><br><span class="line">        v-&gt;data[i - <span class="number">1</span>] = v-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;length -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Vec *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="literal">NULL</span>) <span class="keyword">return</span> ;<span class="comment">//如果v为空</span></span><br><span class="line">    <span class="built_in">free</span>(v-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(v);<span class="comment">//释放malloc动态申请的内存</span></span><br><span class="line">       <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出线性表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Vec *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Vector : [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v-&gt;length; i++) &#123;</span><br><span class="line">        <span class="function">i &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    Vec *v = init(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> index = rand() % (v-&gt;length + <span class="number">3</span>) <span class="number">-1</span>;<span class="comment">//index = [-1, length + 2],测试用例</span></span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;<span class="comment">//012插入3删除</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;insert %d at %d to Vector = %d\n&quot;</span>, value, index, insert(v, value, index));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;erase a iterm at %d from Vector = %d\n&quot;</span>, index, erase(v, index));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(v);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-03%20%E4%B8%8B%E5%8D%888.10.29.png" alt="截屏2020-11-03 下午4.30.00"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-03%20%E4%B8%8B%E5%8D%888.10.29.png" alt="截屏2020-11-03 下午8.10.29"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-17%20%E4%B8%8B%E5%8D%882.09.53.png"></p>
<p>链表内部有数据和记录下一个结点的地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span><span class="comment">//结点</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//存储数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span><span class="comment">//记录下一个结点的位置</span></span><br><span class="line">&#125; ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span><span class="comment">//链表</span></span><br><span class="line">    ListNode head;<span class="comment">//虚拟头结点，list</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; List;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">createNewNode</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//初始化结点</span></span><br><span class="line"><span class="function">List *<span class="title">createLinkList</span><span class="params">()</span></span>;<span class="comment">//初始化链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(ListNode *)</span></span>;<span class="comment">//释放结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(List *)</span></span>;<span class="comment">//释放链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(List *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;<span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(List *, <span class="keyword">int</span>)</span></span>;<span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(List *)</span></span>;<span class="comment">//打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List *)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    List *<span class="built_in">list</span> = createLinkList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> index = rand() % (<span class="built_in">list</span>-&gt;length + <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;insert %d at  %d to list = %d\n&quot;</span>, value, index, insert(<span class="built_in">list</span>, index, value));</span><br><span class="line">               &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;earse a iterm at %d from list = %d\n&quot;</span>, index, erase(<span class="built_in">list</span>, index));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;reverse the list!\n&quot;</span>);</span><br><span class="line">            reverse(<span class="built_in">list</span>);</span><br><span class="line">             &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(<span class="built_in">list</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line">    clear(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">createNewNode</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    ListNode *node = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    node-&gt;data = value;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List *<span class="title">createLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List *<span class="built_in">list</span> = (List *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">    <span class="built_in">list</span>-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="built_in">list</span>-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ListNode *p = &amp;(<span class="built_in">list</span>-&gt;head);<span class="comment">//指向头结点</span></span><br><span class="line">    ListNode *node = createNewNode(value);<span class="comment">//初始化结点，准备插入链表中</span></span><br><span class="line">    <span class="keyword">while</span> (index--) p = p-&gt;next;</span><br><span class="line">    node-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = node;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">list</span>-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ListNode *p = &amp;(<span class="built_in">list</span>-&gt;head);</span><br><span class="line">    ListNode *delete_node;</span><br><span class="line">    <span class="keyword">while</span> (index--) p = p-&gt;next;</span><br><span class="line">    delete_node = p-&gt;next;</span><br><span class="line">    p-&gt;next = delete_node-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(delete_node);</span><br><span class="line">    <span class="built_in">list</span>-&gt;length -=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    ListNode *p = <span class="built_in">list</span>-&gt;head.next;</span><br><span class="line">    ListNode *q;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="built_in">list</span>-&gt;head.next;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head.next = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;List(%d) = [&quot;</span>, <span class="built_in">list</span>-&gt;length);</span><br><span class="line">    <span class="keyword">for</span> (ListNode *p = <span class="built_in">list</span>-&gt;head.next; p; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(ListNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    ListNode *delete_node = <span class="built_in">list</span>-&gt;head.next;</span><br><span class="line">    ListNode *temp;</span><br><span class="line">    <span class="keyword">while</span> (delete_node) &#123;</span><br><span class="line">        temp = delete_node-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(delete_node);</span><br><span class="line">        delete_node = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="2-栈和队列"><a href="#2-栈和队列" class="headerlink" title="2.栈和队列"></a>2.栈和队列</h1><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8B%E5%8D%883.19.10.png" alt="截屏2020-11-04 下午3.19.10"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8B%E5%8D%883.20.10.png" alt="截屏2020-11-04 下午3.20.10"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8B%E5%8D%883.20.41.png" alt="截屏2020-11-04 下午3.20.41"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8A%E5%8D%8810.37.49.png" alt="截屏2020-11-05 上午10.37.49"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%883.07.14.png" alt="截屏2020-11-05 下午3.07.14"></p>
<p>线性数据结构</p>
<p>FILO (First In Last Out)先进后出</p>
<p>栈顶指针</p>
<p>对于一个空栈，栈顶指针下标为-1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR(a, b) <span class="meta-string">&quot;\033[&quot;</span> #b <span class="meta-string">&quot;m&quot;</span> a <span class="meta-string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN(a) COLOR(a, 32)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack *<span class="title">init</span><span class="params">(<span class="keyword">int</span> input_size)</span> </span>&#123;<span class="comment">//初始化栈</span></span><br><span class="line">    Stack *<span class="built_in">stack</span> = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * input_size);</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = input_size;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;<span class="comment">//栈顶指针初始值为-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> </span>&#123;<span class="comment">//栈顶元素</span></span><br><span class="line">    <span class="comment">//if (empty(stack)) return 0;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> </span>&#123;<span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> </span>&#123;<span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">int</span> *temp_stack;</span><br><span class="line">    <span class="keyword">int</span> extr_size = <span class="built_in">stack</span>-&gt;size;</span><br><span class="line">    <span class="keyword">while</span> (extr_size) &#123;</span><br><span class="line">        temp_stack = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(<span class="built_in">stack</span>-&gt;data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (extr_size + <span class="built_in">stack</span>-&gt;size));</span><br><span class="line">        <span class="keyword">if</span> (temp_stack) <span class="keyword">break</span>;</span><br><span class="line">        extr_size &gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp_stack == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//扩容失败</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;size += extr_size;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data = temp_stack;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="built_in">stack</span>-&gt;size - <span class="number">1</span>)&#123; <span class="comment">//扩容</span></span><br><span class="line">        <span class="keyword">if</span> (!expand(<span class="built_in">stack</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(GREEN(<span class="string">&quot;expand successful! stack-&gt;size = %d \n&quot;</span>), <span class="built_in">stack</span>-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> </span>&#123;<span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(<span class="built_in">stack</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> </span>&#123;<span class="comment">//打印栈</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (empty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;stack empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">stack</span>-&gt;top; i++) &#123;</span><br><span class="line">        <span class="function">i &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">stack</span>-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> </span>&#123;<span class="comment">//释放申请的内存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    Stack *<span class="built_in">stack</span> = init(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">       <span class="keyword">int</span> value = rand() % <span class="number">100</span>;</span><br><span class="line">       <span class="keyword">int</span> op = rand() % <span class="number">4</span>;</span><br><span class="line">       <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the stack= %d\n&quot;</span>, value, push(<span class="built_in">stack</span>, value));</span><br><span class="line">               &#125;<span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;pop %d from the stack!&quot;</span>, top(<span class="built_in">stack</span>));</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, pop(<span class="built_in">stack</span>));</span><br><span class="line">               &#125;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       output(<span class="built_in">stack</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line">    clear(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h2><p>先进先出FIFO(First In First out)</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8A%E5%8D%889.17.30.png" alt="截屏2020-11-04 上午9.17.30"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8A%E5%8D%889.19.23.png" alt="截屏2020-11-04 上午9.19.23"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8A%E5%8D%889.19.46.png" alt="截屏2020-11-04 上午9.19.46"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8A%E5%8D%889.21.18.png" alt="截屏2020-11-04 上午9.21.18"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8A%E5%8D%8811.30.30.png" alt="截屏2020-11-04 上午11.30.30"></p>
<h3 id="1-简单队列"><a href="#1-简单队列" class="headerlink" title="1.简单队列"></a>1.简单队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构定义+结构操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> head;<span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">int</span> tail;<span class="comment">//尾结点，最后一个元素的下一个为空的位置</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构操作</span></span><br><span class="line"><span class="function">Queue *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//初始化队列</span></span><br><span class="line">    Queue *<span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="built_in">queue</span>-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;length = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;head == <span class="built_in">queue</span>-&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;tail == <span class="built_in">queue</span>-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;tail++] = value;</span><br><span class="line">    <span class="comment">//queue-&gt;tail++;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(<span class="built_in">queue</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Queue : [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">queue</span>-&gt;head, j = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>-&gt;tail; i++,j++) &#123;</span><br><span class="line">        <span class="function">j &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">queue</span>-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;<span class="comment">//清空队列</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;data);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    Queue *<span class="built_in">queue</span> = init(max_op);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;push %d to the Queue !&quot;</span>, value);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, push(<span class="built_in">queue</span>, value));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;pop %d from th Queue !&quot;</span>, value);</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, pop(<span class="built_in">queue</span>));</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line">    clear(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="2-循环队列"><a href="#2-循环队列" class="headerlink" title="2.循环队列"></a>2.循环队列</h3><p>（解决假溢出，出队时，头指针往后走，会造成假溢出）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构定义+结构操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> head;<span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">int</span> tail;<span class="comment">//尾结点，最后一个元素的下一个为空的位置</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> count;<span class="comment">//记录队列中元素的个数</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构操作</span></span><br><span class="line"><span class="function">Queue *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//初始化队列</span></span><br><span class="line">    Queue *<span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="built_in">queue</span>-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;length = n;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">   <span class="comment">// return queue-&gt;head == queue-&gt;tail;</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;count == <span class="built_in">queue</span>-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;tail++] = value;</span><br><span class="line">    <span class="comment">//queue-&gt;tail++;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;tail == <span class="built_in">queue</span>-&gt;length) <span class="built_in">queue</span>-&gt;tail = <span class="number">0</span>;<span class="comment">//queue-&gt;tail %= queue-&gt;length;</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(<span class="built_in">queue</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="built_in">queue</span>-&gt;length) <span class="built_in">queue</span>-&gt;head = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;count--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Queue : [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">queue</span>-&gt;head, j = <span class="number">0</span>; j &lt; <span class="built_in">queue</span>-&gt;count; i++,j++) &#123;</span><br><span class="line">        <span class="function">j &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">queue</span>-&gt;data[i % <span class="built_in">queue</span>-&gt;length]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;<span class="comment">//清空队列</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;data);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    Queue *<span class="built_in">queue</span> = init(max_op);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;push %d to the Queue !&quot;</span>, value);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, push(<span class="built_in">queue</span>, value));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;pop %d from th Queue !&quot;</span>, value);</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, pop(<span class="built_in">queue</span>));</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line">    clear(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决了假溢出但是会出现真溢出</p>
<h3 id="3-循环队列2"><a href="#3-循环队列2" class="headerlink" title="3.循环队列2"></a>3.循环队列2</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR(a,b) <span class="meta-string">&quot;\033[&quot;</span> #b <span class="meta-string">&quot;m&quot;</span> a <span class="meta-string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN(a) COLOR(a,32)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构定义+结构操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> head;<span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">int</span> tail;<span class="comment">//尾结点，最后一个元素的下一个为空的位置</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> count;<span class="comment">//记录队列中元素的个数</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构操作</span></span><br><span class="line"><span class="function">Queue *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//初始化队列</span></span><br><span class="line">    Queue *<span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="built_in">queue</span>-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;length = n;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">   <span class="comment">// return queue-&gt;head == queue-&gt;tail;</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> extr_size = <span class="built_in">queue</span>-&gt;length;</span><br><span class="line">    <span class="keyword">int</span> *temp_queue;</span><br><span class="line">    <span class="keyword">while</span> (extr_size) &#123;</span><br><span class="line">        temp_queue = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (extr_size + <span class="built_in">queue</span>-&gt;length));</span><br><span class="line">        <span class="keyword">if</span> (temp_queue) <span class="keyword">break</span>;</span><br><span class="line">        extr_size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp_queue == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">queue</span>-&gt;head, j = <span class="number">0</span>; j &lt; <span class="built_in">queue</span>-&gt;count; j++) &#123;</span><br><span class="line">        temp_queue[j] = <span class="built_in">queue</span>-&gt;data[(i + j) % <span class="built_in">queue</span>-&gt;length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;data);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = temp_queue;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;length += extr_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = <span class="built_in">queue</span>-&gt;count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;count == <span class="built_in">queue</span>-&gt;length) &#123;<span class="comment">//扩容</span></span><br><span class="line">        <span class="keyword">if</span>(!expand(<span class="built_in">queue</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(GREEN(<span class="string">&quot;ecpand sucessfull!Queue-&gt;size = %d\n&quot;</span>), <span class="built_in">queue</span>-&gt;length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;tail++] = value;</span><br><span class="line">    <span class="comment">//queue-&gt;tail++;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;tail == <span class="built_in">queue</span>-&gt;length) <span class="built_in">queue</span>-&gt;tail = <span class="number">0</span>;<span class="comment">//queue-&gt;tail %= queue-&gt;length;</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(<span class="built_in">queue</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="built_in">queue</span>-&gt;length) <span class="built_in">queue</span>-&gt;head = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;count--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Queue : [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">queue</span>-&gt;head, j = <span class="number">0</span>; j &lt; <span class="built_in">queue</span>-&gt;count; i++,j++) &#123;</span><br><span class="line">        <span class="function">j &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">queue</span>-&gt;data[i % <span class="built_in">queue</span>-&gt;length]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> </span>&#123;<span class="comment">//清空队列</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;data);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    Queue *<span class="built_in">queue</span> = init(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;push %d to the Queue !&quot;</span>, value);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, push(<span class="built_in">queue</span>, value));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;pop %d from th Queue !&quot;</span>, value);</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, pop(<span class="built_in">queue</span>));</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line">    clear(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="3-树"><a href="#3-树" class="headerlink" title="3.树"></a>3.树</h1><h2 id="3-1-二叉树"><a href="#3-1-二叉树" class="headerlink" title="3.1.二叉树"></a>3.1.二叉树</h2><p>二叉树性质</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%884.56.15.png" alt="截屏2020-11-05 下午4.56.15"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.04.49.png" alt="截屏2020-11-05 下午5.04.49"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.24.57.png" alt="截屏2020-11-05 下午5.24.57"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.25.24.png" alt="截屏2020-11-05 下午5.25.24"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.25.31.png" alt="截屏2020-11-05 下午5.25.31"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.25.51.png" alt="截屏2020-11-05 下午5.25.51"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-06%20%E4%B8%8B%E5%8D%8811.15.42.png" alt="截屏2020-11-06 下午11.15.42"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-06%20%E4%B8%8B%E5%8D%8811.17.03.png" alt="截屏2020-11-06 下午11.17.03"></p>
<h2 id="3-2-二叉树代码演示"><a href="#3-2-二叉树代码演示" class="headerlink" title="3.2.二叉树代码演示"></a>3.2.二叉树代码演示</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="comment">//定义节点</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span><span class="comment">//定义树</span></span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//节点个数</span></span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span> <span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//节点初始化</span></span><br><span class="line">    Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = value;</span><br><span class="line">    node-&gt;lchild = node-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree *<span class="title">getNewTree</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化树</span></span><br><span class="line">    Tree *tree = (Tree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert_node</span><span class="params">(Node *root, <span class="keyword">int</span> value, <span class="keyword">int</span> *flag)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getNewNode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data &gt; value) root-&gt;lchild = insert_node(root-&gt;lchild, value, flag);<span class="comment">//递归插入，直到节点为空</span></span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert_node(root-&gt;rchild, value, flag);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Tree *tree, <span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//二叉查找树/二叉排序树</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    tree-&gt;root = insert_node(tree-&gt;root, value, &amp;flag);</span><br><span class="line">    tree-&gt;n += flag;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearNode</span><span class="params">(Node *node)</span> </span>&#123;<span class="comment">//释放节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clearNode(node-&gt;lchild);</span><br><span class="line">    clearNode(node-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Tree *tree)</span> </span>&#123;<span class="comment">//释放树申请的内存</span></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clearNode(tree-&gt;root);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树的遍历</span></span><br><span class="line"><span class="comment">//1.先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_node</span><span class="params">(Node *node)</span> </span>&#123;<span class="comment">//先序遍历（递归）</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);</span><br><span class="line">    pre_order_node(node-&gt;lchild);</span><br><span class="line">    pre_order_node(node-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(Tree *tree)</span> </span>&#123;<span class="comment">//先序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pre_order : &quot;</span>);</span><br><span class="line">    pre_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    in_order_node(node-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);</span><br><span class="line">    in_order_node(node-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(Tree *tree)</span> </span>&#123;<span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pre_order : &quot;</span>);</span><br><span class="line">    in_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    post_order_node(node-&gt;lchild);</span><br><span class="line">    post_order_node(node-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order</span><span class="params">(Tree *tree)</span> </span>&#123;<span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pre_order : &quot;</span>);</span><br><span class="line">    post_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    output_node(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    output_node(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Tree *tree)</span> </span>&#123;<span class="comment">//输出广义表</span></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tree(%d) : &quot;</span>, tree-&gt;n);</span><br><span class="line">    output_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    Tree *tree = getNewTree();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 4</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = rand() % <span class="number">100</span>;</span><br><span class="line">        insert(tree, value);</span><br><span class="line">        output(tree);</span><br><span class="line">    &#125;</span><br><span class="line">    pre_order(tree);</span><br><span class="line">    in_order(tree);</span><br><span class="line">    post_order(tree);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line">    clear(tree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h2 id="3-3-广义表转二叉树"><a href="#3-3-广义表转二叉树" class="headerlink" title="3.3.广义表转二叉树"></a>3.3.广义表转二叉树</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    Node **data;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = value;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree *<span class="title">getNewTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tree *tree = (Tree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack *<span class="title">init_stack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Stack *<span class="built_in">stack</span> = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *) * n);</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">top</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Stack *<span class="built_in">stack</span>, Node *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="built_in">stack</span>-&gt;size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data[++(<span class="built_in">stack</span>-&gt;top)] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(<span class="built_in">stack</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_stack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear_node(node-&gt;lchild);</span><br><span class="line">    clear_node(node-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_tree</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> *node_num)</span> </span>&#123;</span><br><span class="line">    Stack *<span class="built_in">stack</span> = init_stack(<span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//标记逗号，确定是左孩子还是右孩子,flag = 0,在逗号左侧，左孩子， 1 在逗号右侧右孩子</span></span><br><span class="line">    Node *temp = <span class="literal">NULL</span>;<span class="comment">//临时保存新节点</span></span><br><span class="line">    Node *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (str[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:&#123;</span><br><span class="line">            push(<span class="built_in">stack</span>, temp);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:&#123;</span><br><span class="line">            p = top(<span class="built_in">stack</span>);</span><br><span class="line">            pop(<span class="built_in">stack</span>);</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>: &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            temp = getNewNode(str[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!empty(<span class="built_in">stack</span>) &amp;&amp; flag == <span class="number">0</span>) &#123;</span><br><span class="line">                top(<span class="built_in">stack</span>)-&gt;lchild = temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!empty(<span class="built_in">stack</span>) &amp;&amp; flag == <span class="number">1</span>) &#123;</span><br><span class="line">                top(<span class="built_in">stack</span>)-&gt;rchild = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            ++(*node_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line">    clear_stack(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">if</span> (temp &amp;&amp; !p) p = temp;<span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    pre_order_node(root-&gt;lchild);</span><br><span class="line">    pre_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pre_order : &quot;</span>);</span><br><span class="line">    pre_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    in_order_node(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    in_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in_order : &quot;</span>);</span><br><span class="line">    in_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    post_order_node(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    post_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;post_order : &quot;</span>);</span><br><span class="line">    post_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> node_num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, str);</span><br><span class="line">    Tree *tree = getNewTree();</span><br><span class="line">    tree-&gt;root = build(str, &amp;node_num);</span><br><span class="line">    tree-&gt;n = node_num;</span><br><span class="line">    pre_order(tree);</span><br><span class="line">    in_order(tree);</span><br><span class="line">    post_order(tree);</span><br><span class="line">    clear_tree(tree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A(B(,D),C(E,))</span><br><span class="line">pre_order : A B D C E</span><br><span class="line">in_order : B D A E C</span><br><span class="line">post_order : B D A E C</span><br></pre></td></tr></table></figure>




<h1 id="4-排序与查找"><a href="#4-排序与查找" class="headerlink" title="4.排序与查找"></a>4.排序与查找</h1><h2 id="4-1插入排序"><a href="#4-1插入排序" class="headerlink" title="4.1插入排序"></a>4.1插入排序</h2><h2 id="4-2冒泡排序"><a href="#4-2冒泡排序" class="headerlink" title="4.2冒泡排序"></a>4.2冒泡排序</h2><h2 id="4-3归并排序"><a href="#4-3归并排序" class="headerlink" title="4.3归并排序"></a>4.3归并排序</h2><h2 id="4-4稳定排序"><a href="#4-4稳定排序" class="headerlink" title="4.4稳定排序"></a>4.4稳定排序</h2><h2 id="4-5选择排序"><a href="#4-5选择排序" class="headerlink" title="4.5选择排序"></a>4.5选择排序</h2><h2 id="4-6快速排序"><a href="#4-6快速排序" class="headerlink" title="4.6快速排序"></a>4.6快速排序</h2><h2 id="4-7非稳定排序"><a href="#4-7非稳定排序" class="headerlink" title="4.7非稳定排序"></a>4.7非稳定排序</h2><h2 id="4-8快速排序的优化"><a href="#4-8快速排序的优化" class="headerlink" title="4.8快速排序的优化"></a>4.8快速排序的优化</h2><h2 id="4-9二分查找"><a href="#4-9二分查找" class="headerlink" title="4.9二分查找"></a>4.9二分查找</h2><h2 id="4-10三分查找"><a href="#4-10三分查找" class="headerlink" title="4.10三分查找"></a>4.10三分查找</h2><h2 id="4-11哈希表"><a href="#4-11哈希表" class="headerlink" title="4.11哈希表"></a>4.11哈希表</h2><p>数组的性质：数组是展开的函数，函数是压缩的数组</p>
<p>数组可以由下表索引到值，时间复杂度$O(1$)</p>
<blockquote>
<p>哈希表：将任意类型的元素映射成数组下标</p>
</blockquote>
<h3 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h3><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.37.54.png" alt="截屏2021-02-01 上午11.37.54"></p>
<p>通过哈希函数映射成数组下标</p>
<p>16 % 9 = 7</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.37.57.png" alt="截屏2021-02-01 上午11.37.57"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.37.59.png" alt="截屏2021-02-01 上午11.37.59"></p>
<p>7 % 9 = 7 发生冲突</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.38.01.png" alt="截屏2021-02-01 上午11.38.01"></p>
<h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><p>方法一：开放定值法：下一个位置是否有值，如果没有存放到下一个位置</p>
<p>方法二：再哈希：用第二种哈希方法处理</p>
<p>方法三：拉链法：值建立一个链表，所有的值都存放在链表中</p>
<p>方法四：建立公共溢出区</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.38.03.png" alt="截屏2021-02-01 上午11.38.03"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.38.05.png" alt="截屏2021-02-01 上午11.38.05"></p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//对字符串建立哈希表：BKDRHash</span></span><br><span class="line"><span class="comment">//冲突处理方法：拉链法</span></span><br><span class="line"><span class="comment">//结构定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;<span class="comment">//链表结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span><span class="comment">//哈希表结构定义</span></span><br><span class="line">    Node **data;<span class="comment">//存Node*</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">init_node</span><span class="params">(<span class="keyword">char</span> *str, Node *head)</span> </span>&#123;<span class="comment">//初始化结点,将str插入到以head为头结点的链表中,头插法,所有的新节点都会插入到头部</span></span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;str = strdup(str);<span class="comment">//符串拷贝</span></span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HashTable *<span class="title">init_hashtable</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//初始化哈希表，大小n</span></span><br><span class="line">    HashTable *h = (HashTable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    h-&gt;size = n &lt;&lt; <span class="number">1</span>;<span class="comment">//哈希表的利用率一定小于100%，一般为50%~90%</span></span><br><span class="line">    h-&gt;data = (Node **)<span class="built_in">calloc</span>(h-&gt;size, <span class="keyword">sizeof</span>(Node *));</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seed = <span class="number">31</span>;<span class="comment">//初始化映射种子</span></span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) hash = hash * seed + str[i];</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x7fffffff</span>;<span class="comment">//防止hash变成负数，将符号位变成正数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(HashTable *h, <span class="keyword">char</span> *str)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> hash = BKDRHash(str);<span class="comment">//将字符串映射成整型数组下表</span></span><br><span class="line">    <span class="keyword">int</span> ind = hash % h-&gt;size;</span><br><span class="line">    h-&gt;data[ind] = init_node(str, h-&gt;data[ind]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(HashTable *h, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = BKDRHash(str);</span><br><span class="line">    <span class="keyword">int</span> ind = hash % h-&gt;size;</span><br><span class="line">    Node *p = h-&gt;data[ind];</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; <span class="built_in">strcmp</span>(p-&gt;str, str)) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Node *p = node, *q;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p-&gt;str);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_hashtable</span><span class="params">(HashTable *h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h-&gt;size; i++) &#123;</span><br><span class="line">        clear_node(h-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(h-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(h);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_n 100</span></span><br><span class="line">    <span class="keyword">char</span> str[max_n + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    HashTable *h = init_hashtable(max_n + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;op, str)) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;insert %s to HashTable\n&quot;</span>, str);</span><br><span class="line">            insert(h, str);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;search %s fromm HashTable result = %d \n&quot;</span>, str, search(h, str));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_n</span></span><br><span class="line">    clear_hashtable(h);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 hello</span><br><span class="line">insert hello to HashTable</span><br><span class="line">0 haizei</span><br><span class="line">insert haizei to HashTable</span><br><span class="line">0 nihao</span><br><span class="line">insert nihao to HashTable</span><br><span class="line">1 haizei</span><br><span class="line">search haizei fromm HashTable result &#x3D; 1</span><br><span class="line">1 haizeix</span><br><span class="line">search haizeix fromm HashTable result &#x3D; 0</span><br><span class="line">1 nihao</span><br><span class="line">search nihao fromm HashTable result &#x3D; 1</span><br><span class="line">1 hello</span><br><span class="line">search hello fromm HashTable result &#x3D; 1</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
















































































<h1 id="5-堆与优先队列"><a href="#5-堆与优先队列" class="headerlink" title="5.堆与优先队列"></a>5.堆与优先队列</h1><h2 id="5-1完全二叉树"><a href="#5-1完全二叉树" class="headerlink" title="5.1完全二叉树"></a>5.1完全二叉树</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.20.png" alt="截屏2021-01-31 下午9.36.20"></p>
<p>完全二叉树:每一层都是满的，只有在最后一层不是满的</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.23.png" alt="截屏2021-01-31 下午9.36.23"></p>
<p>二叉树可以用数组存储</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.29.png" alt="截屏2021-01-31 下午9.36.29"></p>
<h2 id="5-2堆"><a href="#5-2堆" class="headerlink" title="5.2堆"></a>5.2堆</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.31.png" alt="截屏2021-01-31 下午9.36.31"></p>
<h2 id="5-3堆尾部插入"><a href="#5-3堆尾部插入" class="headerlink" title="5.3堆尾部插入"></a>5.3堆尾部插入</h2><p>自下向上调整</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.35.png" alt="截屏2021-01-31 下午9.36.35"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.37.png" alt="截屏2021-01-31 下午9.36.37"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.38.png"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.40.png" alt="截屏2021-01-31 下午9.36.40"></p>
<h2 id="5-4堆头部弹出-删除元素"><a href="#5-4堆头部弹出-删除元素" class="headerlink" title="5.4堆头部弹出/删除元素"></a>5.4堆头部弹出/删除元素</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.42.png" alt="截屏2021-01-31 下午9.36.42"></p>
<p>取出最后一个元素当做头部元素</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.44.png" alt="截屏2021-01-31 下午9.36.44"></p>
<p>维护堆性质</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.45.png" alt="截屏2021-01-31 下午9.36.45"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.47.png" alt="截屏2021-01-31 下午9.36.47"></p>
<h2 id="5-5堆排序"><a href="#5-5堆排序" class="headerlink" title="5.5堆排序"></a>5.5堆排序</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.48.png" alt="截屏2021-01-31 下午9.36.48"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.50.png" alt="截屏2021-01-31 下午9.36.50"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.52.png" alt="截屏2021-01-31 下午9.36.52"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.53.png" alt="截屏2021-01-31 下午9.36.53"></p>
<h2 id="5-6堆-优先队列"><a href="#5-6堆-优先队列" class="headerlink" title="5.6堆/优先队列"></a>5.6堆/优先队列</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.55.png" alt="截屏2021-01-31 下午9.36.55"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.56.png" alt="截屏2021-01-31 下午9.36.56"></p>
<h2 id="5-7优先队列代码实现"><a href="#5-7优先队列代码实现" class="headerlink" title="5.7优先队列代码实现"></a>5.7优先队列代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b, b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">priority_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> cnt, size;<span class="comment">//记录当前元素个数、全部元素数量</span></span><br><span class="line">&#125; <span class="built_in">priority_queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">priority_queue</span> *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span> *q = (<span class="built_in">priority_queue</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">priority_queue</span>));</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));<span class="comment">//下标从1开始</span></span><br><span class="line">    q-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    q-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;cnt == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;<span class="comment">//输出队首元素</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="built_in">priority_queue</span> *q, <span class="keyword">int</span> val )</span> </span>&#123; <span class="comment">//插入元素val</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//优先队列不存在</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;cnt == q-&gt;size) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//优先队列满了，不能插入</span></span><br><span class="line">    <span class="comment">//q-&gt;cnt++;</span></span><br><span class="line">    q-&gt;data[++q-&gt;cnt] = val;</span><br><span class="line">    <span class="comment">//优先队列调整，自下向上</span></span><br><span class="line">    <span class="keyword">int</span> ind = q-&gt;cnt;</span><br><span class="line">    <span class="keyword">while</span> (ind &gt;&gt; <span class="number">1</span> &amp;&amp; q-&gt;data[ind] &gt; q-&gt;data[ind &gt;&gt; <span class="number">1</span>]) &#123;<span class="comment">//当当前节点有父节点，且当前节点&gt;父节点的值(大顶堆)</span></span><br><span class="line">        swap(q-&gt;data[ind], q-&gt;data[ind &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">        ind &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="built_in">priority_queue</span> * q)</span> </span>&#123;<span class="comment">//头部弹出,堆顶弹出且调整</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//优先队列不存在</span></span><br><span class="line">    <span class="keyword">if</span> (empty(q)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//优先队列为空</span></span><br><span class="line">    q-&gt;data[<span class="number">1</span>] = q-&gt;data[q-&gt;cnt--];<span class="comment">//取优先队列的最后一个元素赋值给头部，头部弹出</span></span><br><span class="line">    <span class="comment">//q-&gt;cnt--;</span></span><br><span class="line">    <span class="comment">//维护优先队列，自顶向下</span></span><br><span class="line">    <span class="keyword">int</span> ind = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ind &lt;&lt; <span class="number">1</span>) &lt;= q-&gt;cnt) &#123;<span class="comment">//当前优先队列还有子节点</span></span><br><span class="line">        <span class="keyword">int</span> temp = ind, l = ind &lt;&lt; <span class="number">1</span>, r = ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;<span class="comment">// r = ind * 2 + 1</span></span><br><span class="line">        <span class="keyword">if</span> (q-&gt;data[l] &gt; q-&gt;data[temp]) temp = l;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= q-&gt;cnt &amp;&amp; q-&gt;data[r] &gt; q-&gt;data[temp]) temp = r;<span class="comment">//不一定有右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (temp == ind) <span class="keyword">break</span>;<span class="comment">//当前节点就是三元组中最大的</span></span><br><span class="line">        swap(q-&gt;data[ind], q-&gt;data[temp]);</span><br><span class="line">        ind = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="built_in">priority_queue</span> * q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    <span class="built_in">priority_queue</span> *q = init(max_op);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        push(q, val);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;insert %d to the priority_queue !\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, top(q));</span><br><span class="line">        pop(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> man_op</span></span><br><span class="line">    clear(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insert 9 to the priority_queue !</span><br><span class="line">insert 33 to the priority_queue !</span><br><span class="line">insert 31 to the priority_queue !</span><br><span class="line">insert 51 to the priority_queue !</span><br><span class="line">insert 86 to the priority_queue !</span><br><span class="line">insert 36 to the priority_queue !</span><br><span class="line">insert 68 to the priority_queue !</span><br><span class="line">insert 46 to the priority_queue !</span><br><span class="line">insert 65 to the priority_queue !</span><br><span class="line">insert 32 to the priority_queue !</span><br><span class="line">insert 64 to the priority_queue !</span><br><span class="line">insert 9 to the priority_queue !</span><br><span class="line">insert 42 to the priority_queue !</span><br><span class="line">insert 64 to the priority_queue !</span><br><span class="line">insert 28 to the priority_queue !</span><br><span class="line">insert 77 to the priority_queue !</span><br><span class="line">insert 48 to the priority_queue !</span><br><span class="line">insert 66 to the priority_queue !</span><br><span class="line">insert 27 to the priority_queue !</span><br><span class="line">insert 5 to the priority_queue !</span><br><span class="line">86 77 68 66 65 64 64 51 48 46 42 36 33 32 31 28 27 9 9 5</span><br><span class="line">//弹出元素从大到小</span><br></pre></td></tr></table></figure>














<h1 id="6-森林与并查集"><a href="#6-森林与并查集" class="headerlink" title="6.森林与并查集"></a>6.森林与并查集</h1><hr>
]]></content>
      <categories>
        <category>基础数据结构</category>
      </categories>
      <tags>
        <tag>基础数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>习题答疑</title>
    <url>/2020/12/29/07.%E4%B9%A0%E9%A2%98%E7%AD%94%E7%96%91/</url>
    <content><![CDATA[<h1 id="9-课程答疑-一"><a href="#9-课程答疑-一" class="headerlink" title="9.课程答疑(一)"></a>9.课程答疑(一)</h1><h2 id="1-逆波兰式"><a href="#1-逆波兰式" class="headerlink" title="1.逆波兰式"></a>1.逆波兰式</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8A%E5%8D%8811.29.22.png" alt="截屏2021-01-31 上午11.29.22"></p>
<ol>
<li><p>表达式树，最有价值的是当成思维逻辑结构中的数据结构</p>
</li>
<li><p>表达式求值程序，本质上就是对表达式树的递归遍历</p>
</li>
<li><p>重点观察表达式树的特性：根节点是整个表达式中优先级最低的运算符，也就是最后一个被计算的运算符</p>
</li>
</ol>
<p>   <strong>表达式求解程序</strong></p>
<ol>
<li><strong>Step1：</strong>找到表达式中优先级最低的运算符的位置</li>
<li><strong>Step2：</strong>递归计算运算符左右两侧表达式的值</li>
<li><strong>Step3：</strong>根据当前运算符获得运算结果</li>
</ol>
<p>   <strong>输出逆波兰式</strong></p>
<ol>
<li>表达式求解程序，本质上是对表达树的遍历</li>
<li>所以，采用后序遍历的方式，输出逆波兰式的结果</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>, pri = INF - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = INF;</span><br><span class="line">        <span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: cur = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: cur = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur &lt;= pri) &#123;</span><br><span class="line">            pos = i, pri = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;<span class="comment">//表达式中已经没有运算符,全部都是数字</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pos点为优先级最低点，分别计算左右子树的值</span></span><br><span class="line">    <span class="keyword">int</span> a = calc(str, l, pos - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> b = calc(str, pos + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">switch</span> (str[pos]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> : <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> : <span class="keyword">return</span> a - b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> : <span class="keyword">return</span> a * b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> : <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, calc(str, <span class="number">0</span>, <span class="built_in">strlen</span>(str) - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>, pri = INF - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>  temp = <span class="number">0</span>;<span class="comment">//带括号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = INF;</span><br><span class="line">        <span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: temp += <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: temp -= <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: cur = temp + <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: cur = temp + <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: cur = temp + <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur &lt;= pri) &#123;</span><br><span class="line">            pos = i, pri = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;<span class="comment">//表达式中已经没有运算符,全部都是数字</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pos点为优先级最低点，分别计算左右子树的值</span></span><br><span class="line">    <span class="keyword">int</span> a = calc(str, l, pos - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> b = calc(str, pos + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">switch</span> (str[pos]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> : <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> : <span class="keyword">return</span> a - b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> : <span class="keyword">return</span> a * b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> : <span class="keyword">return</span> a / b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span> : <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">pow</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, str)) &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, str, calc(str, <span class="number">0</span>, <span class="built_in">strlen</span>(str) - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(3 + 5) * (10 + 40) &#x3D; 400</span><br><span class="line">(2 + 3)^2 &#x3D; 25</span><br></pre></td></tr></table></figure>


<p>带^和()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>, pri = INF - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>  temp = <span class="number">0</span>;<span class="comment">//带括号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = INF;</span><br><span class="line">        <span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: temp += <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: temp -= <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: cur = temp + <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: cur = temp + <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: cur = temp + <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur &lt;= pri) &#123;</span><br><span class="line">            pos = i, pri = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;<span class="comment">//表达式中已经没有运算符,全部都是数字</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pos点为优先级最低点，分别计算左右子树的值</span></span><br><span class="line">    <span class="keyword">int</span> a = calc(str, l, pos - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> b = calc(str, pos + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %c&quot;</span>, str[pos]);</span><br><span class="line">    <span class="keyword">switch</span> (str[pos]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> : <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> : <span class="keyword">return</span> a - b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> : <span class="keyword">return</span> a * b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> : <span class="keyword">return</span> a / b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span> : <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">pow</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, str)) &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">int</span> val = calc(str, <span class="number">0</span>, <span class="built_in">strlen</span>(str) - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, str, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 5 + 10 40 + *</span><br><span class="line">(3 + 5) * (10 + 40) &#x3D; 400</span><br><span class="line">2 3 + 2 ^</span><br><span class="line">(2 + 3)^2 &#x3D; 25</span><br></pre></td></tr></table></figure>




<h2 id="2-根据三元组数列建立二叉链表"><a href="#2-根据三元组数列建立二叉链表" class="headerlink" title="2.根据三元组数列建立二叉链表"></a>2.根据三元组数列建立二叉链表</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%884.42.10.png" alt="截屏2021-01-31 下午4.42.10"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%884.42.21.png" alt="截屏2021-01-31 下午4.42.10"></p>
<ol>
<li>本质就是一个模拟题</li>
<li>模拟题的学习重点，就是学习各种各样的模拟技巧，以及对应的编码技巧</li>
<li><strong>技巧1：</strong>用一个数组，记录字符所对应的节点地址</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node *arr[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;ch = ch;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;ch);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        output(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str)) &#123;<span class="comment">//读入三元组</span></span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;^&#x27;</span> &amp;&amp; str[<span class="number">1</span>] == <span class="string">&#x27;^&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//已经读入到结尾</span></span><br><span class="line">        p = getNewNode(str[<span class="number">1</span>]);<span class="comment">//当前节点</span></span><br><span class="line">        arr[str[<span class="number">1</span>] - <span class="string">&#x27;A&#x27;</span>] = p;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;^&#x27;</span>) &#123;</span><br><span class="line">            root = p;<span class="comment">//根节点</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断第三个字母</span></span><br><span class="line">        <span class="keyword">switch</span> (str[<span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: arr[str[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>]-&gt;lchild = p; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: arr[str[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>]-&gt;rchild = p; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    output(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h2 id="3-植物大战僵尸"><a href="#3-植物大战僵尸" class="headerlink" title="3.植物大战僵尸"></a>3.植物大战僵尸</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%885.07.05.png" alt="截屏2021-01-31 下午5.07.05"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%885.07.23.png" alt="s"></p>
<ol>
<li><strong>题目建模：</strong>每一轮，找到一个集合中的最大值，并且删掉这个最大值。所以，尝试用堆解决。</li>
<li><strong>题目难点：</strong>僵尸之间的相对顺序，时刻发生改变，而堆中，数据是不变的。</li>
<li><strong>问题简化：</strong>如果僵尸之间的相对顺序不变，这道题目，就可以用堆求解，甚至是简单的排序即可。</li>
<li><strong>发现突破口：</strong>当两个僵尸速度相同时，两个僵尸之间的相对位置就不会发生改变。</li>
<li>题目中，速度都是整数，且在1到100之间，也就是说，最多存在 100 种速度。</li>
<li>根据速度，建立 100 个堆，将速度相同的僵尸，塞到一个堆中</li>
<li>每一轮，在100个堆顶元素中，找到一个跑在最前面的僵尸，干掉即可</li>
</ol>
<p><strong>Bug-1：</strong>没有严格按照题目要求实现程序，没有考虑到位置相同的情况。</p>
<p><strong>Bug-2：</strong>写程序中的小笔误，在堆的 pop 操作中，参与比较的两个元素的下标错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) c = a;\</span><br><span class="line">    a = b, b = c;\</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, f, s;<span class="comment">//n代表编号，总数量,有n个僵尸,第一秒的速度为f,之后的速度为s</span></span><br><span class="line">&#125; Data;</span><br><span class="line"></span><br><span class="line">Data heap[<span class="number">101</span>][MAX_N + <span class="number">5</span>];<span class="comment">//堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gt</span><span class="params">(Data a, Data b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.f - b.f) <span class="keyword">return</span> a.f &gt; b.f;</span><br><span class="line">    <span class="keyword">return</span> a.n &lt; b.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Data *h, Data val)</span> </span>&#123;</span><br><span class="line">    h[++h[<span class="number">0</span>].n] = val;</span><br><span class="line">    <span class="keyword">int</span> ind = h[<span class="number">0</span>].n;</span><br><span class="line">    <span class="keyword">while</span> (ind / <span class="number">2</span> &amp;&amp; gt(h[ind], h[ind / <span class="number">2</span>])) &#123;</span><br><span class="line">        swap(h[ind], h[ind / <span class="number">2</span>]);</span><br><span class="line">        ind /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(Data *h)</span> </span>&#123;</span><br><span class="line">    swap(h[<span class="number">1</span>], h[h[<span class="number">0</span>].n]);</span><br><span class="line">    h[<span class="number">0</span>].n -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ind = <span class="number">1</span>, temp;</span><br><span class="line">    <span class="keyword">while</span> (ind * <span class="number">2</span> &lt;= h[<span class="number">0</span>].n) &#123;</span><br><span class="line">        temp = ind;</span><br><span class="line">        <span class="keyword">if</span> (gt(h[ind * <span class="number">2</span>], h[temp])) temp = ind * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (ind * <span class="number">2</span> + <span class="number">1</span> &lt;= h[<span class="number">0</span>].n &amp;&amp; gt(h[ind * <span class="number">2</span> + <span class="number">1</span>], h[temp])) temp = ind * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp == ind) <span class="keyword">break</span>;<span class="comment">//向下调整到了合适的位置</span></span><br><span class="line">        swap(h[temp], h[ind]);</span><br><span class="line">        ind =  temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Data *h)</span> </span>&#123; <span class="keyword">return</span> h[<span class="number">0</span>].n == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function">Data <span class="title">top</span><span class="params">(Data *h)</span> </span>&#123; <span class="keyword">return</span> h[<span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Data *h)</span> </span>&#123; h[<span class="number">0</span>].n = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_heap</span><span class="params">()</span> </span>&#123;<span class="comment">//清空堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) clear(heap[i]);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init_heap();</span><br><span class="line">    <span class="keyword">int</span> n, f, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;f, &amp;s);</span><br><span class="line">        Data d = &#123;i, f, s&#125;;</span><br><span class="line">        push(heap[s], d);<span class="comment">//插入堆中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//干掉n个僵尸</span></span><br><span class="line">        <span class="keyword">int</span> ind = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++) &#123;<span class="comment">//找到跑在最前面的僵尸</span></span><br><span class="line">            <span class="keyword">if</span> (empty(heap[j])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cur_pos = (i - <span class="number">1</span>) * j + top(heap[j]).f;</span><br><span class="line">            <span class="keyword">if</span> (ind == <span class="number">0</span>) &#123;</span><br><span class="line">                ind = j, pos = cur_pos;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; cur_pos || (pos == cur_pos &amp;&amp; top(heap[j]).n &lt; top(heap[ind]).n)) &#123;</span><br><span class="line">                ind = j, pos = cur_pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d %d %d\n&quot;, top(heap[ind]).n, top(heap[ind]).f, ind, pos);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, top(heap[ind]).n);<span class="comment">//干掉僵尸</span></span><br><span class="line">        pop(heap[ind]);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tcase, n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tcase);</span><br><span class="line">    <span class="keyword">while</span> ((n++) &lt; tcase) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>, n);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="10-课程答疑-二-1"><a href="#10-课程答疑-二-1" class="headerlink" title="10.课程答疑(二)1"></a>10.课程答疑(二)1</h1><h2 id="一、预习资料-【数据结构】-最短路简化"><a href="#一、预习资料-【数据结构】-最短路简化" class="headerlink" title="一、预习资料-【数据结构】-最短路简化"></a>一、预习资料-【数据结构】-最短路简化</h2><ol>
<li>广搜裸题</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAX_N 1000</span><br><span class="line">int g[MAX_N + 5][MAX_N + 5];</span><br><span class="line">inline void add(int a, int b) &#123;</span><br><span class="line">    g[a][++g[a][0]] &#x3D; b;</span><br><span class="line">    g[b][++g[b][0]] &#x3D; a;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int ans[MAX_N + 5];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m, c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">    for (int i &#x3D; 0, a, b; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    ans[c] &#x3D; 1;</span><br><span class="line">    q.push(c);</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        int ind &#x3D; q.front();</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; g[ind][0]; i++) &#123;</span><br><span class="line">            int to &#x3D; g[ind][i];</span><br><span class="line">            if (ans[to]) continue;</span><br><span class="line">            ans[to] &#x3D; ans[ind] + 1;</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] - 1 &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="二、预习资料-【数据结构】-游戏分组"><a href="#二、预习资料-【数据结构】-游戏分组" class="headerlink" title="二、预习资料-【数据结构】-游戏分组"></a>二、预习资料-【数据结构】-游戏分组</h2><ol>
<li>并查集裸题</li>
<li>并查集的简化实现方式</li>
<li><strong>路径压缩：</strong>代码实现短，优化效果明显</li>
<li><strong>按秩优化：</strong>代码实现稍复杂，对于随机数据的优化效果一般，还需要占用额外的存储空间</li>
<li>在快速编码的场景中，只需要实现路径压缩即可</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAX_N 1000000</span><br><span class="line">int fa[MAX_N + 5];</span><br><span class="line">int get(int x) &#123;</span><br><span class="line">    return fa[x] &#x3D; (x &#x3D;&#x3D; fa[x] ? x : get(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line">void merge(int a, int b) &#123;</span><br><span class="line">    fa[get(a)] &#x3D; get(b);</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) fa[i] &#x3D; i;</span><br><span class="line">    for (int i &#x3D; 0, a, b; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        merge(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        ans +&#x3D; (fa[i] &#x3D;&#x3D; i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="三、预习资料-【数据结构】-字符串旋转矩阵"><a href="#三、预习资料-【数据结构】-字符串旋转矩阵" class="headerlink" title="三、预习资料-【数据结构】-字符串旋转矩阵"></a>三、预习资料-【数据结构】-字符串旋转矩阵</h2><ol>
<li>首要解决的问题：还原原字符串</li>
<li><strong>Step1：</strong>通过最后一列的字符，确定相应的第一列的字符</li>
<li><strong>Step2：</strong>得出结论，相同字符的相对顺序在第一列和最后一列中相同</li>
<li><strong>Step3：</strong>确定了每一个字符的编号，以及编号与编号之间的前后关系，即可还原原字符串</li>
<li>由于反复标记 fail 指针链上的状态，导致时间超限，在这里有一个特殊的程序优化</li>
</ol>
<p><img src="../guanghu/Library/Application%2520Support/typora-user-images/image-20210124215823630.png" alt="image-20210124215823630"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAX_N 110000</span><br><span class="line">char t[MAX_N + 5], s[MAX_N + 5];</span><br><span class="line">int ind[MAX_N + 5], *ans[MAX_N + 5];</span><br><span class="line"></span><br><span class="line">bool cmp(int i, int j) &#123;</span><br><span class="line">    if (t[i] - t[j]) return t[i] &lt; t[j];</span><br><span class="line">    return i &lt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void convert(char *t, char *s) &#123;</span><br><span class="line">    int n &#x3D; 0;</span><br><span class="line">    for (n &#x3D; 0; t[n]; n++) ind[n] &#x3D; n;</span><br><span class="line">    sort(ind, ind + n, cmp);</span><br><span class="line">    for (int i &#x3D; 0, p &#x3D; ind[0]; i &lt; n; i++, p &#x3D; ind[p]) &#123;</span><br><span class="line">        s[i] &#x3D; t[p];</span><br><span class="line">    &#125;</span><br><span class="line">    s[n] &#x3D; 0;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">    int flag, *ans;</span><br><span class="line">    int next[26], fail;</span><br><span class="line">&#125; tree[2000005];</span><br><span class="line">int que[2000005], head, tail;</span><br><span class="line">int root &#x3D; 1, cnt &#x3D; 2;</span><br><span class="line">inline int getNewNode() &#123; return cnt++; &#125;</span><br><span class="line">int *insert(char *s) &#123;</span><br><span class="line">    int p &#x3D; root;</span><br><span class="line">    for (int i &#x3D; 0; s[i]; i++) &#123;</span><br><span class="line">        int ind &#x3D; s[i] - &#39;a&#39;;</span><br><span class="line">        if (tree[p].next[ind] &#x3D;&#x3D; 0) tree[p].next[ind] &#x3D; getNewNode();</span><br><span class="line">        p &#x3D; tree[p].next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    tree[p].flag &#x3D; 1;</span><br><span class="line">    if (tree[p].ans &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        tree[p].ans &#x3D; new int(0);</span><br><span class="line">    &#125;</span><br><span class="line">    return tree[p].ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build() &#123;</span><br><span class="line">    head &#x3D; tail &#x3D; 0;</span><br><span class="line">    tree[root].fail &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 26; i++) &#123;</span><br><span class="line">        if (tree[root].next[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            tree[root].next[i] &#x3D; root;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[tree[root].next[i]].fail &#x3D; root;</span><br><span class="line">        que[tail++] &#x3D; tree[root].next[i];</span><br><span class="line">    &#125;</span><br><span class="line">    while (head &lt; tail) &#123;</span><br><span class="line">        int p &#x3D; que[head++];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 26; i++) &#123;</span><br><span class="line">            int c &#x3D; tree[p].next[i], k &#x3D; tree[p].fail;</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                tree[p].next[i] &#x3D; tree[k].next[i];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            tree[c].fail &#x3D; tree[k].next[i];</span><br><span class="line">            que[tail++] &#x3D; c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void match(char *s) &#123;</span><br><span class="line">    for (int i &#x3D; 0, p &#x3D; tree[root].next[s[0] - &#39;a&#39;], q, k; s[i]; i++, p &#x3D; tree[p].next[s[i] - &#39;a&#39;]) &#123;</span><br><span class="line">        q &#x3D; p;</span><br><span class="line">        while (q) &#123;</span><br><span class="line">            if (tree[q].flag) &#123;</span><br><span class="line">                *tree[q].ans +&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            k &#x3D; q;</span><br><span class="line">            q &#x3D; tree[q].fail;</span><br><span class="line">            tree[k].fail &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    cnt &#x3D; 2;</span><br><span class="line">    memset(tree, 0, sizeof(tree));</span><br><span class="line">    memset(ans, 0, sizeof(ans));</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int solve(char *t) &#123;</span><br><span class="line">    init();</span><br><span class="line">    convert(t, s);</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        ans[i] &#x3D; insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">    build();</span><br><span class="line">    match(s + 1);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; (ans[i][0] ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    while (cin &gt;&gt; t) solve(t);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="四、预习资料-【数据结构】-灌溉"><a href="#四、预习资料-【数据结构】-灌溉" class="headerlink" title="四、预习资料-【数据结构】-灌溉"></a>四、预习资料-【数据结构】-灌溉</h2><h3 id="最小生成树问题-Kruskal-算法"><a href="#最小生成树问题-Kruskal-算法" class="headerlink" title="最小生成树问题-Kruskal 算法"></a>最小生成树问题-Kruskal 算法</h3><ol>
<li>Step1：对于所有边从小到大排序</li>
<li>Step2：依次取出每一条边，试着加入图中，边上的两个点不联通的情况下，才将边加入图中</li>
</ol>
<p>除了学习一个新算法以外，这道题目，一无是处。</p>
<p><img src="../guanghu/Library/Application%2520Support/typora-user-images/image-20210124215840760.png" alt="image-20210124215840760"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAX_N 10000</span><br><span class="line">struct Edge &#123;</span><br><span class="line">    int v, u, c;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; e;</span><br><span class="line"></span><br><span class="line">bool cmp(const Edge &amp;a, const Edge &amp;b) &#123;</span><br><span class="line">    return a.c &lt; b.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fa[MAX_N + 5];</span><br><span class="line">int get(int x) &#123;</span><br><span class="line">    return fa[x] &#x3D; (x - fa[x] ? get(fa[x]) : x);</span><br><span class="line">&#125;</span><br><span class="line">void merge(int a, int b) &#123;</span><br><span class="line">    fa[get(a)] &#x3D; get(b);</span><br><span class="line">&#125;</span><br><span class="line">void init(int n) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n; i++) fa[i] &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i &#x3D; 1, a; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            if (i &lt; j) e.push_back(&#123;i, j, a&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e.begin(), e.end(), cmp);</span><br><span class="line">    init(n);</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; e.size(); i++) &#123;</span><br><span class="line">        int v &#x3D; e[i].v, u &#x3D; e[i].u, c &#x3D; e[i].c;</span><br><span class="line">        if (get(v) &#x3D;&#x3D; get(u)) continue;</span><br><span class="line">        merge(v, u);</span><br><span class="line">        ans +&#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="五、Leetcode-05-最长回文子串"><a href="#五、Leetcode-05-最长回文子串" class="headerlink" title="五、Leetcode-05-最长回文子串"></a>五、Leetcode-05-最长回文子串</h2><h3 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h3><ol>
<li>Step1：对原字符串进行特殊处理，在每两个字符中间加入 # 字符</li>
<li>Step2：依次求解每一个位置的最大回文半径</li>
<li>在求解过程中，记录一个 c 点，$c+r[c]$ 最大</li>
<li>求回文半径时：要不然借助原有信息，要不然就是暴力匹配，暴力匹配过程，均摊时间复杂度 O(1)</li>
<li><strong>时间复杂度：</strong>O(n)</li>
</ol>
<p><img src="../guanghu/Library/Application%2520Support/typora-user-images/image-20210124215852853.png" alt="image-20210124215852853"></p>
<p><img src="../guanghu/Library/Application%2520Support/typora-user-images/image-20210124215900772.png" alt="image-20210124215900772"></p>
<p><img src="../guanghu/Library/Application%2520Support/typora-user-images/image-20210124215910516.png" alt="image-20210124215910516"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string get_new_string(string &amp;s) &#123;</span><br><span class="line">        string ns &#x3D; &quot;#&quot;;</span><br><span class="line">        for (int i &#x3D; 0; s[i]; i++) &#123;</span><br><span class="line">            (ns +&#x3D; s[i]) +&#x3D; &quot;#&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ns;</span><br><span class="line">    &#125;</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        string ns &#x3D; get_new_string(s);</span><br><span class="line">        int *r &#x3D; new int[ns.size()], c;</span><br><span class="line">        r[0] &#x3D; 1, c &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; ns.size(); i++) &#123;</span><br><span class="line">            if (i &gt;&#x3D; c + r[c]) &#123;</span><br><span class="line">                r[i] &#x3D; 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r[i] &#x3D; min(c + r[c] - i, r[2 * c - i]);</span><br><span class="line">            &#125;</span><br><span class="line">            while (i - r[i] &gt;&#x3D; 0 &amp;&amp; ns[i - r[i]] &#x3D;&#x3D; ns[i + r[i]]) r[i] +&#x3D; 1;</span><br><span class="line">            if (i + r[i] &gt; c + r[c]) c &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        string ret &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; ns[i]; i++) &#123;</span><br><span class="line">            if (r[i] &lt;&#x3D; ans) continue;</span><br><span class="line">            ans &#x3D; r[i];</span><br><span class="line">            ret &#x3D; &quot;&quot;;</span><br><span class="line">            for (int j &#x3D; i - r[i] + 1; j &lt; i + r[i]; j++) &#123;</span><br><span class="line">                if (ns[j] &#x3D;&#x3D; &#39;#&#39;) continue;</span><br><span class="line">                ret +&#x3D; ns[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solv;</span><br><span class="line">    string s;</span><br><span class="line">    while (cin &gt;&gt; s) &#123;</span><br><span class="line">        cout &lt;&lt; solv.longestPalindrome(s) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="11-课程答疑-三"><a href="#11-课程答疑-三" class="headerlink" title="11.课程答疑(三)"></a>11.课程答疑(三)</h1><h2 id="一、【中等】leetcode-146-LRU缓存机制"><a href="#一、【中等】leetcode-146-LRU缓存机制" class="headerlink" title="一、【中等】leetcode-146-LRU缓存机制"></a>一、【中等】leetcode-146-LRU缓存机制</h2><p><a href="https://leetcode-cn.com/problems/lru-cache/">leetcode-146-LRU缓存机制</a></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.20.38.png" alt="截屏2021-02-01 上午11.20.38"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.20.47.png" alt="截屏2021-02-01 上午11.20.47"></p>
<ol>
<li>哈希表 + 链表解决 $O(1)$ 读取，以及 $O(1)$ 修改缓存数据节点位置的操作</li>
<li><strong>弯路1：</strong>一开始想到了哈希表，但忽略了利用链表实现 $O(1)$ 修改</li>
<li><strong>弯路2：</strong>由于头尾指针会发生变化，忽略了虚拟节点的处理技巧</li>
</ol>
<p>代码演示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">public:</span><br><span class="line">    class Node &#123;</span><br><span class="line">    public :</span><br><span class="line">        Node() : Node(0, 0) &#123;&#125;</span><br><span class="line">        Node(int key, int value) : pre(nullptr), next(nullptr), key(key), value(value) &#123;&#125;</span><br><span class="line">        Node *pre, *next;</span><br><span class="line">        int key, value;</span><br><span class="line">    &#125;;</span><br><span class="line">    int capacity, node_cnt;</span><br><span class="line">    unordered_map&lt;int, Node *&gt; ind;</span><br><span class="line">    Node head, tail;</span><br><span class="line">    LRUCache(int capacity) &#123;</span><br><span class="line">        this-&gt;capacity &#x3D; capacity;</span><br><span class="line">        this-&gt;node_cnt &#x3D; 0;</span><br><span class="line">        head.next &#x3D; &amp;tail;</span><br><span class="line">        tail.pre &#x3D; &amp;head;</span><br><span class="line">    &#125;</span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if (ind.find(key) &#x3D;&#x3D; ind.end()) return -1;</span><br><span class="line">        Node *p &#x3D; ind[key];</span><br><span class="line">        remove_node(p);</span><br><span class="line">        insert_tail(p);</span><br><span class="line">        return p-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    void output() &#123;</span><br><span class="line">        Node *p &#x3D; head.next;</span><br><span class="line">        while (p) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;(&quot; &lt;&lt; p-&gt;key &lt;&lt; &quot;, &quot; &lt;&lt; p-&gt;value &lt;&lt; &quot;)-&gt;&quot;;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    void remove_node(Node *p) &#123;</span><br><span class="line">        p-&gt;next-&gt;pre &#x3D; p-&gt;pre;</span><br><span class="line">        p-&gt;pre-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    void insert_tail(Node *p) &#123;</span><br><span class="line">        p-&gt;next &#x3D; &amp;tail;</span><br><span class="line">        p-&gt;pre &#x3D; tail.pre;</span><br><span class="line">        tail.pre &#x3D; p;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        Node *p;</span><br><span class="line">        if (ind.find(key) &#x3D;&#x3D; ind.end()) &#123;</span><br><span class="line">            p &#x3D; new Node(key, value);</span><br><span class="line">            node_cnt +&#x3D; 1;</span><br><span class="line">            insert_tail(p);</span><br><span class="line">            ind[key] &#x3D; p;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        if (node_cnt &gt; capacity) &#123;</span><br><span class="line">            p &#x3D; head.next;</span><br><span class="line">            remove_node(p);</span><br><span class="line">            delete p;</span><br><span class="line">            node_cnt -&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="line"> * LRUCache* obj &#x3D; new LRUCache(capacity);</span><br><span class="line"> * int param_1 &#x3D; obj-&gt;get(key);</span><br><span class="line"> * obj-&gt;put(key,value);</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="二、【困难】Leetcode-460-LFU缓存"><a href="#二、【困难】Leetcode-460-LFU缓存" class="headerlink" title="二、【困难】Leetcode-460-LFU缓存"></a>二、【困难】Leetcode-460-LFU缓存</h2><ol>
<li>编码较复杂，基于十字链表实现 LFU 缓存机制</li>
<li>将出现次数相同的节点，存储在同一个 LRUCache 中</li>
<li>将所有非空的 LRUCache ，按照代表的次数，链接成一个大链表</li>
<li>删除节点的操作，简化成了：删除第一个 LRUCache 中的头结点</li>
<li><strong>操作1：</strong>删除一个节点</li>
<li><strong>操作2：</strong>新增一个节点</li>
<li><strong>操作3：</strong>将一个现有节点，移动到下一个 LRUCache 中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">public :</span><br><span class="line">    Node() : Node(0, 0) &#123;&#125;</span><br><span class="line">    Node(int key, int value) </span><br><span class="line">    : pre(nullptr), next(nullptr), </span><br><span class="line">    key(key), value(value), cnt(0) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node *pre, *next;</span><br><span class="line">    int key, value, cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">public:</span><br><span class="line">    int node_cnt;</span><br><span class="line">    Node head, tail;</span><br><span class="line">    LRUCache *pre, *next;</span><br><span class="line">    LRUCache() : pre(nullptr), next(nullptr) &#123;</span><br><span class="line">        this-&gt;node_cnt &#x3D; 0;</span><br><span class="line">        head.next &#x3D; &amp;tail;</span><br><span class="line">        tail.pre &#x3D; &amp;head;</span><br><span class="line">    &#125;</span><br><span class="line">    void output() &#123;</span><br><span class="line">        return ;</span><br><span class="line">        Node *p &#x3D; head.next;</span><br><span class="line">        while (p) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;(&quot; &lt;&lt; p-&gt;key &lt;&lt; &quot;, &quot; &lt;&lt; p-&gt;value &lt;&lt; &quot;)-&gt;&quot;;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        p &#x3D; tail.pre;</span><br><span class="line">        while (p) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;(&quot; &lt;&lt; p-&gt;key &lt;&lt; &quot;, &quot; &lt;&lt; p-&gt;value &lt;&lt; &quot;)-&gt;&quot;;</span><br><span class="line">            p &#x3D; p-&gt;pre;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    void remove_node(Node *p) &#123;</span><br><span class="line">        p-&gt;next-&gt;pre &#x3D; p-&gt;pre;</span><br><span class="line">        p-&gt;pre-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">        node_cnt -&#x3D; 1;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    void insert_tail(Node *p) &#123;</span><br><span class="line">        p-&gt;next &#x3D; &amp;tail;</span><br><span class="line">        p-&gt;pre &#x3D; tail.pre;</span><br><span class="line">        tail.pre-&gt;next &#x3D; p;</span><br><span class="line">        tail.pre &#x3D; p;</span><br><span class="line">        node_cnt +&#x3D; 1;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    void put(Node *p) &#123;</span><br><span class="line">        insert_tail(p);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *pop() &#123;</span><br><span class="line">        Node *p &#x3D; head.next;</span><br><span class="line">        head.next &#x3D; p-&gt;next;</span><br><span class="line">        node_cnt -&#x3D; 1;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LFUCache &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;int, LRUCache *&gt; lfu;</span><br><span class="line">    unordered_map&lt;int, Node *&gt; ind;</span><br><span class="line">    LRUCache head, tail;</span><br><span class="line">    int capacity, node_cnt;</span><br><span class="line">    LFUCache(int capacity) : capacity(capacity), node_cnt(0) &#123;</span><br><span class="line">        head.next &#x3D; &amp;tail;</span><br><span class="line">        tail.pre &#x3D; &amp;head;</span><br><span class="line">    &#125;</span><br><span class="line">    void remove_from_LRUCache(Node *p) &#123;</span><br><span class="line">        LRUCache *c1 &#x3D; lfu[p-&gt;cnt];</span><br><span class="line">        c1-&gt;remove_node(p);</span><br><span class="line">        if (c1-&gt;node_cnt &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            remove_LRUCache(c1);</span><br><span class="line">            lfu.erase(lfu.find(p-&gt;cnt));</span><br><span class="line">            delete(c1);</span><br><span class="line">        &#125;</span><br><span class="line">        node_cnt -&#x3D; 1;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    void insert_to_LRUCache(Node *p) &#123;</span><br><span class="line">        LRUCache *c &#x3D; lfu[p-&gt;cnt];</span><br><span class="line">        c-&gt;put(p);</span><br><span class="line">        node_cnt +&#x3D; 1;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    void remove_LRUCache(LRUCache *c) &#123;</span><br><span class="line">        c-&gt;next-&gt;pre &#x3D; c-&gt;pre;</span><br><span class="line">        c-&gt;pre-&gt;next &#x3D; c-&gt;next;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    void insert_LRUCache(LRUCache *c1, LRUCache *c2) &#123;</span><br><span class="line">        c2-&gt;pre &#x3D; c1, c2-&gt;next &#x3D; c1-&gt;next;</span><br><span class="line">        c1-&gt;next-&gt;pre &#x3D; c2, c1-&gt;next &#x3D; c2;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    void move_next_LRUCache(Node *p) &#123;</span><br><span class="line">        LRUCache *c1 &#x3D; lfu[p-&gt;cnt], *c2;</span><br><span class="line">        if (lfu.find(p-&gt;cnt + 1) &#x3D;&#x3D; lfu.end()) &#123;</span><br><span class="line">            c2 &#x3D; new LRUCache();</span><br><span class="line">            insert_LRUCache(c1, c2);</span><br><span class="line">            lfu[p-&gt;cnt + 1] &#x3D; c2;</span><br><span class="line">        &#125;</span><br><span class="line">        remove_from_LRUCache(p);</span><br><span class="line">        p-&gt;cnt +&#x3D; 1;</span><br><span class="line">        insert_to_LRUCache(p);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if (ind.find(key) &#x3D;&#x3D; ind.end()) return -1;</span><br><span class="line">        Node *p &#x3D; ind[key];</span><br><span class="line">        move_next_LRUCache(p);</span><br><span class="line">        return p-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        Node *p;</span><br><span class="line">        if (ind.find(key) &#x3D;&#x3D; ind.end()) &#123;</span><br><span class="line">            if (node_cnt &#x3D;&#x3D; capacity) &#123;</span><br><span class="line">                remove_from_LRUCache(head.next-&gt;head.next);</span><br><span class="line">            &#125;</span><br><span class="line">            p &#x3D; new Node(key, value);</span><br><span class="line">            if (lfu.find(p-&gt;cnt) &#x3D;&#x3D; lfu.end()) &#123;</span><br><span class="line">                lfu[p-&gt;cnt] &#x3D; new LRUCache();</span><br><span class="line">                insert_LRUCache(&amp;head, lfu[p-&gt;cnt]);</span><br><span class="line">            &#125;</span><br><span class="line">            insert_to_LRUCache(p);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            move_next_LRUCache(ind[key]);</span><br><span class="line">            ind[key]-&gt;value &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="12-习题答疑课-四"><a href="#12-习题答疑课-四" class="headerlink" title="12.习题答疑课(四)"></a>12.习题答疑课(四)</h1><h2 id="一、HZOJ-328-楼兰图腾"><a href="#一、HZOJ-328-楼兰图腾" class="headerlink" title="一、HZOJ-328-楼兰图腾"></a>一、HZOJ-328-楼兰图腾</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8B%E5%8D%885.02.59.png" alt="截屏2021-02-01 下午5.02.59"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8B%E5%8D%885.03.08.png" alt="截屏2021-02-01 下午5.03.08"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 2.HZOJ328-60.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: huguang</span></span><br><span class="line"><span class="comment">	&gt; Mail: hug@haizeix.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_n 200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-x))</span></span><br><span class="line"><span class="keyword">int</span> num[max_n + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> v, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=n) &#123;</span><br><span class="line">        num[j] += v;</span><br><span class="line">        j += lowbit(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alg</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j) &#123;</span><br><span class="line">        sum += num[j];</span><br><span class="line">        j -= lowbit(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,a,x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        add(a + <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> q = alg(a);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> w = i - <span class="number">1</span> - q;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> e = n - a - w;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r = a - <span class="number">1</span> - q;</span><br><span class="line">        x +=  w * e;</span><br><span class="line">        y +=  q * r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<h2 id="二、HZOJ-224-复合线段树"><a href="#二、HZOJ-224-复合线段树" class="headerlink" title="二、HZOJ-224-复合线段树"></a>二、HZOJ-224-复合线段树</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8B%E5%8D%885.18.34.png" alt="截屏2021-02-01 下午5.18.34"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8B%E5%8D%885.18.43.png" alt="截屏2021-02-01 下午5.18.43"></p>
<h3 id="1、解题思路"><a href="#1、解题思路" class="headerlink" title="1、解题思路"></a>1、解题思路</h3><ol>
<li>因为要支持区间操作，所以要用到线段树的懒标记技巧</li>
<li>有两种区间修改操作，乘法与加法</li>
<li>$a\times(s + b) = a \times s + a \times b$，可知乘法操作的时候，需要同时修改区间和值与加法懒标记</li>
<li>加法懒标记只需要单独修改加法懒标记即可</li>
<li>懒标记更新技巧：先下沉乘法懒标记，再下沉加法懒标记</li>
</ol>
<p><img src="../guanghu/Library/Application%2520Support/typora-user-images/image-20210130215543216.png" alt="image-20210130215543216"></p>
<h3 id="2、0分程序改-BUG"><a href="#2、0分程序改-BUG" class="headerlink" title="2、0分程序改 BUG"></a>2、0分程序改 BUG</h3><ol>
<li>主要 BUG，超过内存限制</li>
<li>原因分析：程序中，将懒标记改成了记录具体的操作序列，所以使得线段树节点空间激增，超过内存限制</li>
<li>在不修改懒标记技巧的情况下，无法满分通过程序</li>
<li><strong>思考：</strong>如果把线段树的节点修改成动态申请的，说不定会通过空间限制。</li>
</ol>
<h3 id="3、10分程序改-BUG"><a href="#3、10分程序改-BUG" class="headerlink" title="3、10分程序改 BUG"></a>3、10分程序改 BUG</h3><ol>
<li>懒标记更新方式严重错误，源程序中将懒标记更新到了整棵子树中。</li>
<li><strong>修改1：</strong>懒标记从父节点，只下沉到直接子节点处</li>
<li><strong>修改2：</strong>标记下沉时，要先将乘法标记下沉，再将加法标记下沉</li>
<li><strong>修改3：</strong>该 $%p$ 的地方就 $%p$</li>
</ol>
<h3 id="4、50分程序改-BUG"><a href="#4、50分程序改-BUG" class="headerlink" title="4、50分程序改 BUG"></a>4、50分程序改 BUG</h3><ol>
<li>下沉乘法懒标记时出错，应该同时修改加法懒标记</li>
<li><strong>修改1：</strong>将乘法标记下沉与加法标记下沉分成两个函数分别实现</li>
<li><strong>修改2：</strong>将数据类型改成 $long\ long$</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum, t1, t2;</span><br><span class="line">&#125; tree[(MAX_N &lt;&lt; <span class="number">2</span>) + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul_tag</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> ind, <span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    tree[ind].sum *= x;</span><br><span class="line">    tree[ind].sum %= p;</span><br><span class="line">    tree[ind].t1 *= x;</span><br><span class="line">    tree[ind].t1 %= p;</span><br><span class="line">    tree[ind].t2 *= x;</span><br><span class="line">    tree[ind].t2 %= p;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_tag</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> ind, <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    tree[ind].sum += x * n;</span><br><span class="line">    tree[ind].sum %= p;</span><br><span class="line">    tree[ind].t2 += x;</span><br><span class="line">    tree[ind].t2 %= p;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UP</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> ind)</span> </span>&#123;</span><br><span class="line">    tree[ind].sum = tree[ind &lt;&lt; <span class="number">1</span>].sum + tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    tree[ind].sum %= p; </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DOWN</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> ind, <span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[ind].t1 - <span class="number">1</span> || tree[ind].t2) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a = tree[ind].t1, b = tree[ind].t2;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        mul_tag(ind &lt;&lt; <span class="number">1</span>, a);</span><br><span class="line">        mul_tag(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, a);</span><br><span class="line">        add_tag(ind &lt;&lt; <span class="number">1</span>, b, mid - l + <span class="number">1</span>);</span><br><span class="line">        add_tag(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, b, r - mid);</span><br><span class="line">        tree[ind].t1 = <span class="number">1</span>;</span><br><span class="line">        tree[ind].t2 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> ind, <span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r)</span> </span>&#123;</span><br><span class="line">    tree[ind].t1 = <span class="number">1</span>; tree[ind].t2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[ind].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(ind &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    build(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    UP(ind);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> ind, <span class="keyword">long</span> <span class="keyword">long</span> flag, <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y, <span class="keyword">long</span> <span class="keyword">long</span> val, <span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            mul_tag(ind, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add_tag(ind, val, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    DOWN(ind, l, r);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) modify(ind &lt;&lt; <span class="number">1</span>, flag, x, y, val, l, mid);</span><br><span class="line">    <span class="keyword">if</span> (y &gt; mid) modify(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, flag, x, y, val, mid + <span class="number">1</span>, r);</span><br><span class="line">    UP(ind);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> ind, <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y, <span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[ind].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    DOWN(ind, l, r);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) ans += query(ind &lt;&lt; <span class="number">1</span>, x, y, l, mid);</span><br><span class="line">    ans %= p;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; mid) ans += query(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, y, mid + <span class="number">1</span>, r);</span><br><span class="line">    ans %= p;</span><br><span class="line">    UP(ind);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> op, x, y, k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">                modify(<span class="number">1</span>, op - <span class="number">1</span>, x, y, k, <span class="number">1</span>, n);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; query(<span class="number">1</span>, x, y, <span class="number">1</span>, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>










<h2 id="三、HZOJ-52-古老的打字机"><a href="#三、HZOJ-52-古老的打字机" class="headerlink" title="三、HZOJ-52-古老的打字机"></a>三、HZOJ-52-古老的打字机</h2><h3 id="1、40分程序改-BUG"><a href="#1、40分程序改-BUG" class="headerlink" title="1、40分程序改 BUG"></a>1、40分程序改 BUG</h3><ol>
<li>状态转移过程，采用了最朴素的状态转移方式，时间效率极差</li>
<li>没有采用斜率优化的转移技巧</li>
</ol>
<h3 id="2、40分程序改-BUG"><a href="#2、40分程序改-BUG" class="headerlink" title="2、40分程序改 BUG"></a>2、40分程序改 BUG</h3><ol>
<li>程序过程中需要求前缀和，值范围超过了整型表示范围，将 $int$ 改成 $long\ long$ 即可</li>
</ol>
<h1 id="13-习题答疑课-五"><a href="#13-习题答疑课-五" class="headerlink" title="13.习题答疑课(五)"></a>13.习题答疑课(五)</h1><h2 id="一、【0分】HZOJ-64-海贼红黑树"><a href="#一、【0分】HZOJ-64-海贼红黑树" class="headerlink" title="一、【0分】HZOJ-64-海贼红黑树"></a>一、【0分】HZOJ-64-海贼红黑树</h2><ol>
<li>做了错误的假设，假设第一个操作是插入节点的操作</li>
<li>删除了$__attribute__((constructor))$，导致 NIL节点没有被初始化</li>
<li>没有修改双黑节点的颜色，将双黑变成普通黑</li>
</ol>
<h2 id="二、剑指-Offer-56-数字出现的次数Ⅱ"><a href="#二、剑指-Offer-56-数字出现的次数Ⅱ" class="headerlink" title="二、剑指 Offer-56-数字出现的次数Ⅱ"></a>二、剑指 Offer-56-数字出现的次数Ⅱ</h2><ol>
<li>写出真值表，推导状态转化公式</li>
</ol>
<p><img src="../guanghu/Library/Application%2520Support/typora-user-images/image-20210131215620980.png" alt="image-20210131215620980"></p>
<p><strong>扩展问题：</strong>只有一个数字出现次数不足 4 次，其他数字，都出现了 4 次，找到这个数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int a &#x3D; 0, b &#x3D; 0, a1, b1;</span><br><span class="line">        for (int i &#x3D; 0, c; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            c &#x3D; nums[i];</span><br><span class="line">            a1 &#x3D; (a &amp; ~b &amp; ~c) | (~a &amp; b &amp; c);</span><br><span class="line">            b1 &#x3D; (~a &amp; b &amp; ~c) | (~a &amp; ~b &amp; c);</span><br><span class="line">            a &#x3D; a1;</span><br><span class="line">            b &#x3D; b1;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="三、HZOJ-646-海贼王堆"><a href="#三、HZOJ-646-海贼王堆" class="headerlink" title="三、HZOJ-646-海贼王堆"></a>三、HZOJ-646-海贼王堆</h2><ol>
<li>堆的裸题</li>
<li>使用 set 模拟堆的行为</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Data &#123;</span><br><span class="line">    string name;</span><br><span class="line">    int sex, age, ind;</span><br><span class="line">    bool operator&lt;(const Data &amp;a) const &#123;</span><br><span class="line">        if (name.find(&quot;wang&quot;) &#x3D;&#x3D; 0 &amp;&amp; a.name.find(&quot;wang&quot;) !&#x3D; 0) return true;</span><br><span class="line">        if (name.find(&quot;wang&quot;) !&#x3D; 0 &amp;&amp; a.name.find(&quot;wang&quot;) &#x3D;&#x3D; 0) return false;</span><br><span class="line">        if (sex - a.sex) return sex &#x3D;&#x3D; 0;</span><br><span class="line">        if (age - a.age) return age &gt; a.age;</span><br><span class="line">        if (name !&#x3D; a.name) return name &lt; a.name;</span><br><span class="line">        return ind &lt; a.ind;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    set&lt;Data&gt; s;</span><br><span class="line">    int n, op;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        switch (op) &#123;</span><br><span class="line">            case 1: &#123;</span><br><span class="line">                string name;</span><br><span class="line">                int sex, age;</span><br><span class="line">                cin &gt;&gt; name &gt;&gt; sex &gt;&gt; age;</span><br><span class="line">                s.insert(&#123;name, sex, age, i&#125;);</span><br><span class="line">            &#125; break;</span><br><span class="line">            case 2: &#123;</span><br><span class="line">                if (s.size() &#x3D;&#x3D; 0) cout &lt;&lt; &quot;empty&quot; &lt;&lt; endl;</span><br><span class="line">                else cout &lt;&lt; s.begin()-&gt;name &lt;&lt; endl;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case 3: &#123;</span><br><span class="line">                if (s.size() &#x3D;&#x3D; 0) break;</span><br><span class="line">                s.erase(s.begin());</span><br><span class="line">            &#125; break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四、面试题反馈"><a href="#四、面试题反馈" class="headerlink" title="四、面试题反馈"></a>四、面试题反馈</h2><h3 id="字典树面试题1"><a href="#字典树面试题1" class="headerlink" title="字典树面试题1"></a>字典树面试题1</h3><p><strong>问题描述：</strong>例如一个用户输入了一个字符串：hellu，那它是不存在于字典中的，那么我们怎么判断出来呢？</p>
<p><strong>要求：</strong></p>
<p>（1）定义存储所有正确单词的数据结构。</p>
<p>（2）写一个录入单词的函数。</p>
<p>（3）写一个判断用户输入的单词是否正确的函数。</p>
<p><strong>注：</strong>忽略大小写，可以认为都是小写。</p>
<h3 id="字典树面试题2"><a href="#字典树面试题2" class="headerlink" title="字典树面试题2"></a>字典树面试题2</h3><p><strong>问题描述：</strong>出错的情况下，提示出正确的单词（可能有多个）。出错的情况很多，前中后的位置都有可能出错，可能错一个字母，也可能多一个或少一个字母。</p>
<p><strong>要求：</strong></p>
<p>（1）找出跟错误单词相差一个字母的正确单词即可。</p>
<p>（2）定义存储单词的数据结构。</p>
<p>（3）写出查询函数，返回n个正确的单词。</p>
<h1 id="00000000"><a href="#00000000" class="headerlink" title="00000000"></a>00000000</h1><h1 id="0000000000"><a href="#0000000000" class="headerlink" title="0000000000"></a>0000000000</h1>]]></content>
      <categories>
        <category>习题答疑</category>
      </categories>
      <tags>
        <tag>习题答疑</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言</title>
    <url>/2020/11/17/01.C%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>2020.11.17-12.20</p>
<h1 id="0-基础知识"><a href="#0-基础知识" class="headerlink" title="0.基础知识"></a>0.基础知识</h1><p><strong>unsigned int （unsigned long）</strong></p>
<ul>
<li>4字节8位可表达位数：2^32=42 9496 7296</li>
<li>范围：0 ～ 42 9496 7295 (42*10^8)</li>
</ul>
<p><strong>int （long）</strong></p>
<ul>
<li>4字节8位可表达位数：2^32=42 9496 7296</li>
<li>范围：-21 4748 3648 ～ 21 4748 3647 (21*10^8)</li>
</ul>
<p><strong>unsigned long (unsigned __int64)</strong></p>
<ul>
<li>8字节8位可表达位数：2^64=1844 6744 0737 0960 0000</li>
<li>范围：0 ～ 1844 6744 0737 0955 1615 (1844*10^16)</li>
</ul>
<p><strong>long long (__int64)</strong></p>
<ul>
<li>8字节8位可表达位数：2^64=1844 6744 0737 0960 0000</li>
<li>范围：-922 3372 0368 5477 5808 ～ 922 3372 0368 5477 5807 (922*10^16)</li>
</ul>
<a id="more"></a>


<p><code>while(~scanf()):~</code>按位取反,<code>scanf</code>返回值为-1时值不合法，-1（1111…1111）,-1按位取反结果为0循环终止</p>
<blockquote>
<p><code>%d</code> —— 以带符号的十进制形式输出整数 </p>
<p><code>%o</code> —— 以无符号的八进制形式输出整数 </p>
<p><code>%x</code> —— 以无符号的十六进制形式输出整数</p>
<p><code>%u</code> —— 以无符号的十进制形式输出整数 </p>
<p><code>%c</code> —— 以字符形式输出单个字符 </p>
<p><code>%s</code> —— 输出字符串 </p>
<p><code>%f</code> —— 以小数点形式输出单、双精度实数</p>
<p><code>%e</code> —— 以标准指数形式输出单、双精度实数</p>
<p><code>%g</code> —— 选用输出宽度较小的格式输出实数，科学技术输出</p>
<p><code>%ld</code>用于long类型，<code>%lld</code>用于long long类型。</p>
<p><code>%lu</code> <code>sizeof(array)</code></p>
<p><code>%p</code>   <code>&amp;i</code></p>
<p><code> double</code>对应的是 <code>%lf</code><br><code>float</code>对应的是 <code>%f</code></p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-10-27%20%E4%B8%8A%E5%8D%889.37.36.png" alt="截屏2020-10-27 上午9.37.36"></p>
<h1 id="1-输入输出函数说明"><a href="#1-输入输出函数说明" class="headerlink" title="1.输入输出函数说明"></a>1.输入输出函数说明</h1><h2 id="1-printf函数"><a href="#1-printf函数" class="headerlink" title="1.printf函数"></a>1.printf函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  	头文件：stdio.h</span><br><span class="line">  	原型：<span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fromat, ...)</span></span>;<span class="comment">//返回成功打印字符个数</span></span><br><span class="line">		format :格式控制字符串</span><br><span class="line">    ...:可变参数列表</span><br><span class="line">    返回值：输出字符的数量</span><br><span class="line"><span class="comment">//使用printf函数，求解一个数字n的十进制表示的数字位数</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  n = <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; has %d digits! \n&quot;</span>, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<h2 id="2-scanf函数"><a href="#2-scanf函数" class="headerlink" title="2.scanf函数"></a>2.scanf函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">  	头文件：stdio.h</span><br><span class="line">  	原型：<span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fromat, ...)</span></span>;<span class="comment">//返回成功打印字符个数</span></span><br><span class="line">		format :格式控制字符串</span><br><span class="line">    ...:可变参数列表</span><br><span class="line">    返回值：成功读入参数的个数</span><br><span class="line">    <span class="comment">//读入一个字符串(可能包含空格)，输出这个字符串中字符的数量，</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>,str) != EOF)&#123;</span><br><span class="line">		getchar();</span><br><span class="line">    n =  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;  has  %d digits!\n&quot;</span>, n);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用scanf时其会将末尾的回车符保留在缓存当中，所以在用其输入字符串时一定要加一个getchar去吃掉回车符</p>
</blockquote>
<p><code>~scanf()</code></p>
<h2 id="3-sprinf-fprintf"><a href="#3-sprinf-fprintf" class="headerlink" title="3.sprinf,fprintf"></a>3.sprinf,fprintf</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">//标准输入</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//stdin</span></span><br><span class="line">	<span class="comment">//标准输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">//stdout stderr</span></span><br><span class="line">	<span class="built_in">sprintf</span>(str, <span class="string">&quot;%d.%d.%d.%d&quot;</span>, <span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//字符串拼接</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str);</span><br><span class="line">	FILE *fout = fopen(<span class="string">&quot;output&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;stdout = %s\n&quot;</span>, str);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stdoerr = %s\n&quot;</span>, str);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//stdout（标准输出），输出方式是行缓冲。输出的字符会先存放在缓冲区，等按下回车键时才进行实际的I/O操作。 </span></span><br><span class="line"><span class="comment">//stderr（标准错误），是不带缓冲的，这使得出错信息可以直接尽快地显示出来。</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;stdout = %s&quot;</span>, str);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stdoerr = %s&quot;</span>, str);</span><br><span class="line">  <span class="comment">//stdoerr = 192.168.1.1stdout = 192.168.1.1%</span></span><br><span class="line">  <span class="comment">//在Linux环境下我们可以发现第一次会输出stdoerr,</span></span><br><span class="line">  <span class="comment">//是因为stdout将输出的字符串放到了缓冲区当中直到程序结束在将缓冲区中的数据刷新出来。</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;stdout = %s\n&quot;</span>, str);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stdoerr = %s&quot;</span>, str);</span><br><span class="line">  <span class="comment">//stdout = 192.168.1.1</span></span><br><span class="line">	<span class="comment">//stdoerr = 192.168.1.1%</span></span><br><span class="line">  <span class="comment">//这个属于stdout输出的第二种情况即遇到换行符(“\n”)时输出,因此在本例中顺序输出了该结果</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="2-基本运算符"><a href="#2-基本运算符" class="headerlink" title="2.基本运算符"></a>2.基本运算符</h1><blockquote>
<p><code>&amp;  </code>   按位与运算符</p>
<p><code>^</code>     异或 ==&gt; 逆运算     自己是自己的逆运算</p>
<p>0异或任何数，其结果=任何数:0 ^ 0=0,0 ^ 1=1</p>
<p>1异或任何数，其结果=任何数取反:1 ^ 0=1,1 ^ 1=0</p>
<p>任何数异或自己，等于把自己置0:x ^ x=0</p>
<p>​                    1 0 1 0</p>
<p>​    ^      <u>     1 1 1 1</u>      </p>
<p>​    ==&gt;        0 1 0 1         ， </p>
<p>2^3 = 1   2^1=3  3^1=2</p>
<p><code>~</code>     </p>
<p>~x  ==&gt; 如果 x 为 0，则得到 1，如果 x 是 1，则得到 0</p>
</blockquote>
<blockquote>
<p><code>&lt;&lt;</code>,<code>&gt;&gt;</code> 左移,右移</p>
<p>32bit</p>
<p>左移：</p>
<p>十进制整数2（0010）  2&lt;&lt;1 ==&gt;(0100) = 4 = 2 * 2</p>
</blockquote>
<p><code>math.h</code></p>
<p>1.<code>pow</code>函数：指数函数</p>
<p>原型：<code>double pow(double a, bouble b);</code></p>
<p>编译时需要<code>gcc -o ippanduan 1.pow.c -lm</code></p>
<p>2.<code>sqrt</code>函数：开平方根函数</p>
<p>原型：<code>double sqrt(double x);</code></p>
<p><code>ceil</code>函数：上取整函数</p>
<p><code>double ceil(double x);</code></p>
<p><code>floor</code>函数：向下取整</p>
<p><code>abs</code>函数:整数绝对值</p>
<p>头文件：<code>stdlib.h</code></p>
<p>原型：<code>int abs(int x);</code></p>
<p><code>fabs</code>函数：实数绝对值函数</p>
<p><code>log</code>函数：以<code>e</code>为底对数函数</p>
<p><code>log10</code>函数：以<code>10</code>为底对数函数</p>
<ul>
<li><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/u=506614216,773713317&fm=58.png" alt="formula"></li>
</ul>
<p>32bit</p>
<p>int : <code>2 ^ (-31) ~ 2 ^ 31 - 1</code></p>
<p><code>n %  2</code> ==<code> n &amp; 1</code></p>
<p><code>!!</code>逻辑归一化，<code>!!(x)</code>,,,如果x=3， <code>!(x) == 0</code> <code>!!(x)== 1</code>,归一化</p>
<p><code>false</code>  : <code>null</code> ,  <code>0</code>,<code>\0</code></p>
<p>分支结构：顺序、分支、循环结构</p>
<p>switch 不可以用于double、float</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">/* 可选的 */</span></span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">/* 可选的 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 您可以有任意数量的 case 语句 */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选的 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>循环结构</strong></p>
<blockquote>
<p>while</p>
<p>while (表达式){</p>
<p>​    代码块;</p>
<p>}</p>
<p>do{</p>
<p>代码块;</p>
<p>}  while  (表达式);</p>
<p>for (初始化; 循环条件; 执行后操作) {</p>
<p>​            代码块;</p>
<p>}</p>
</blockquote>
<h1 id="3-程序流程控制方法"><a href="#3-程序流程控制方法" class="headerlink" title="3.程序流程控制方法"></a><strong>3.程序流程控制方法</strong></h1><h2 id="1-短路原则："><a href="#1-短路原则：" class="headerlink" title="1.短路原则："></a>1.短路原则：</h2><blockquote>
<p>要使（表达式1）&amp;&amp;（表达式2）运算结果为真则要求：表达式1，表达式2都为真，如果表达式1为假，则不计算表达式2了，因为此时已<br>经确定（表达式1）&amp;&amp;（表达式2）运算结果不可能为真，这就是&amp;&amp;运算的短路特性。</p>
</blockquote>
<blockquote>
<p>要使（表达式1）||（表达式2）运算结果为假则要求：表达式1，表达式2都为假，如果表达式1为真，则不计算表达式2了，因为此时已经<br>确定（表达式1）||（表达式2）运算结果不可能为假，这就是||运算的短路特性。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( (a++) &amp;&amp; (b++)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;true a = %d, b = %d \n&quot;</span>, a, b);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;false a = %d, b = %d \n&quot;</span>, a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在第一个之后输出的数字输出空格</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">	<span class="comment">//if (i != 0) printf(&quot; &quot;);</span></span><br><span class="line"><span class="comment">//	if (i) printf(&quot; &quot;);</span></span><br><span class="line">	<span class="function">i &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot; &quot;</span>)</span></span>;<span class="comment">//逻辑与短路原则</span></span><br><span class="line">	i == <span class="number">0</span> || <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>




<h2 id="2-随机数"><a href="#2-随机数" class="headerlink" title="2.随机数"></a>2.随机数</h2><blockquote>
<p>srand()是随机数种子，s表示seed，种子的意思。</p>
</blockquote>
<blockquote>
<p>rand()可以产生0到RAND_MAX(32767)之间的随机数，用rand()%x可以得到0到x之间的随机数。</p>
</blockquote>
<blockquote>
<p>srand()和rand()都需要用到stdlib.h。</p>
<p>srand()的种子主要有两种，srand(1)和srand((unsigned)time(NULL))，前者生成的随机数每次都是相等的，后者则是根据现在在走的时间取的随机数，是真随机数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">//伪随机数，结果固定</span></span><br><span class="line"><span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, val);</span><br><span class="line"><span class="comment">//伪随机数，结果随机</span></span><br><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, val);</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<h2 id="3-取模运算"><a href="#3-取模运算" class="headerlink" title="3.取模运算"></a>3.取模运算</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span>）<span class="comment">//偶数</span></span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>)<span class="comment">//优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//统计偶数个数</span></span><br><span class="line">num += (val &amp; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>






<h2 id="4-循环结构代码演示"><a href="#4-循环结构代码演示" class="headerlink" title="4.循环结构代码演示"></a>4.循环结构代码演示</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回文数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rev_num</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> x = n;</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x)&#123;</span><br><span class="line">		temp = temp * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">		x /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp == n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, rev_num(n) ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回文数  base进制下的回文数 0110  4 + 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rev_num</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> base)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> x = n;</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x)&#123;</span><br><span class="line">		temp = temp * base + x % base;</span><br><span class="line">		x /= base;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp == n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, rev_num(n, <span class="number">2</span>) ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> x = n;</span><br><span class="line">	<span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x)&#123;</span><br><span class="line">	 	x /= <span class="number">10</span>;</span><br><span class="line">	 	digit += <span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d has %d digits !\n&quot;</span>,n , digit);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bug </span></span><br><span class="line"><span class="comment">//0 has 0 digits !</span></span><br><span class="line"><span class="comment">//因为没有执行while循环</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> x = n;</span><br><span class="line">	<span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">do</span>&#123;</span><br><span class="line">	 	x /= <span class="number">10</span>;</span><br><span class="line">		 digit += <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d has %d digits !\n&quot;</span>,n , digit);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="5-判断日期的合法性"><a href="#5-判断日期的合法性" class="headerlink" title="5.判断日期的合法性"></a>5.判断日期的合法性</h2><blockquote>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出一个日期，请判断日期的合法性。特别注意一下几点：</p>
<ol>
<li>年份是负数时，代表公元前，是合法的</li>
<li>月份和日子是负数是非法的</li>
<li>2月份要注意判断闰年的情况，闰年的判断标准是：能被4整除但不能被100整除，或者能被400整除</li>
</ol>
<hr>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入 𝑦,𝑚,𝑑y,m,d三个整数，分别代表年月日。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>如果日期合法，输出『Yes』，否则输出『No』。 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m &lt;= <span class="number">0</span> || m &gt; <span class="number">12</span> || d &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> mouth[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span> ,<span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span> ((y % <span class="number">4</span> ==<span class="number">0</span> &amp;&amp; y % <span class="number">100</span>) || y % <span class="number">400</span> == <span class="number">0</span>) mouth[<span class="number">2</span>] += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> d&lt;= mouth[m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> y, m, d;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;y, &amp;m, &amp;d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, check(y, m, d) ?  <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<blockquote>
<p>题目描述</p>
<p>所谓丑数，就是素因子中只含有 2、3、5 的数字。给出一个数字 N，请输出 N 以内所有丑数。特别的规定，1是第一个丑数。</p>
<p>输入一个整数 𝑁（1≤𝑁≤1000）N（1≤N≤1000）</p>
<p>从小到达输出 𝑁N 以内的所有丑数，包括 𝑁N，每行输出一个数字 。</p>
</blockquote>
<hr>
<p>//*<strong><strong>**</strong></strong>30</p>
<p>约数定理：N= 2^n+3^n+5^n</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(n % <span class="number">2</span> == <span class="number">0</span>) n/= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (n % <span class="number">3</span>) n/= <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">while</span> (n % <span class="number">5</span>) n/= <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!check(i)) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<blockquote>
<p><code>n % 2 ==0 ==&gt; n &amp; 1 ==0</code>      3%2  3&amp;1</p>
<p>​    0 0 1 1</p>
<p>&amp; 0 0 1 0</p>
<hr>
<p>​    0 0 1 0 </p>
<p>3 = 2^1 + 2^0  结果值与最后一位有关系</p>
<p><code>n % 4 == 0 =&gt; n &amp; 3 == 0</code></p>
<p><code>n % 4</code> :  结果值有：0 1 2 3</p>
<p>​    0 1 0 0</p>
<p>  0 0 1 1</p>
<hr>
<p>​    0 0 1 0 </p>
<p><code>n % 6</code> !==&gt;任何东西,转换成二进制后，前面的数，不一定都能被6整除</p>
<p><code>n % 7</code></p>
<p><code>n % 8</code>==&gt; <code>n &amp; 7</code></p>
<p><code>n % 16</code>==&gt; <code>n &amp; 15</code></p>
</blockquote>
<h1 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h1><h2 id="1-函数"><a href="#1-函数" class="headerlink" title="1.函数"></a>1.函数</h2><p>在没有特殊函数情况下C/C++函数开始的入口是main函数</p>
<blockquote>
<p>函数:压缩了的数组</p>
<p>数组是展开的函数</p>
</blockquote>
<h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h2><blockquote>
<p>递归：</p>
<p>​        程序调用自身的变成技巧</p>
</blockquote>
<p>递归程序的组成部分：</p>
<p>​        1.边界条件处理</p>
<p>​        2.针对问题的处理过程和递归过程</p>
<p>​        3.结果返回</p>
<h2 id="3-函数指针"><a href="#3-函数指针" class="headerlink" title="3.函数指针"></a>3.函数指针</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> (*f1)(<span class="keyword">int</span>), <span class="keyword">int</span> (*f2)(<span class="keyword">int</span>), <span class="keyword">int</span> (*f3)(<span class="keyword">int</span>), <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> f1(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">100</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> f2(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f3(x);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>函数指针的应用：分段函数</p>
<p>二分查找</p>
<p><code>(head + tail) / 2 等价于 (head + tail) &gt;&gt; 1</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tail = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">    mid = (head + tail) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//mid = (head + tail) &gt;&gt; 1;</span></span><br><span class="line">    <span class="keyword">if</span>(num[mid]==x) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(num[mid] &lt; x) head = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>






<p><code>*(num)(long long)</code>函数指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Triangle</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Pentagonal</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * (<span class="number">3</span> * n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Hexagonal</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * (<span class="number">2</span> * n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> (*num)(<span class="keyword">long</span> <span class="keyword">long</span>), <span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> head = <span class="number">0</span>, tail = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (num(mid) == x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (num(mid) &lt; x) head = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">285</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> val = Triangle(n);</span><br><span class="line">        <span class="keyword">if</span> (binary_search(Pentagonal, val, val) == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (binary_search(Hexagonal, val, val) == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="4-欧几里得算法"><a href="#4-欧几里得算法" class="headerlink" title="4.欧几里得算法"></a>4.欧几里得算法</h2><p>辗转相除法(计算两个数字的最大公约数)</p>
<p><code>while(~scanf())</code>:<code>~</code>按位取反,<code>scanf</code>返回值为-1时值不合法，-1（1111…1111）,-1按位取反结果为0循环终止</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	if (!b) return a;//==&gt;	if (b == 0) return a;</span></span><br><span class="line"><span class="comment">//	return gcd(b, a % b);</span></span><br><span class="line">	<span class="keyword">return</span> (b ? gcd(b, a % b) : a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;gcd(%d, %d) = %d\n&quot;</span>, a, b, gcd(a, b));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>扩展：关键字<code>inline</code>内联函数</p>
<p>可能使函数调用更快，减少函数调用开销，递归函数和复杂的循环不能使用<code>inline</code></p>
<h2 id="5-扩展欧几里得算法"><a href="#5-扩展欧几里得算法" class="headerlink" title="5.扩展欧几里得算法"></a>5.扩展欧几里得算法</h2><p>快速求解<code>ax+by=1</code>的方程组的一组整数解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="6-变参函数"><a href="#6-变参函数" class="headerlink" title="6.变参函数"></a>6.变参函数</h2><p>实现可变参数 max_int ，从若干个参数中返回最大值</p>
<p>​    <code>int max_int(int a, ...);</code></p>
<p>如何获得a往后的参数列表？va_list类型的变量</p>
<p>如何定位a后面第一个参数的位置？va_start函数</p>
<p>如何获取下一个可变参数列表中的参数？va_arg函数</p>
<p>如何结束整个获得整个可变参数列表的动作？va_end函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_int</span><span class="params">(<span class="keyword">int</span> n, ...)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = INT32_MIN;<span class="comment">//32位极小值</span></span><br><span class="line">	va_list arg;<span class="comment">//...参数与列表</span></span><br><span class="line">	va_start(arg, n);</span><br><span class="line">	<span class="keyword">while</span> (n--)&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = va_arg(arg, <span class="keyword">int</span>);</span><br><span class="line">		<span class="keyword">if</span> (temp &gt; ans) ans = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	va_end(arg);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max_int(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max_int(<span class="number">5</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max_int(<span class="number">5</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">21</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span>a</span><br></pre></td></tr></table></figure>


<h2 id="7-简版printf函数实现"><a href="#7-简版printf函数实现" class="headerlink" title="7.简版printf函数实现"></a>7.简版printf函数实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *frm, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; frm[i]; i++)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(frm[i]);</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_printf = %d\n&quot;</span>, my_printf(<span class="string">&quot;hello, world!\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>const  char *frm</code> frm的值为常量</p>
<p>const字符串字面量</p>
<p>传入变量也没有任何影响</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *frm, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    va_list arg;</span><br><span class="line">    va_start(arg, frm);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> PUTC(a) putchar(a),++cnt</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; frm[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (frm[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: &#123;</span><br><span class="line">                      <span class="keyword">switch</span> (frm[++i]) &#123;</span><br><span class="line">                      <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:  PUTC(frm[i]);    <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:&#123;</span><br><span class="line">                                  <span class="keyword">int</span> x = va_arg(arg, <span class="keyword">int</span>);</span><br><span class="line">                                  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) PUTC(<span class="string">&#x27;-&#x27;</span>),x = -x;</span><br><span class="line">                                  <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                                  <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">                                   <span class="keyword">do</span> &#123;</span><br><span class="line">                                      temp = temp * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">                                      x /= <span class="number">10</span>;</span><br><span class="line">                                      ++digit;</span><br><span class="line">                                  &#125; <span class="keyword">while</span>(x);</span><br><span class="line">                                  <span class="keyword">while</span> (digit--) &#123;</span><br><span class="line">                                      PUTC(temp % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                                      temp /= <span class="number">10</span>;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span> : &#123;PUTC(frm[i]); <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// putchar(frm[i]);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> PUTC</span></span><br><span class="line">    va_end(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf == &gt; hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_printf ==&gt; %d\n\n&quot;</span>, my_printf(<span class="string">&quot;hello, world!\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int (a) = %d\n&quot;</span>, a);</span><br><span class="line">    my_printf(<span class="string">&quot;my_printf ==&gt; int (a) = %d\n\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int (0) = %d\n&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    my_printf(<span class="string">&quot;my_printf ==&gt; int (0) = %d\n\n&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int (10000) = %d\n&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    my_printf(<span class="string">&quot;my_printf ==&gt; int (10000) = %d\n\n&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int (-123) = %d\n&quot;</span>, <span class="number">-123</span>);</span><br><span class="line">    my_printf(<span class="string">&quot;my_printf ==&gt; int (-123) = %d\n\n&quot;</span>, <span class="number">-123</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>优化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse_num</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> *temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        digit++;</span><br><span class="line">        *temp = *temp * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">return</span> digit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">output_num</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(digit--) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        cnt++;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *frm, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    va_list arg;</span><br><span class="line">    va_start(arg, frm);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> PUTC(a) putchar(a),++cnt</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; frm[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (frm[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: &#123;</span><br><span class="line">                      <span class="keyword">switch</span> (frm[++i]) &#123;</span><br><span class="line">                      <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:  PUTC(frm[i]);    <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = va_arg(arg, <span class="keyword">int</span>);</span><br><span class="line">                        <span class="keyword">uint32_t</span> xx = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) PUTC(<span class="string">&#x27;-&#x27;</span>),xx = -x;</span><br><span class="line">                        <span class="keyword">else</span> xx = x;</span><br><span class="line">                        <span class="keyword">int</span> x1 = xx / <span class="number">100000</span>, x2 = xx % <span class="number">100000</span>;</span><br><span class="line">                        <span class="keyword">int</span> temp1 = <span class="number">0</span>, temp2 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">int</span> digit1 = reverse_num(x1, &amp;temp1);</span><br><span class="line">                        <span class="keyword">int</span> digit2 = reverse_num(x2, &amp;temp2);</span><br><span class="line">                        <span class="keyword">int</span> digit3 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (x1) digit3 = <span class="number">5</span> - digit2;</span><br><span class="line">                        <span class="keyword">else</span> digit1 = <span class="number">0</span>;</span><br><span class="line">                        cnt += output_num(temp1, digit1);</span><br><span class="line">                        cnt += output_num(<span class="number">0</span>,digit3);</span><br><span class="line">                        cnt += output_num(temp2, digit2);</span><br><span class="line">                        &#125; <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: &#123;</span><br><span class="line">                          <span class="keyword">const</span> <span class="keyword">char</span> *str = va_arg(arg, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">                          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">                                PUTC(str[i]);</span><br><span class="line">                          &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span> : &#123;PUTC(frm[i]); <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> PUTC</span></span><br><span class="line">    va_end(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf == &gt; hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_printf ==&gt; %d\n\n&quot;</span>, my_printf(<span class="string">&quot;hello, world!\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int (a) = %d\n&quot;</span>, a);</span><br><span class="line">    my_printf(<span class="string">&quot;my_printf ==&gt; int (a) = %d\n\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int (0) = %d\n&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    my_printf(<span class="string">&quot;my_printf ==&gt; int (0) = %d\n\n&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int (10000) = %d\n&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    my_printf(<span class="string">&quot;my_printf ==&gt; int (10000) = %d\n\n&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int (10050) = %d\n&quot;</span>, <span class="number">10050</span>);</span><br><span class="line">    my_printf(<span class="string">&quot;my_printf ==&gt; int (10050) = %d\n\n&quot;</span>, <span class="number">10050</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int (-123) = %d\n&quot;</span>, <span class="number">-123</span>);</span><br><span class="line">    my_printf(<span class="string">&quot;my_printf ==&gt; int (-123) = %d\n\n&quot;</span>, <span class="number">-123</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int (INT32_MAX) = %d\n&quot;</span>, INT32_MAX);</span><br><span class="line">    my_printf(<span class="string">&quot;my_printf ==&gt; int (INT32_MAX) = %d\n\n&quot;</span>, INT32_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int (INT32_MIN) = %d\n&quot;</span>, INT32_MIN);</span><br><span class="line">    my_printf(<span class="string">&quot;my_printf ==&gt; int (INT32_MIN) = %d\n\n&quot;</span>, INT32_MIN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;I love China&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(str) = %s\n&quot;</span>, str);</span><br><span class="line">    my_printf(<span class="string">&quot;my_printf ==&gt; str = %s\n\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; has %d digits!\n&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;printf %d&quot;</span>, n) - <span class="number">7</span>);</span><br><span class="line">        my_printf(<span class="string">&quot; has %d digits!\n\n&quot;</span>, my_printf(<span class="string">&quot;my_printf %d&quot;</span>, n) - <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h1><h2 id="1-数组声明与初始化"><a href="#1-数组声明与初始化" class="headerlink" title="1.数组声明与初始化"></a>1.数组声明与初始化</h2><p><code>int arr[100] = &#123;0&#125;</code>数组清空,只有={0}时，全部的数组才能被初始化为0，</p>
<p>静态数组在内存栈区（8M）</p>
<p>动态数组molloc，calloc，rolloc</p>
<p>数组是展开的函数</p>
<h2 id="2数组的运用"><a href="#2数组的运用" class="headerlink" title="2数组的运用"></a>2数组的运用</h2><h3 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h3><p>时间复杂度<code>O(N* loglogN)</code>趋近于<code>O(N)</code></p>
<blockquote>
<p>思想：用素数标记掉不是素数的数字，例如我知道了i是素数，那么<code>2*i</code>，<code>3*i</code>…不是素数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_n 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[max_n + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= max_n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;<span class="comment">//if (prime[i] == 0)&#123;&#125;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= max_n; j += i) &#123;</span><br><span class="line">				prime[j] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= max_n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>优化</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_n 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[max_n + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= max_n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;</span><br><span class="line">		prime[++prime[<span class="number">0</span>]] = i;<span class="comment">///******!!!</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= max_n; j += i) &#123;</span><br><span class="line">      <span class="comment">//当 i = 10000是发生溢出</span></span><br><span class="line">				prime[j] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= prime[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, prime[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p><code>prime[++prime[0]] = i;</code></p>
<p>会不会出现已经存储的还没有被标记</p>
<p>标记的速度很快，标记一群存储一个</p>
<p>3是素数，4是偶数，基数偶数相邻，除2以外，偶数都不是素数，</p>
</blockquote>
<h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>时间复杂度O(n)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_n 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[max_n + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= max_n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!prime[i]) prime[++prime[<span class="number">0</span>]] = i;</span><br><span class="line">    <span class="comment">//如果没有值，给他前面一个合数赋值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= prime[<span class="number">0</span>]; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (prime[j] * i &gt; max_n) <span class="keyword">break</span>;</span><br><span class="line">			prime[prime[j] * i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= prime[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, prime[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;prime[0] = %d\n&quot;</span>, prime[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h2 id="3-折半查找-二分查找"><a href="#3-折半查找-二分查找" class="headerlink" title="3.折半查找/二分查找"></a>3.折半查找/二分查找</h2><p>数组转函数，剩下开辟数组空间的时间，时间换空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> (*arr)(<span class="keyword">int</span>), <span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid ;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        mid = (tail + head ) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr(mid) == x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr(mid) &gt; x) &#123;</span><br><span class="line">            mid -= <span class="number">1</span>;</span><br><span class="line">            tail = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mid += <span class="number">1</span>;</span><br><span class="line">            head = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search1</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> tail = n - <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> mid;</span><br><span class="line">   <span class="keyword">while</span>(head &lt;= tail) &#123;</span><br><span class="line">       mid = (head + tail) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (arr[mid] == x) <span class="keyword">return</span> mid;</span><br><span class="line">       <span class="keyword">if</span> (arr[mid] &lt; x) head = mid + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">       arr[i] = i * i;</span><br><span class="line">       <span class="comment">//scanf(&quot;%d&quot;, &amp;arr[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;binary_search ==&gt;%d\n&quot;</span>, binary_search(func, x, n));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;binary_search1==&gt; %d\n&quot;</span>, binary_search1(arr, x, n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<blockquote>
<p>(2 + 4) / 2</p>
<p>0010</p>
<p>0100</p>
<p>0111   ==&gt;    &gt;&gt;1   == 0011 = 3  ,最后一位为1或0，</p>
</blockquote>
<p>折半查找实现平方根</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">double</span> (*arr)(<span class="keyword">double</span>), <span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> tail = n;</span><br><span class="line">    <span class="keyword">double</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1.0</span>) tail = <span class="number">1.0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> EPLS 1e-8</span></span><br><span class="line">    <span class="keyword">while</span> (tail - head &gt; EPLS) &#123;</span><br><span class="line">        mid = (head + tail) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr(mid) &lt; n) head = mid;</span><br><span class="line">        <span class="keyword">else</span> tail = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> EPLS</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_sqrt(%lf) = %g\n&quot;</span>, n, binary_search(func, n));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sqrt(%lf) = %g\n&quot;</span>, n, <span class="built_in">sqrt</span>(n)) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-牛顿迭代"><a href="#4-牛顿迭代" class="headerlink" title="4.牛顿迭代"></a>4.牛顿迭代</h2><blockquote>
<p>x2= x1 - (f(x1))/f`(x1)</p>
</blockquote>
<p>牛顿迭代递推式：</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8A%E5%8D%889.47.46.png" alt="截屏2020-12-10 上午9.47.46"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x - n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">NewTon</span><span class="params">(<span class="keyword">double</span> (*F)(<span class="keyword">double</span>,<span class="keyword">double</span>), <span class="keyword">double</span> (*f)(<span class="keyword">double</span>), <span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = n / <span class="number">2.0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> EPSL 1e-7</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(F(x, n)) &gt; EPSL) &#123;</span><br><span class="line">        x -=  F(x, n) / f(x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> EPSL</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_sqrt</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NewTon(func, f, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sqrt(%g) ==&gt;%g\n&quot;</span>, n, <span class="built_in">sqrt</span>(n));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_sqrt(%g) ==&gt; %g\n&quot;</span>, n, NewTon(func, f, n));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mysqrt %g==&gt; %g\n&quot;</span>, n, my_sqrt(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h2 id="5-数组代码演示"><a href="#5-数组代码演示" class="headerlink" title="5.数组代码演示"></a>5.数组代码演示</h2><p>静态数组 int arr[100];，存放在栈区</p>
<p>动态数组 通过molloc动态开辟空间 ，存放在堆区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_n 100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[max_n +<span class="number">5</span>];</span><br><span class="line"><span class="comment">//当将数组放在main函数外面的时候，数组的默认值为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//变量存放在栈区</span></span><br><span class="line">    <span class="keyword">int</span> arr[max_n +<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//静态数组</span></span><br><span class="line">    <span class="comment">//将arr的每一位值都初始化为0，不过不初始化为0，默认值不一定为0</span></span><br><span class="line">    <span class="comment">//函数内部申明变量，放在栈区 8MB，初始化值太大会发生爆栈</span></span><br><span class="line">  	</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="comment">//为什么传地址：</span></span><br><span class="line">  	<span class="comment">//程序的功能逻辑需要传变量的地址，</span></span><br><span class="line">    <span class="comment">//通过scanf写入值，通过scanf函数改变函数外部变量的值，需要传入地址</span></span><br><span class="line">  	<span class="comment">//传出参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//scanf(&quot;%d&quot;, &amp;arr[i]);</span></span><br><span class="line">        <span class="comment">//等价于</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">&#125;                                                                                            </span><br></pre></td></tr></table></figure>






<h2 id="6-数组传参"><a href="#6-数组传参" class="headerlink" title="6.数组传参"></a>6.数组传参</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_n 100</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,arr[10];</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">int</span> arr[max_n +<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">//105 * 4 = 420 bit</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(arr) = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">    <span class="comment">//420 , 4 * 105 = 420</span></span><br><span class="line">    <span class="comment">//sizeof(arr)输出arr的所占空间大小</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr = %p, &amp;arr[0] = %p\n&quot;</span>, arr, &amp;arr[<span class="number">0</span>]);<span class="comment">//arr == &amp;arr[0]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[1] = %p\n&quot;</span>, &amp;arr[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">char</span> str[max_n + <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str = %p, str + 1 = %p\n&quot;</span>, str, str + <span class="number">1</span>);<span class="comment">//1bit</span></span><br><span class="line">    <span class="comment">//arr[1] - arr[0] ==&gt; 4bit,1个int  4 bit</span></span><br><span class="line">  	<span class="comment">// arr + 1 跳跃一个元素（（int）bit））的大小 </span></span><br><span class="line">    <span class="comment">//double 8 bit</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    int32_t &lt;==&gt; int  4 bit</span></span><br><span class="line"><span class="comment">    long / long long 64 bit</span></span><br><span class="line"><span class="comment">    int64_bit &lt;inttypes.h&gt;</span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line">  	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;                          </span><br></pre></td></tr></table></figure>








<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_n 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.指针变量也是变量，存储地址，指针存储地址</span></span><br><span class="line">    <span class="comment">//2.传出参数，希望外部的函数也可以访问改变的变量</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(num) = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">  	<span class="comment">//num=8bit   arr=420bit</span></span><br><span class="line">   	<span class="comment">//那出传进来的是数组还是指针变量，</span></span><br><span class="line">    <span class="comment">//num表现形式是指针，int类型指针，64位系统占8bit，所以传进来的是一个指针变量，</span></span><br><span class="line">  	<span class="comment">//num接收数组首地址</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//表现形式一致性</span></span><br><span class="line">  	<span class="comment">//num arr不一样，表现形式一致，</span></span><br><span class="line">    <span class="comment">//arr + i 通过地址访问arr[i],,num+i可以访问nnum[i]</span></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;num = %p, num + 1 = %p\n&quot;</span>, num, num + <span class="number">1</span>);</span><br><span class="line">  	<span class="comment">//(num + 1) - num = 4 bit</span></span><br><span class="line">    <span class="comment">//(arr + 1) - arr = 4 bit  ===&gt;表现形式一致</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> *n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//*n = 123;</span></span><br><span class="line">  <span class="comment">//等价于</span></span><br><span class="line">  n[<span class="number">0</span>] = <span class="number">1234</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[max_n +<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(arr) = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">  	<span class="comment">//420bit</span></span><br><span class="line">    func(arr);</span><br><span class="line">    </span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, n);<span class="comment">//0</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, n);<span class="comment">//</span></span><br><span class="line">    func1(&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, n);<span class="comment">//*n=123   n[0]=1234</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>二维数组传参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*num)[<span class="number">4</span>])</span> </span>&#123;<span class="comment">// num -&gt; int[4]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr = %p, arr + 1 = %p\n&quot;</span>, num, num + <span class="number">1</span>);<span class="comment">//16bit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> **num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %p, num + 1 = %p\n&quot;</span>, num, num + <span class="number">1</span>);<span class="comment">//8 bit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    func(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr = %p, atrr + 1 = %p\n&quot;</span>, arr, arr + <span class="number">1</span>);<span class="comment">//16bit</span></span><br><span class="line">    <span class="keyword">int</span> **num;<span class="comment">//指针的指针</span></span><br><span class="line"></span><br><span class="line">    func1(num);<span class="comment">//8 bit </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>






<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-11%20%E4%B8%8B%E5%8D%883.26.43.png" alt="截屏2020-12-11 下午3.26.43"></p>
<p>高维数组传参，省略最前面的一个</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-11%20%E4%B8%8B%E5%8D%883.42.42.png" alt="截屏2020-12-11 下午3.42.42"></p>
<h1 id="6-预处理命令"><a href="#6-预处理命令" class="headerlink" title="6.预处理命令"></a>6.预处理命令</h1><p>预处理命令-宏定义</p>
<blockquote>
<p>以<code>#</code>开头的都是C语言的预处理命令</p>
</blockquote>
<h2 id="1-定义符号常量"><a href="#1-定义符号常量" class="headerlink" title="1.定义符号常量"></a>1.定义符号常量</h2><p><code>#define PI 3.14</code></p>
<p><code>#define MAX_N 10000</code></p>
<h2 id="2-定义傻瓜表达式"><a href="#2-定义傻瓜表达式" class="headerlink" title="2.定义傻瓜表达式"></a>2.定义傻瓜表达式</h2><p><code>#define MAX(a,b) (a) &gt; (b) ? (a) : (b)</code></p>
<p><code>#define S(a, b) a  * b</code></p>
<blockquote>
<p><code>==&gt; S(1 + 3, 4 + 2)  == 1 + 4 * 4 + 2</code></p>
<p>​                                                <code>!= (1 + 3) * (4 + 2)</code></p>
</blockquote>
<blockquote>
<p><strong>宏：仅做符号替换，不做计算,只可以定义一行</strong></p>
</blockquote>
<h2 id="3-定义代码段"><a href="#3-定义代码段" class="headerlink" title="3.定义代码段"></a>3.定义代码段</h2><blockquote>
<p><code>#define P(a) &#123;\</code></p>
<p>``printf(“%d\n”, a);`</p>
<p><code>&#125;</code></p>
<p><code>\</code>连接符,分行写,将当前行的代码与下一行的代码连接</p>
</blockquote>
<h2 id="4-预处理命令-预定义宏"><a href="#4-预处理命令-预定义宏" class="headerlink" title="4.预处理命令-预定义宏"></a>4.预处理命令-预定义宏</h2><table>
<thead>
<tr>
<th align="center">宏</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>__DATE__</code></td>
<td>日期：M mm dd yyyy</td>
</tr>
<tr>
<td align="center"><code>__TIME__</code></td>
<td>时间：hh:mm:ss</td>
</tr>
<tr>
<td align="center"><code>__LINE__</code></td>
<td>行号</td>
</tr>
<tr>
<td align="center"><code>__FILE__</code></td>
<td>文件名</td>
</tr>
<tr>
<td align="center"><code>__func__</code></td>
<td>函数名/<strong><em>非标准</em></strong></td>
</tr>
<tr>
<td align="center"><code>__FUNC__</code></td>
<td>函数名/<strong><em>非标准</em></strong></td>
</tr>
<tr>
<td align="center"><code>__PRETTY__FUNCTION__</code></td>
<td>更详细的函数信息/<strong><em>非标准</em></strong></td>
</tr>
</tbody></table>
<p><code>__DATE__  、__TIME__</code>：编译时的日期</p>
<p>非标准：在不同的环境下名字可能不同</p>
<p>可以做：</p>
<p>确定最后一次编译时的时间</p>
<p>行号、文件、文件名：打印日志功能</p>
<h2 id="5-预处理命令-条件是编译"><a href="#5-预处理命令-条件是编译" class="headerlink" title="5.预处理命令-条件是编译"></a>5.预处理命令-条件是编译</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>#ifdef DEBUG</code></td>
<td align="left">是否定义了DEBUG宏，作用于当前宏后面的代码</td>
</tr>
<tr>
<td align="center"><code>#ifdef DEBUG</code></td>
<td align="left">是否没定义DEEBUG宏</td>
</tr>
<tr>
<td align="center"><code>#if MAX_N == 5</code></td>
<td align="left">宏MAX_N是否等于5，MAX_N是宏不是变量，作用时期不一样</td>
</tr>
<tr>
<td align="center"><code>#elif MAX_N == 4</code></td>
<td align="left">否则宏MAX_N是否等于4</td>
</tr>
<tr>
<td align="center"><code>#else</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>#endif</code></td>
<td align="left">//结束宏</td>
</tr>
</tbody></table>
<blockquote>
<p>MAX_N不是变量是宏，</p>
<p>条件式编译解决非标准预定义宏，实现代码剪裁</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%8810.27.57.png" alt="截屏2020-12-14 上午10.27.57"></p>
<blockquote>
<p>C源文件：vim a.cpp</p>
<p>↓（预处理阶段 ： 处理预处理命令，将所有的预处理预处命令进行展开和替换，生成代码）</p>
<p>编译源码 ： 编译期</p>
<p>↓(一个.c/.cpp生成一个对象(.o/.obj)文件，如果有多个.cpp文件会生成多个对象文件)</p>
<p>对象文件： 生成.o/.obj(win)文件</p>
<p>↓链接期：链接过程(所有的对象文件生成一个可执行文件)</p>
<p>可执程序： 默认生成a.out（可被执行的二进制文件）</p>
<p>预处理期 →编译期 →链接期</p>
</blockquote>
<blockquote>
<p>练习1:<strong>实现打印LOG函数，需要输出所在函数及行号等信息</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log(frm ,args...) &#123;\</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s ==&gt; %s : %d]&quot;</span>, __FILE__, __func__, __LINE__);\</span><br><span class="line">    <span class="built_in">printf</span>(frm, #<span class="meta">#args);\</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log(frm, args...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#args将args(任意类型都可)转换为字符串</span></span><br><span class="line"><span class="comment">//如果lon传入的参数为1个，变参列表就为空，编译器会报警告，too manny argument..</span></span><br><span class="line"><span class="comment">//##args连接，如将a和b连接为ab，连接时后面的可以为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define concat(a, b) a##b</span></span><br><span class="line"><span class="comment">//如果去掉##，写ab的意思是将a、b变量替换成字符ab</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf==&gt;hello 古子秋\n&quot;</span>);</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;log==&gt;hello apricity\n&quot;</span>);</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;lon(a)==&gt;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">int</span> abc = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> def = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> abcdef = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    concat(abc, def) = 234;</span></span><br><span class="line"><span class="comment">//    log(&quot;abcdef = %d\n&quot;, abcdef);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><code>g++ -DDEGBUG  32.LOG.c</code></p>
<blockquote>
<p>练习二：<strong>实现没有BUG的MAX宏，需要通过如下测试</strong></p>
<p>1、MAX(2, 3)//3</p>
<p>2、 5 + MAX(2, 3)//8</p>
<p>3、MAX(2, MAX(3, 4))//4</p>
<p>4 、MAX(2, 3 &gt; 4 ? 3 : 4)//4</p>
<p>5、 MAX(a++, 6), a = 7,return 8,a= 8//</p>
</blockquote>
<p><code>gcc -E 28.max.c</code>将所有的预处理命令展开生成代码</p>
<p><code>__typeof(a)</code>获取a的类型</p>
<p>int a   == &gt; typeof(int) </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) a &gt; b ? a : b</span></span><br><span class="line"><span class="comment">//debug1提升优先级</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="comment">//debug2加上括号，防止与后面的内容发生关联</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="comment">//debug3   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) (&#123;\</span></span><br><span class="line">    __typeof(a) _a = (a);\</span><br><span class="line">    __typeof(b) _b = (b);\</span><br><span class="line">    _a &gt; _b ? _a : _b;\</span><br><span class="line">                  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//__typeof(a) 根据值替换为该值的类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(func) &#123;\</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="meta">#func, func);\</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//#func将func里面的内容转换为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    P(MAX(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    P(<span class="number">5</span> + MAX(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    P(MAX(<span class="number">2</span>, MAX(<span class="number">3</span>, <span class="number">4</span>)));</span><br><span class="line"></span><br><span class="line">    P(MAX(<span class="number">2</span>, <span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span>));</span><br><span class="line">    P(MAX(a++, <span class="number">6</span>));</span><br><span class="line">    P(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gcc -E 28.max.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="string">&quot;MAX(2, 3)&quot;</span>, <span class="number">2</span> &gt; <span class="number">3</span> ? <span class="number">2</span> : <span class="number">3</span>);&#125;;</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="string">&quot;5 + MAX(2, 3)&quot;</span>, <span class="number">5</span> + <span class="number">2</span> &gt; <span class="number">3</span> ? <span class="number">2</span> : <span class="number">3</span>);&#125;;</span><br><span class="line">  <span class="comment">//(5 + 2) &gt; 3 ? 2 : 3 = 7 &gt; 3 ? 2 ； 3 = 2  ！！！！！！！</span></span><br><span class="line">	<span class="comment">//5 + (2 &gt; 3 ? 2 : 3) = 5 + 3 = 8</span></span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="string">&quot;MAX(2, MAX(3, 4))&quot;</span>, <span class="number">2</span> &gt; <span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span> ? <span class="number">2</span> : <span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span>);&#125;;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="string">&quot;MAX(2, 3 &gt; 4 ? 3 : 4)&quot;</span>, <span class="number">2</span> &gt; <span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span> ? <span class="number">2</span> : <span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span>);&#125;;</span><br><span class="line">  <span class="comment">//2 &gt; 3 &gt; 4 ? 3 : 4 ? 2 : 3 &gt; 4 ? 3 : 4</span></span><br><span class="line">  <span class="comment">// 0 &gt; 4 ? 3 : 4 ? 2 : 3 &gt; 4 ? 3 : 4</span></span><br><span class="line">  <span class="comment">//4 ? 2 : 3 &gt; 4 ? 3 : 4</span></span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  <span class="comment">//与后面的内容发生关联</span></span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="string">&quot;MAX(a++, 6)&quot;</span>, a++ &gt; <span class="number">6</span> ? a++ : <span class="number">6</span>);&#125;;</span><br><span class="line">  <span class="comment">//a增加了两次  debug，将a++替换出来，</span></span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="string">&quot;a&quot;</span>, a);&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./a.out </span><br><span class="line"></span><br><span class="line">MAX(<span class="number">2</span>, <span class="number">3</span>) = <span class="number">3</span><span class="comment">//√</span></span><br><span class="line">  <span class="comment">//debug1</span></span><br><span class="line"><span class="number">5</span> + MAX(<span class="number">2</span>, <span class="number">3</span>) = <span class="number">2</span><span class="comment">//×   =8</span></span><br><span class="line">   <span class="comment">//debug2</span></span><br><span class="line">MAX(<span class="number">2</span>, MAX(<span class="number">3</span>, <span class="number">4</span>)) = <span class="number">2</span><span class="comment">//× 4</span></span><br><span class="line">MAX(<span class="number">2</span>, <span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span>) = <span class="number">2</span><span class="comment">//× 4</span></span><br><span class="line">  <span class="comment">//debug3</span></span><br><span class="line">MAX(a++, <span class="number">6</span>) = <span class="number">8</span></span><br><span class="line">a = <span class="number">9</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) (&#123;\</span></span><br><span class="line">    __typeof(a) _a = (a);\</span><br><span class="line">    __typeof(b) _b = (b);\</span><br><span class="line">    _a &gt; _b ? _a : _b;\</span><br><span class="line">                  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(func) &#123;\</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="meta">#func, func);\</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    P(MAX(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    P(<span class="number">5</span> + MAX(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    P(MAX(<span class="number">2</span>, MAX(<span class="number">3</span>, <span class="number">4</span>)));</span><br><span class="line"></span><br><span class="line">    P(MAX(<span class="number">2</span>, <span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span>));</span><br><span class="line">    P(MAX(a++, <span class="number">6</span>));</span><br><span class="line">    P(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>debug后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -E <span class="number">28.</span>max.c</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="string">&quot;MAX(2, 3)&quot;</span>, (&#123; __typeof(<span class="number">2</span>) _a = (<span class="number">2</span>); __typeof(<span class="number">3</span>) _b = (<span class="number">3</span>); _a &gt; _b ? _a : _b; &#125;));&#125;;</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="string">&quot;5 + MAX(2, 3)&quot;</span>, <span class="number">5</span> + (&#123; __typeof(<span class="number">2</span>) _a = (<span class="number">2</span>); __typeof(<span class="number">3</span>) _b = (<span class="number">3</span>); _a &gt; _b ? _a : _b; &#125;));&#125;;</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="string">&quot;MAX(2, MAX(3, 4))&quot;</span>, (&#123; __typeof(<span class="number">2</span>) _a = (<span class="number">2</span>); __typeof((&#123; __typeof(<span class="number">3</span>) _a = (<span class="number">3</span>); __typeof(<span class="number">4</span>) _b = (<span class="number">4</span>); _a &gt; _b ? _a : _b; &#125;)) _b = ((&#123; __typeof(<span class="number">3</span>) _a = (<span class="number">3</span>); __typeof(<span class="number">4</span>) _b = (<span class="number">4</span>); _a &gt; _b ? _a : _b; &#125;)); _a &gt; _b ? _a : _b; &#125;));&#125;;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="string">&quot;MAX(2, 3 &gt; 4 ? 3 : 4)&quot;</span>, (&#123; __typeof(<span class="number">2</span>) _a = (<span class="number">2</span>); __typeof(<span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span>) _b = (<span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span>); _a &gt; _b ? _a : _b; &#125;));&#125;;</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="string">&quot;MAX(a++, 6)&quot;</span>, (&#123; __typeof(a++) _a = (a++); __typeof(<span class="number">6</span>) _b = (<span class="number">6</span>); _a &gt; _b ? _a : _b; &#125;));&#125;;</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="string">&quot;a&quot;</span>, a);&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">./a.out </span><br><span class="line">  </span><br><span class="line">MAX(<span class="number">2</span>, <span class="number">3</span>) = <span class="number">3</span></span><br><span class="line"><span class="number">5</span> + MAX(<span class="number">2</span>, <span class="number">3</span>) = <span class="number">8</span></span><br><span class="line">MAX(<span class="number">2</span>, MAX(<span class="number">3</span>, <span class="number">4</span>)) = <span class="number">4</span></span><br><span class="line">MAX(<span class="number">2</span>, <span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span>) = <span class="number">4</span></span><br><span class="line">MAX(a++, <span class="number">6</span>) = <span class="number">7</span></span><br><span class="line">a = <span class="number">8</span></span><br></pre></td></tr></table></figure>










<blockquote>
<p><strong>函数从哪里开始????</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add : %d\n&quot;</span>, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main : %d\n&quot;</span>, __LINE__);</span><br><span class="line">    add(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>add : 5<br>main : 11<br>add : 5</p>
</blockquote>
<blockquote>
<p>默认情况下从main函数开始执行</p>
<p><code>__attribute__((constructor))</code>    </p>
<p>:  预处理命令——宏，给函数增加一个属性，使下面的函数先于主函数执行</p>
</blockquote>
<p>宏嵌套</p>
<p>宏支持嵌套，可能会出现停止展开的现象</p>
<p>输出带颜色的符号</p>
<p>宏的作用：作用时期早，不涉及调用函数时间损耗</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR(a,b) <span class="meta-string">&quot;\033[&quot;</span> #b <span class="meta-string">&quot;m&quot;</span> a <span class="meta-string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="comment">//a本身就是一个字符串</span></span><br><span class="line"><span class="comment">//进行字符串拼接，</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED(a) COLOR(a, 31)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN(a) COLOR(a, 32)</span></span><br><span class="line"><span class="comment">//宏所有的事情只是简单的替换、</span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(RED(<span class="string">&quot;add : %d\n&quot;</span>), __LINE__);<span class="comment">//输出红色</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(GREEN(<span class="string">&quot;main : %d\n&quot;</span>), __LINE__);<span class="comment">//输出绿色</span></span><br><span class="line">    add(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>运行结果：</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-12%20%E4%B8%8B%E5%8D%886.51.55.png" alt="截屏2020-12-12 下午6.51.55"></p>
<blockquote>
<p>泛型宏？</p>
</blockquote>
<h1 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7.字符串"></a>7.字符串</h1><p>定义字符串数组：<code>char str[size];</code></p>
<p>初始化字符数组：</p>
<blockquote>
<p><code>char str[ ] = &quot;hello world&quot;;</code></p>
<p>//str占多少字节：一个字符一个字节，12个（11 + ‘\0’）长度为11</p>
<p><code>char str[size] = &#123;&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;&#125;;</code></p>
</blockquote>
<p>\0 == 0</p>
<p>头文件<code>string.h</code></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>strlen(str)</code></td>
<td>计算字符串长度，以’\0’作为结束符</td>
</tr>
<tr>
<td><code>strcmp(str1, str2);</code></td>
<td>字符串比较，cpmpare</td>
</tr>
<tr>
<td><code>strcpy(dest, src);</code></td>
<td>字符串拷贝copy(假如字符\0丢失)</td>
</tr>
<tr>
<td><code>strncmp(str1, str2, n);</code></td>
<td>安全的字符串比较</td>
</tr>
<tr>
<td><code>strncpy(str1, str2, n);</code></td>
<td>安全的字符串拷贝(拷贝n个)</td>
</tr>
<tr>
<td><code>memcpy(str1, str2, n);</code></td>
<td>内存拷贝(str2拷贝到str1，拷贝n位)</td>
</tr>
<tr>
<td><code>memcmp(str1, str2, n);</code></td>
<td>内存比较</td>
</tr>
<tr>
<td><code>memset(str1, c, n);</code></td>
<td>内存设置(str每一个字节设置为c)</td>
</tr>
</tbody></table>
<blockquote>
<p><code>strcmp(str1, str2);</code>  字符串比较</p>
<p>  <code>strcpy(dest, src);</code>  字符串拷贝</p>
<p><code>strncmp(str1, str2, n);</code>  <code>安全的字符串比较</code> </p>
<p> <code>strncpy(str1, str2, n);</code>  <code>安全的字符串拷贝</code></p>
<p>字符串拷贝</p>
<p>src 拷贝到 str，src字符\0丢失，会一直拷贝</p>
<p>如果’\0’丢失，strncpy会拷贝到第n位</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>sscanf(str1, format, ...);</code></td>
<td>从字符串str1读入内容</td>
</tr>
<tr>
<td><code>sprintf(str1,fromat, ...);</code></td>
<td>将内容输出到str1</td>
</tr>
</tbody></table>
<p><code>fscanf</code>从文件读入</p>
<p><code>fprintf</code>读入到文件</p>
<blockquote>
<p>练习：使用字符串相关操作，计算一个整型16进制表示的位数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(str, <span class="string">&quot;%x&quot;</span>, n);</span><br><span class="line">      <span class="comment">//将n转换为16进制，以字符串的形式读入str</span></span><br><span class="line">      <span class="comment">//%X和%x的区别，%X输出结果为字母时是大写，%x是小写</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s has %lu digits!\n&quot;</span>, str, <span class="built_in">strlen</span>(str));<span class="comment">//输出str长度即为16整型的位数</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<blockquote>
<p>注：</p>
<p>%c读入单个字符，可以读入任何字符，包括空格符和换行，</p>
<p>%s读入一个字符串</p>
<p>%c循环读入的时候发生错误，会将换行和空格符读入</p>
<p>解决办法：以字符数组str[10]的形式以%s读入字符串，输出str[0]即可</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%888.39.08.png" alt="截屏2020-12-14 下午8.39.08"></p>
<h1 id="8-复杂结构体"><a href="#8-复杂结构体" class="headerlink" title="8.复杂结构体"></a>8.复杂结构体</h1><h2 id="1-结构体struct"><a href="#1-结构体struct" class="headerlink" title="1.结构体struct"></a>1.结构体struct</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span><span class="comment">// struct + 结构体名字</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];	<span class="comment">//姓名			20bit</span></span><br><span class="line">	<span class="keyword">int</span> age;				<span class="comment">//年龄			4</span></span><br><span class="line">	<span class="keyword">char</span> gender;		<span class="comment">//性别			1</span></span><br><span class="line">	<span class="keyword">float</span> height;		<span class="comment">//身高			4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<blockquote>
<p>struct person              // 结构体类型，没有结构体的名字时，称为匿名结构体<br>struct person stu;    //结构体类型的变量<br>stu.age;                        //<code>.</code>直接引用，通过类型的变量直接访问用’<code>.</code>‘直接访问<br>stu-&gt;age;                    //<code>-&gt;</code>间接引用，需要通过地址访问地址下某一字段的值，需要间接访问<br>struct person *p;<br>p = &stu;<br>p-&gt;age;</p>
</blockquote>
<blockquote>
<p>//结构体空间划分标准：对齐标准</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">char</span> name[<span class="number">20</span>];	<span class="comment">//姓名			1bit  5块</span></span><br><span class="line">&gt;<span class="keyword">int</span> age;				<span class="comment">//年龄			4			1</span></span><br><span class="line">&gt;<span class="keyword">char</span> gender;		<span class="comment">//性别			1			1	</span></span><br><span class="line">&gt;<span class="keyword">float</span> height;		<span class="comment">//身高			4			1	</span></span><br></pre></td></tr></table></figure>

<p>对齐标准：</p>
<p>按照对齐标准的整数倍开辟空间，</p>
<p>哪个<strong>类型</strong>所占空间字节数大就作为对齐标准，</p>
<p>以4bit为标准开辟空间，</p>
<p>name  20bit    → 开辟连续的五块4bit空间</p>
<p>一共开辟8 * 4 = 32bit</p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">char</span> name[<span class="number">20</span>];	<span class="comment">//姓名			1bit  3块(24 = 20 + 4)</span></span><br><span class="line">&gt;<span class="keyword">int</span> age;				<span class="comment">//年龄			4			0(age用name剩下的4bit)</span></span><br><span class="line">&gt;<span class="keyword">char</span> gender;		<span class="comment">//性别			1			1	</span></span><br><span class="line">&gt;<span class="keyword">double</span> height;	<span class="comment">//身高			8			1	</span></span><br></pre></td></tr></table></figure>

<p>5 * 8 = 40bit</p>
</blockquote>
<p>对齐标准不是固定的</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">node1</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> a;		<span class="comment">//1（4bit（使用了1bit剩下3bit））</span></span><br><span class="line"><span class="keyword">char</span> b;		<span class="comment">//0(使用开辟a时剩下的1bit)</span></span><br><span class="line"><span class="keyword">int</span> c;		<span class="comment">//1</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">node2</span> &#123;</span></span><br><span class="line"> <span class="keyword">char</span> a;			<span class="comment">//1</span></span><br><span class="line"> <span class="keyword">int</span> c;			<span class="comment">//1</span></span><br><span class="line"> <span class="keyword">char</span> b;			<span class="comment">//1</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>node1   8bit</p>
<p>node2    12bit</p>
<p>划分空间时从上至下依次划分空间</p>
<p>==&gt;相同类型的字段放在一起排布，可以节省空间</p>
</blockquote>
<p>宏：强制改变对齐方式</p>
<p>对齐的作用，方便访问</p>
<h2 id="2-共用体-联合体"><a href="#2-共用体-联合体" class="headerlink" title="2.共用体/联合体"></a>2.共用体/联合体</h2><blockquote>
<p>共用体：当前公用体内的各个字段共用一片存储单元</p>
</blockquote>
<blockquote>
<p>共用体的大小就是共用体内所有字段中所占空间最大的字段</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">reginster</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">char</span> byte1;	<span class="comment">//1bit</span></span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">char</span> byte2;	</span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">char</span> byte3;</span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">char</span> byte4;</span><br><span class="line">		&#125; bytes;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> number;				<span class="comment">//4bit</span></span><br><span class="line">&#125;																<span class="comment">//共用体占4bit</span></span><br></pre></td></tr></table></figure>


<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-18%20%E4%B8%8A%E5%8D%881.47.10.png" alt="截屏2020-12-18 上午1.47.10"></p>
<p>找占空间最大的作为整个共用体的标准</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-16%20%E4%B8%8B%E5%8D%8811.47.50.png" alt="截屏2020-12-16 下午11.47.50"></p>
<p>改变bytes的值，number也会改变</p>
<p>共用体的作用</p>
<p>使用共用体实现ip转整数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">IP</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> a1;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> a2;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> a3;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> a4;</span><br><span class="line">    &#125; ip;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">IP</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str)) &#123;<span class="comment">//输入</span></span><br><span class="line">        <span class="built_in">sscanf</span>(str, <span class="string">&quot;%d.%d.%d.%d&quot;</span>, arr, arr + <span class="number">1</span>, arr + <span class="number">2</span>, arr + <span class="number">3</span>);</span><br><span class="line">      <span class="comment">//将str中的字符串以%d格式读如到arr中</span></span><br><span class="line">        p.ip.a1 = arr[<span class="number">0</span>];</span><br><span class="line">        p.ip.a2 = arr[<span class="number">1</span>];</span><br><span class="line">        p.ip.a3 = arr[<span class="number">2</span>];</span><br><span class="line">        p.ip.a4 = arr[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, p.num);</span><br><span class="line">      <span class="comment">//由于是共用体，四个unsigned char类型和unsigned int类型占空间一样</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="number">16820416</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line"><span class="number">33597632</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-18%20%E4%B8%8A%E5%8D%881.47.24.png" alt="截屏2020-12-18 上午1.47.24"></p>
<blockquote>
<p>大端小端</p>
<p>小端机：数字低位→存储在低地址位   </p>
<p>大端机：数字低位→存储在高地址位   </p>
<p>内存地址以字节为单位编址，</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-17%20%E4%B8%8A%E5%8D%8812.14.10.png" alt="截屏2020-12-17 上午12.14.10"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-17%20%E4%B8%8A%E5%8D%8812.15.56.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">IP</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> a1;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> a2;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> a3;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> a4;</span><br><span class="line">    &#125; ip;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">IP</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str)) &#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(str, <span class="string">&quot;%d.%d.%d.%d&quot;</span>, arr, arr + <span class="number">1</span>, arr + <span class="number">2</span>, arr + <span class="number">3</span>);</span><br><span class="line">        p.ip.a1 = arr[<span class="number">3</span>];</span><br><span class="line">        p.ip.a2 = arr[<span class="number">2</span>];</span><br><span class="line">        p.ip.a3 = arr[<span class="number">1</span>];</span><br><span class="line">        p.ip.a4 = arr[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">//反向存储，小端机数字低位→存储在低地址位   </span></span><br><span class="line">      <span class="comment">//将ip地址首位存到低地址位上</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, p.num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="number">3232235521</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line"><span class="number">3232235522</span></span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断大端机还是小端机</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_little</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="keyword">char</span> *)(&amp;num))[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">//将num强制转换为char类型，取其低位地址，如果为1则为小端机</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, is_little());</span><br><span class="line">  <span class="comment">//返回1，小端机,返回0大端机</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="9-指针"><a href="#9-指针" class="headerlink" title="9.指针"></a>9.指针</h1><h2 id="0-指针含义"><a href="#0-指针含义" class="headerlink" title="0.指针含义"></a>0.指针含义</h2><blockquote>
<p>指针：变量的地址</p>
</blockquote>
<blockquote>
<p>64位操作系统指针占8字节，32问操作系统占4字节</p>
</blockquote>
<blockquote>
<p>指针变量也是变量：是变量就可以存储值，指针变量存储地址，变量本身也有地址</p>
<p>指向整型的指针变量占8个字节</p>
<p>是变量就会占用空间</p>
<p>变量的地址为字节中最小的地址</p>
<p><code>int  a;</code></p>
<p><code>int *p = &amp;a; </code></p>
<p><code>*</code>取值操作，*p取地址里面的值</p>
<p>p是指针变量</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-17%20%E4%B8%8A%E5%8D%881.33.00.png" alt="截屏2020-12-17 上午1.33.00"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-17%20%E4%B8%8A%E5%8D%881.34.00.png" alt="截屏2020-12-17 上午1.34.00"></p>
<p>是变量：变量的作用是用来存储值的，指针变量能接收到的值是地址</p>
<p>变量本身有地址，指针变量本身也有地址。</p>
<p>指向指针的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> **q;<span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">stu</span>;</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = stu;</span><br><span class="line"><span class="comment">//p+1向后跳跃了一个类型的字节</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>








<h2 id="2-指针等价形式转换"><a href="#2-指针等价形式转换" class="headerlink" title="2.指针等价形式转换"></a>2.指针等价形式转换</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-20%20%E4%B8%8B%E5%8D%884.23.27.png" alt="截屏2020-12-20 下午4.23.27"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">a</span>[2], *<span class="title">p</span> =</span> a;</span><br><span class="line">    a[<span class="number">0</span>].x = <span class="number">3</span>;a[<span class="number">0</span>].y = <span class="number">3</span>;</span><br><span class="line">    a[<span class="number">1</span>].x = <span class="number">5</span>;a[<span class="number">1</span>].y = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">1</span>].x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*(a+<span class="number">1</span>)).x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*(&amp;(a[<span class="number">0</span>]) + <span class="number">1</span>)).x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (a + <span class="number">1</span>)-&gt;x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*(a + <span class="number">1</span>)).x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*(&amp;a[<span class="number">0</span>] + <span class="number">1</span>)).x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (p + <span class="number">1</span>)-&gt;x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*(p + <span class="number">1</span>)).x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*(p+<span class="number">1</span>)).x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*(&amp;(*p) + <span class="number">1</span>)).x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//地址-&gt;变量</span></span><br><span class="line">  <span class="comment">//变量.变量</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-函数指针"><a href="#2-函数指针" class="headerlink" title="2.函数指针"></a>2.函数指针</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-20%20%E4%B8%8B%E5%8D%885.24.14.png" alt="截屏2020-12-20 下午5.24.14"></p>
<p>函数指针变量</p>
<p><code>int (*add)(int, int)</code></p>
<p>函数指针类型</p>
<p><code>typedef int (*add)(int, int)</code></p>
<h2 id="3-空指针计算相对地址偏移量"><a href="#3-空指针计算相对地址偏移量" class="headerlink" title="3.空指针计算相对地址偏移量"></a>3.空指针计算相对地址偏移量</h2><blockquote>
<p>结构体类型和变量的相对地址偏移量计算</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offset(T, a) (&#123;\</span></span><br><span class="line">    T temp;\</span><br><span class="line">    (<span class="keyword">char</span> *)(&amp;temp.a) - (<span class="keyword">char</span> *)(&amp;temp);\</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//将地址转换成char * 类型方便做计算(因为类型不一样不可以做计算)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offset1(T, a) (long)(&amp;(((T *)(NULL))-&gt;a))</span></span><br><span class="line"><span class="comment">//不定义变量，相当于temp不存在（相当于temp）,地址从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *env[])</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0x0626364</span>;</span><br><span class="line">  <span class="comment">//0 62  63 64</span></span><br><span class="line">  <span class="comment">//64 63 62 0/小端机</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="keyword">char</span> *)(&amp;num));</span><br><span class="line">  <span class="comment">//dcb        </span></span><br><span class="line">  <span class="comment">//98 b,99 c, 100 d</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//结构体类型和变量的相对地址偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, offset(struct Data, a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, offset(struct Data, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, offset(struct Data, c));</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="4-typedef用法"><a href="#4-typedef用法" class="headerlink" title="4.typedef用法"></a>4.typedef用法</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-20%20%E4%B8%8B%E5%8D%885.33.24.png" alt="截屏2020-12-20 下午5.33.24"></p>
<p>func函数指针类型</p>
<h2 id="5-typdef和define别名的区别"><a href="#5-typdef和define别名的区别" class="headerlink" title="5.typdef和define别名的区别"></a>5.typdef和define别名的区别</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ppchar char *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * pchar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *env[])</span> </span>&#123;</span><br><span class="line"> 		pchar p1,p2;</span><br><span class="line">    ppchar p3,p4;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1 = %lu, p2 = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(p1), <span class="keyword">sizeof</span>(p2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p3 = %lu, p4 = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(p3), <span class="keyword">sizeof</span>(p4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>p1 = 8, p2 = 8<br>p3 = 8, p4 = 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pchar p1,p2;</span><br><span class="line"> <span class="keyword">char</span> * p3,p4;==&gt;<span class="keyword">char</span> * p3;<span class="keyword">char</span> p4;</span><br></pre></td></tr></table></figure>

<p>==&gt;define 只是简单是替换</p>
<p>typedef是重命名</p>
</blockquote>
<h1 id="10-main函数"><a href="#10-main函数" class="headerlink" title="10.main函数"></a>10.main函数</h1><h2 id="1-main函数"><a href="#1-main函数" class="headerlink" title="1.main函数"></a>1.main函数</h2><p>系统调用main函数</p>
<p>mian 参数 参数个数，参数，环境变量</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-20%20%E4%B8%8B%E5%8D%885.53.10.png" alt="截屏2020-12-20 下午5.53.10"></p>
<h2 id="2-main函数参数"><a href="#2-main函数参数" class="headerlink" title="2.main函数参数"></a>2.main函数参数</h2><blockquote>
<p>argc:参数个数</p>
<p>argv：传入的参数以字符串的形式存储</p>
<p>env:环境变量，存储环境的变量的字符串，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./a.out hello world <span class="string">&quot;hello world&quot;</span></span><br><span class="line">agrc = <span class="number">3</span></span><br><span class="line">argv[<span class="number">0</span>] = ./a.out</span><br><span class="line">argv[<span class="number">1</span>] = hello</span><br><span class="line">argv[<span class="number">2</span>] = world</span><br><span class="line">argv[<span class="number">3</span>] = hello world</span><br></pre></td></tr></table></figure>




</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//__attribute__((constructor))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *env[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; env[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(env[i], <span class="string">&quot;USER=&quot;</span>, <span class="number">5</span>)) &#123;<span class="comment">//判断前5个字符串是不是USER=</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(env[i] + <span class="number">5</span>, <span class="string">&quot;apricity&quot;</span>)) &#123;<span class="comment">//对比，相减等于0</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;welcome apricity...!\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;you are not the user! please exit\n&quot;</span>);</span><br><span class="line">              <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;env[%d] = %s\n&quot;</span>, i, env[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *env[])</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"> 		output(argc, argv, env);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">./a.out hello world <span class="string">&quot;hello world&quot;</span></span><br><span class="line">argc = <span class="number">4</span></span><br><span class="line">argv[<span class="number">0</span>] = ./a.out</span><br><span class="line">argv[<span class="number">1</span>] = hello</span><br><span class="line">argv[<span class="number">2</span>] = world</span><br><span class="line">argv[<span class="number">3</span>] = hello world</span><br><span class="line">env[<span class="number">0</span>] = LC_TERMINAL_VERSION=<span class="number">3.4</span><span class="number">.3</span></span><br><span class="line">env[<span class="number">1</span>] = LANG=en_US.UTF<span class="number">-8</span></span><br><span class="line">env[<span class="number">2</span>] = LC_TERMINAL=iTerm2</span><br><span class="line">welcome apricity...!</span><br><span class="line">env[<span class="number">3</span>] = USER=apricity</span><br><span class="line">env[<span class="number">4</span>] = LOGNAME=apricity</span><br><span class="line">env[<span class="number">5</span>] = HOME=/home/apricity</span><br><span class="line">env[<span class="number">6</span>] = PATH=/home/apricity/.autojump/bin:/home/apricity/.autojump/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">env[<span class="number">7</span>] = MAIL=/var/mail/apricity</span><br><span class="line"> </span><br></pre></td></tr></table></figure>




<h1 id="11-工程项目开发"><a href="#11-工程项目开发" class="headerlink" title="11.工程项目开发"></a>11.工程项目开发</h1><h1 id="错误总结"><a href="#错误总结" class="headerlink" title="错误总结"></a>错误总结</h1><h2 id="1-collect2-error-ld-returned-1-exit-status"><a href="#1-collect2-error-ld-returned-1-exit-status" class="headerlink" title="1.collect2: error: ld returned 1 exit status "></a>1.<code>collect2: error: ld returned 1 exit status </code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/tmp/ccgbUZFw.o: In function `main<span class="number">&#x27;</span>:</span><br><span class="line"><span class="number">21.</span>my_sqrt.c:(.text+<span class="number">0x12c</span>): undefined reference to `<span class="built_in">sqrt</span><span class="number">&#x27;</span></span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>


<p>编译的时候使用 <code>gcc a.c -lm</code></p>
<h2 id="2-stack-smashing-detected-terminated"><a href="#2-stack-smashing-detected-terminated" class="headerlink" title="2.stack smashing detected ***:  terminated"></a>2.stack smashing detected ***: <unknown> terminated</h2><p>数组越界</p>
<h2 id="3-warning-backslash-and-newline-separated-by-space"><a href="#3-warning-backslash-and-newline-separated-by-space" class="headerlink" title="3.warning: backslash and newline separated by space"></a>3.warning: backslash and newline separated by space</h2><p>将\后面的空格去掉就可以了.</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2020/11/18/02.Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>2020.11.18-2020.12.20</p>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-vim的基本使用"><a href="#1-vim的基本使用" class="headerlink" title="1.vim的基本使用"></a>1.<code>vim</code>的基本使用</h2><blockquote>
<p><code>pwd</code>        (print working directory)</p>
<p><code>$0whoamiaptapt </code></p>
<p><code>updateapt</code> </p>
<p><code>upgrade</code><br><code>apt-cache search XXX</code>        (搜索XXX软件)<br><code>apt remove XXX</code>        (卸载XXX软件)<br><code>dpkg -i xxx.dep</code>        (使用dpkg程序安装xxx.dep)(安装 = install -&gt; -i)<br><code>dpkg -r</code>         (使用dpkg卸载软件)(卸载 = remove -&gt; -r)</p>
</blockquote>
<a id="more"></a>



<h2 id="2-Terminal"><a href="#2-Terminal" class="headerlink" title="2.Terminal"></a>2.<code>Terminal</code></h2><p>终端<code>( terminal )= tty </code>(Teletypewriter， 电传打印机)，作用是提供一个命令的输入输出环 境，在<code>linux</code>操作系统下使用组合键 <code>ctrl + alt + T</code> 打开的就是终端，可以认为 <code>terminal</code> 和 <code>tty </code>是 同义词。</p>
<h2 id="3-shell"><a href="#3-shell" class="headerlink" title="3.shell"></a>3.<code>shell</code></h2><p><code>shell</code>是一种人机交互的接口。 <code>shell</code> 有壳的意思，是指 “提供使用者使用界面” 的软件，是一种 命令解析器,是<code>Linux</code>内核的一个壳，负责外界与Linux内核的交互。</p>
<blockquote>
<p><code>windows</code> 的cmd就是一种<code>shell</code>。所以 <code>shell</code> 并不只是指命令语言<code>-Bash/Zsh</code>。 其实GUI本身也是一种<code>shell</code>.</p>
</blockquote>
<p>用户在 <code>shell</code> 中提交命令， <code>shell</code> 负责接收用户的命令，并扮演命令解析器的⻆色。 </p>
<p>当你打开一个 <code>Terminal</code> 时，操作系统会将 Terminal 和 Shell 关联起来，当我们在 <code>Terminal</code> 中输入命令的时候， <code>Shell</code> 就负责解释命令。</p>
<h2 id="3、命令"><a href="#3、命令" class="headerlink" title="3、命令"></a>3、命令</h2><blockquote>
<p>命令是人和计算机交互的基本单位，人使用命令 将要做什么事传达给计算机，计算机做出解 析，并做出回应。</p>
</blockquote>
<p><strong>命令也有自己的语法结构</strong>:</p>
<p>和人说话一样，命令的主要结构也可以看做为主谓宾的简单句和复杂句，在命令中，省略主语</p>
<blockquote>
<p>举个例子</p>
</blockquote>
<p><code>cp(谓语动词) fileA(宾语) fileB(宾语)</code></p>
<p> <code>cp(谓语动词) -ar(方式状语) fileA(宾语) fileB(宾语)</code></p>
<p><strong>命令细节</strong></p>
<blockquote>
<p>Linux命令由以下几个部分组成: 命令名 ， 分隔符 ， 选项 和 操作对象 组成。 </p>
</blockquote>
<p><strong>命令名</strong></p>
<p>命令名标识了命令的功能，如cp，rm，mv，rename，fdisk等等，都能很轻易的看出该命令的功能， 还有一些命令，有二级子命令，如apt-get install | remove，install和remove就是apt-get的子命令。</p>
<p><strong>分隔符</strong></p>
<p>  分隔符通常为空格，连续的多个空格会被视为一个空格。</p>
<blockquote>
<p>一些特殊的符号也属于分隔符，例如管道<code>|</code>，重定向<code>&gt;,&lt;&lt;,&lt;,&gt;&gt;,</code>后台运行<code>&amp;</code>，序列执行<code>&amp;&amp;```、;</code>都 是特殊的分隔符，在使用这些特殊符号的时候，不需要额外加空格，但为了使命令更易读，通常会 加上空格。</p>
</blockquote>
<p><strong>选项</strong></p>
<ul>
<li>命令的选项通常用 <code>-</code> 连接，通常为一个字母，是选项的首字母。大多数命令都可以使用 <code>-h</code> 来 查看该命令的帮助。</li>
<li>命令的选项也可以使用 <code>--</code> 来引导，接的是选项的全程，效果与—连接单个字母是一样的。</li>
</ul>
<p><strong>操作对象</strong></p>
<p>   操作对象为该命令动作的承受着。</p>
<p><strong>格式约定</strong></p>
<ul>
<li>使用 <code>[]</code> 来标记可以选择的选项</li>
<li> 使用 <code>|</code> 来表示不能同时使用的参数 </li>
<li>选项通常紧跟命令名，当然，在很多时候我们可以省略命令的选项而使用默认参数</li>
</ul>
<h2 id="4-程序与进程"><a href="#4-程序与进程" class="headerlink" title="4.程序与进程"></a><strong>4.程序与进程</strong></h2><blockquote>
<p>那么什么是程序呢?</p>
<blockquote>
<p> 计算机程序是指一组指示计算机执行动作或做出判断的指令，通常用某种程序设计语言<br>编写，运行于某种目标体系结构上。</p>
</blockquote>
</blockquote>
<blockquote>
<p>什么又是进程呢?</p>
<blockquote>
<p>进程是程序在内存中的镜像。</p>
</blockquote>
</blockquote>
<h2 id="5-路径"><a href="#5-路径" class="headerlink" title="5.路径"></a>5.路径</h2><p><strong>绝对路径</strong></p>
<p>​    绝对路径的起始点为根目录 <code>/</code> ,例如 <code>/usr/bin/cp</code> 就是一个绝对路径。</p>
<p><strong>相对路径</strong> </p>
<p>​    相对路径的起始点为当前路径 <code>.</code> ，假如用户当前目录为 <code>/home/apricity/</code> ，那么同样的文件 <code>cp</code> ,其 相对路径为 <code>../../usr/bin/cp</code> 。</p>
<p><strong>远程路径</strong></p>
<blockquote>
<p>在很多时候，我们会需要访问本机之外的资源，这个时候远程路径就有了用武之地了。</p>
</blockquote>
<p>远程路径的一般表示方法为: <code>协议://用户名:密码@位置/路径:端口</code> 比如: <a href="http://baidu.com/">http://baidu.com</a></p>
<p>​    <code>ftp://user:passwd@ftp.baidu.com:21</code><br>  远程路径根据应用的不同，具体表示方法和所需要的参数都不太一致，从以上两个远程路径就可以<br>看出。</p>
<p><strong>路径相关的命令</strong></p>
<blockquote>
<p><code>cd</code> #change directory</p>
</blockquote>
<blockquote>
<p><code>ls</code> #list<br> <code>pwd</code> #print working directory</p>
</blockquote>
<p><strong>特殊路径</strong></p>
<blockquote>
<p><code>~</code> 家目录<br> <code>-</code> 上次工作目录</p>
</blockquote>
<h2 id="6-软件"><a href="#6-软件" class="headerlink" title="6.软件"></a><strong>6.软件</strong></h2><p>通常，一个软件包含的内容会分别被拷⻉到同级别的 <code>bin lib share</code> 和 <code>/etc</code> 目录下。</p>
<blockquote>
<p><code>bin</code> 存放程序的可执行文件。在系统环境变量中将该路径添加进去，就可以直接执行程序. </p>
<p><code>lib</code> 库文件集中存放，方便共享。<br> <code>share</code> 存放程序需要的其他资源.<br> <code>/etc</code> 配置文件存放路径，大部分的程序的配置文件都可以在这个路径下找到</p>
</blockquote>
<h2 id="7-配置方式"><a href="#7-配置方式" class="headerlink" title="7.配置方式"></a>7.<strong>配置方式</strong></h2><blockquote>
<p><code>/etc/network/interface</code> 文件为Ubuntu的网络配置文件，通过修改该文件，并重启网络， 就可以实现网络的配置工作。</p>
</blockquote>
<p>直接使用ifconfig命令来直接修改网络配置:</p>
<p><code>ifconfig eth0 172.17.211.175</code></p>
<p>这条命令将把设备<code> eth0</code> 的<code>ip</code>地址更新为 <code>172.17.211.175</code> 。</p>
<h2 id="8-隐藏文件"><a href="#8-隐藏文件" class="headerlink" title="8.隐藏文件"></a>8.隐藏文件</h2><p>Linux的隐藏文件都是以<code> .</code> 开头的，也就是说所有以 <code>.</code> 开头的文件都会被系统识别为隐藏文件。</p>
<p>使用<code> ls</code> 命令添加 <code>a</code> 选项，就可以显示隐藏文件。 这里有两个特殊的目录 <code>.</code> 和<code> ..</code> ,分别为当前目录和父目录。</p>
<h2 id="9-文件类型"><a href="#9-文件类型" class="headerlink" title="9.文件类型"></a>9.文件类型</h2><p>使用 <code>ll</code> 命令可以查看当前文件夹下所有文件的详细信息。</p>
<blockquote>
<p><code>ll</code> 等效于 <code>ls -al</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apricity@qiu ~ % ll                                                                                                                                                           [0]</span><br><span class="line">total 40K</span><br><span class="line">-rw-rw-r-- 1 apricity apricity    0 Nov 22 16:39 aaa.txt</span><br><span class="line">drwxrwxr-x 7 apricity apricity 4.0K Nov 20 19:08 autojump</span><br><span class="line">drwxrwxr-x 2 apricity apricity 4.0K Nov 25 11:34 C语言</span><br><span class="line">drwxrwxr-x 3 apricity apricity 4.0K Nov 19 14:42 guziqiu</span><br><span class="line">drwxrwxr-x 2 apricity apricity 4.0K Nov 20 19:33 haizei_oj</span><br><span class="line">-rw-rw-r-- 1 apricity apricity 8.3K May 25  2020 install_zsh.sh</span><br><span class="line">drwxrwxr-x 4 apricity apricity 4.0K Nov 22 14:10 linux基础</span><br><span class="line">drwxrwxr-x 2 apricity apricity 4.0K Nov 22 20:46 <span class="built_in">test</span></span><br><span class="line">-rw-rw-r-- 1 apricity apricity    0 Nov 12 01:14 update</span><br><span class="line">drwxrwxr-x 7 apricity apricity 4.0K Nov 12 00:49 zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>
<p>​        <strong>该命令主要输出了七列内容，分别为:权限、文件数、所属用户、所属群组、文件大小、常⻅日</strong><br><strong>期、文件名。</strong><br>          <strong>第一列权限，主要可以分为以下四个部分:文件类型，所属用户权限，所属组权限，其他用户权</strong><br><strong>限</strong>。</p>
<blockquote>
<p>以刚才执行<code>ll</code>的结果中的 <code>../</code> 目录的权限为例:</p>
<table>
<thead>
<tr>
<th align="center">文件类型</th>
<th align="center">所属用户权限</th>
<th align="center">所属群组权限</th>
<th align="center">其他用户权限</th>
</tr>
</thead>
<tbody><tr>
<td align="center">d</td>
<td align="center">rwx</td>
<td align="center">r-x</td>
<td align="center">r-x</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li><p>第一部分文件类型为 d ,代表这个文件是一个目录(directory)，目录是一种特殊的文件; </p>
</li>
<li><p>第二部分所属用户权限为 rwx ，代表该文件拥有者拥有可读(read),可写(write),可执行(execute) 的权限;</p>
</li>
<li><p>第三部分所属群组权限为 r-x ，代表与该文件拥有者在一个群组的用户具有可读，可执行的权 限，在这里<code> -</code> 顶替了<code>w</code>的位置，代表没有写权限; </p>
</li>
<li><p>第四部分其他用户权限同样为可读，可执行。</p>
</li>
</ul>
<blockquote>
<p><code>rwx</code> 的顺序是固定的!</p>
</blockquote>
<p>Linux中的文件类型除了目录 d 之外，总共有7种文件类型，</p>
<ul>
<li><code>-</code> regular file 普通文件</li>
<li><code>d</code> directory目录 </li>
<li><code>l</code> link链接</li>
<li><code>b</code>  block 块设备 存储数据以供系统存取的接口设备，也就是硬盘</li>
<li><code>c</code>   character 字符设备 串口设备，键盘，鼠标等</li>
<li><code>s</code> socket套接字<code>//应用层和底层的接口</code></li>
<li><code>p</code> pipe管道</li>
</ul>
<p>对于普通文件又可以分为以下三种:</p>
<ul>
<li><p>纯文本文件</p>
<p>​        纯文本文件使用<code>ASCII</code>编码，这是<code>Linux</code>系统中最常⻅的一种文件类型，之所以成为纯文本文件，是因 为这种类型的文件是我们可以直接读取的内容，在<code>Linux</code>，几乎所有的配置文件都属于这种类型。</p>
</li>
<li><p>二进制文件 </p>
<p>​        二进制文件是系统中的可执行文件(不包括脚本)，计算机只能认识并执行二进制文件。二进制文件不能使用 <code>cat</code> 等命令直接读出。 </p>
</li>
<li><p>数据格式的文件</p>
<p>在一些程序运行过程中，需要读取特定格式的文件，这种文件被称为数据文件(data file)。这种文件 通常也不能使用<code>cat</code>命令读出。 例如: <code>/var/log/wtmp</code> 文件。</p>
</li>
</ul>
<blockquote>
<p>使用<code>ll</code>命令查看文件，可以看到该文件为普通文件   <code>ll</code> == <code>ls -l</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ll /var/<span class="built_in">log</span>/wtmp</span><br><span class="line"></span><br><span class="line"> -rw-rw-r-- 1 root utmp 8832 Apr 27 11:50 /var/<span class="built_in">log</span>/wtmp</span><br></pre></td></tr></table></figure>

<p>使用file命令查看问价详情，返回为 <code>data</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;file /var/<span class="built_in">log</span>/wtmp</span><br><span class="line">&gt;/var/<span class="built_in">log</span>/wtmp: data</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="10-文件权限"><a href="#10-文件权限" class="headerlink" title="10.文件权限"></a>10.文件权限</h2><p>​        </p>
<blockquote>
<p>文件的权限包含三组( <code>u</code> 用户，<code> g</code> 群组，<code> o</code> 其他用户)，每一组又都包含 三组具体的权限(<code>r</code>读，<code>w</code>写，<code>x</code>执行)。    </p>
</blockquote>
<p>​            对于文件权限，我们也可以用下面的方式来表示:</p>
<table>
<thead>
<tr>
<th align="center">r</th>
<th align="center">w</th>
<th align="center">x</th>
<th align="center">r</th>
<th align="center">w</th>
<th align="center">x</th>
<th align="center">r</th>
<th align="center">w</th>
<th align="center">x</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(2^2) 4</td>
<td align="center">(2^1) 2</td>
<td align="center">(2^0) 1</td>
<td align="center">(2^2) 4</td>
<td align="center">(2^1) 2</td>
<td align="center">(2^0) 1</td>
<td align="center">(2^2) 4</td>
<td align="center">(2^1) 2</td>
<td align="center">(2^0) 1</td>
</tr>
</tbody></table>
<p>也就是权限的每一组都由三个十进制的数字表示，该组的的权限就可以简单的用着三个十进制的数</p>
<p>字相加得到。</p>
<blockquote>
<p>一个权限为<code> rwxr-xr-x</code> 的文件，则它的权限可以使用 <code>755</code> 来表示。</p>
</blockquote>
<h2 id="11-与文件权限有关的命令"><a href="#11-与文件权限有关的命令" class="headerlink" title="11.与文件权限有关的命令"></a>11.<strong>与文件权限有关的命令</strong></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod <span class="comment">#更改文件权限 </span></span><br><span class="line">chown <span class="comment">#更改文件所属用户 </span></span><br><span class="line">chgrp <span class="comment">#更改文件所属组</span></span><br></pre></td></tr></table></figure>


<ul>
<li>chmod 的用法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod a+x file <span class="comment">#给file文件的ugo都赋予执行的权限</span></span><br><span class="line">chmod o-x file <span class="comment">#将file文件o减去执行权限</span></span><br><span class="line">chmod 755 file <span class="comment">#设置file文件的权限为rwxr-xr-x</span></span><br><span class="line">chmod u=rwx,go=rx file <span class="comment">#设置file文件的权限为rwxr-xr-x</span></span><br></pre></td></tr></table></figure>


<ul>
<li>chown 的用法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown guziqiu:apricity file <span class="comment">#修改file的所属用户是guziqiu,所属组为apricity</span></span><br><span class="line"> chown -R guziqiu:apricity directory </span><br><span class="line"> <span class="comment">#修改目录directory及目录下的所有文件的所属用户是guziqiu， 所属组为zpricity</span></span><br><span class="line"> chown guziqiu file <span class="comment">#修改file的所属用户为guziqiu</span></span><br></pre></td></tr></table></figure>


<ul>
<li>chgrp 的用法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chgrp root file <span class="comment">#修改file所属的组为root</span></span><br></pre></td></tr></table></figure>


<h2 id="12-用户"><a href="#12-用户" class="headerlink" title="12.用户"></a>12.用户</h2><blockquote>
<p><code>Linux</code>有两类用户,分别是 <code>root</code> 和 <code>普通用户</code> 。</p>
</blockquote>
<ul>
<li><p>超级管理员: <code>root</code></p>
<p><code>root</code> 拥有系统的完全控制权，所以在使用<code>Linux</code>系统的时候，需要慎重使用<code>root</code>用户，更多的自由 与权限同样也意味着更大的⻛险。</p>
</li>
<li><p>普通用户</p>
<p>普通用户拥有的权限就没有 <code>root</code> 用户那么大了，它只能做系统允许做的事。普通用户可以执行大 部分的命令，但是<code>root</code>专有的命令却不能执行。</p>
</li>
</ul>
<p>可以使用 su 命令来切换用户:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:~$ whoami</span><br><span class="line">guziqiu</span><br><span class="line">:~$ su - root</span><br><span class="line">Password:</span><br><span class="line">:~<span class="comment"># whoami</span></span><br><span class="line">root</span><br><span class="line">:~<span class="comment"># su - guziqiu</span></span><br><span class="line">:~$ whoami</span><br><span class="line">guziqiu</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>su - guziqiu</code></p>
<p><code>-</code>代表一次完整的重新登录</p>
</blockquote>
<p>退出</p>
<p><code>control +D</code></p>
<p><code>exit </code></p>
<p><code>logout</code></p>
<h2 id="13-其他命令"><a href="#13-其他命令" class="headerlink" title="13.其他命令"></a>13.其他命令</h2><p><code>id</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apricity@qiu ~ % id                                                                                                                                                 [0]</span><br><span class="line">uid=1000(apricity) gid=1000(apricity) groups=1000(apricity),27(sudo)</span><br><span class="line">//用户，组，其他组</span><br></pre></td></tr></table></figure>




<p>1.火车动画</p>
<p>​    <code>sl</code></p>
<p>2.<code>apt-build moo</code> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-build moo </span><br><span class="line"></span><br><span class="line">         (__)    ~</span><br><span class="line">         (oo)   /</span><br><span class="line">     _____\/___/</span><br><span class="line">    /  /\ / /</span><br><span class="line">   ~  /  * /</span><br><span class="line">     / ___/</span><br><span class="line">*----/\</span><br><span class="line">    /  \</span><br><span class="line">   /   /</span><br><span class="line">  ~    ~</span><br><span class="line">...<span class="string">&quot;Have you danced today? Discow!&quot;</span>...</span><br></pre></td></tr></table></figure>


<p>3.cowsay</p>
<p>用ASCII字符打印牛，羊等动物，还有个cowthink，这个是奶牛想，那个是奶牛说，哈哈，差不多</p>
<p><code>sudo apt-get install cowsay</code></p>
<p><code>cowsay -f tux &quot;坑爹啊&quot;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">________</span><br><span class="line">&lt; 坑爹啊 &gt;</span><br><span class="line"> --------</span><br><span class="line">   \</span><br><span class="line">    \</span><br><span class="line">        .--.</span><br><span class="line">       |o_o |</span><br><span class="line">       |:_/ |</span><br><span class="line">      //   \ \</span><br><span class="line">     (|     | )</span><br><span class="line">    /&#x27;\_   _/`\</span><br><span class="line">    \___)=(___/</span><br></pre></td></tr></table></figure>


<ol start="4">
<li><code>cmatrix</code> 命令</li>
</ol>
<p>这个很酷！《黑客帝国》那种矩阵风格的动画效果</p>
<p> <code>sudo apt-get install cmatrix</code></p>
<p><code>cmatrix</code></p>
<p><code>q</code>退出</p>
<h1 id="二、命令系统"><a href="#二、命令系统" class="headerlink" title="二、命令系统"></a>二、命令系统</h1><p>shell、termial、console</p>
<blockquote>
<p>shell是一种命令解析器，它给用户提供了一个输入命令并接受机器返回结果的界面。</p>
</blockquote>
<p>console控制台，一般console只能有一个</p>
<p>terminal,它是一个封装程序，一个terminal运行一个shell来扩充为一个具备shell功能的的程序。</p>
<blockquote>
<p>console 和 terminal的概念都源自大型机，console可以看作为一个特殊的terminal。现在用的一般都是引申义，一般情况下可以混用。</p>
</blockquote>
<p>命令返回值含义</p>
<p>[0]如果为 0，则表示命令执行成功，其它值则表示错误，</p>
<p>[1]Operation not permitted</p>
<p>[2]No such file or directory</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;OS error code   1:  Operation not permitted&quot;</span><br><span class="line"> &quot;OS error code   2:  No such file or directory&quot;</span><br><span class="line"> &quot;OS error code   3:  No such process&quot;</span><br><span class="line"> &quot;OS error code   4:  Interrupted system call&quot;</span><br><span class="line"> &quot;OS error code   5:  Input/output error&quot;</span><br><span class="line"> &quot;OS error code   6:  No such device or address&quot;</span><br><span class="line"> &quot;OS error code   7:  Argument list too long&quot;</span><br><span class="line"> &quot;OS error code   8:  Exec format error&quot;</span><br><span class="line"> &quot;OS error code   9:  Bad file descriptor&quot;</span><br><span class="line"> &quot;OS error code  10:  No child processes&quot;</span><br><span class="line"> &quot;OS error code  11:  Resource temporarily unavailable&quot;</span><br><span class="line"> &quot;OS error code  12:  Cannot allocate memory&quot;</span><br><span class="line"> &quot;OS error code  13:  Permission denied&quot;</span><br><span class="line"> &quot;OS error code  14:  Bad address&quot;</span><br><span class="line"> &quot;OS error code  15:  Block device required&quot;</span><br><span class="line"> &quot;OS error code  16:  Device or resource busy&quot;</span><br><span class="line"> &quot;OS error code  17:  File exists&quot;</span><br><span class="line"> &quot;OS error code  18:  Invalid cross-device link&quot;</span><br><span class="line"> &quot;OS error code  19:  No such device&quot;</span><br><span class="line"> &quot;OS error code  20:  Not a directory&quot;</span><br><span class="line"> &quot;OS error code  21:  Is a directory&quot;</span><br><span class="line"> &quot;OS error code  22:  Invalid argument&quot;</span><br><span class="line"> &quot;OS error code  23:  Too many open files in system&quot;</span><br><span class="line"> &quot;OS error code  24:  Too many open files&quot;</span><br><span class="line"> &quot;OS error code  25:  Inappropriate ioctl for device&quot;</span><br><span class="line"> &quot;OS error code  26:  Text file busy&quot;</span><br><span class="line"> &quot;OS error code  27:  File too large&quot;</span><br><span class="line"> &quot;OS error code  28:  No space left on device&quot;</span><br><span class="line"> &quot;OS error code  29:  Illegal seek&quot;</span><br><span class="line"> &quot;OS error code  30:  Read-only file system&quot;</span><br><span class="line"> &quot;OS error code  31:  Too many links&quot;</span><br><span class="line"> &quot;OS error code  32:  Broken pipe&quot;</span><br><span class="line"> &quot;OS error code  33:  Numerical argument out of domain&quot;</span><br><span class="line"> &quot;OS error code  34:  Numerical result out of range&quot;</span><br><span class="line"> &quot;OS error code  35:  Resource deadlock avoided&quot;</span><br><span class="line"> &quot;OS error code  36:  File name too long&quot;</span><br><span class="line"> &quot;OS error code  37:  No locks available&quot;</span><br><span class="line"> &quot;OS error code  38:  Function not implemented&quot;</span><br><span class="line"> &quot;OS error code  39:  Directory not empty&quot;</span><br><span class="line"> &quot;OS error code  40:  Too many levels of symbolic links&quot;</span><br><span class="line"> &quot;OS error code  42:  No message of desired type&quot;</span><br><span class="line"> &quot;OS error code  43:  Identifier removed&quot;</span><br><span class="line"> &quot;OS error code  44:  Channel number out of range&quot;</span><br><span class="line"> &quot;OS error code  45:  Level 2 not synchronized&quot;</span><br><span class="line"> &quot;OS error code  46:  Level 3 halted&quot;</span><br><span class="line"> &quot;OS error code  47:  Level 3 reset&quot;</span><br><span class="line"> &quot;OS error code  48:  Link number out of range&quot;</span><br><span class="line"> &quot;OS error code  49:  Protocol driver not attached&quot;</span><br><span class="line"> &quot;OS error code  50:  No CSI structure available&quot;</span><br><span class="line"> &quot;OS error code  51:  Level 2 halted&quot;</span><br><span class="line"> &quot;OS error code  52:  Invalid exchange&quot;</span><br><span class="line"> &quot;OS error code  53:  Invalid request descriptor&quot;</span><br><span class="line"> &quot;OS error code  54:  Exchange full&quot;</span><br><span class="line"> &quot;OS error code  55:  No anode&quot;</span><br><span class="line"> &quot;OS error code  56:  Invalid request code&quot;</span><br><span class="line"> &quot;OS error code  57:  Invalid slot&quot;</span><br><span class="line"> &quot;OS error code  59:  Bad font file format&quot;</span><br><span class="line"> &quot;OS error code  60:  Device not a stream&quot;</span><br><span class="line"> &quot;OS error code  61:  No data available&quot;</span><br><span class="line"> &quot;OS error code  62:  Timer expired&quot;</span><br><span class="line"> &quot;OS error code  63:  Out of streams resources&quot;</span><br><span class="line"> &quot;OS error code  64:  Machine is not on the network&quot;</span><br><span class="line"> &quot;OS error code  65:  Package not installed&quot;</span><br><span class="line"> &quot;OS error code  66:  Object is remote&quot;</span><br><span class="line"> &quot;OS error code  67:  Link has been severed&quot;</span><br><span class="line"> &quot;OS error code  68:  Advertise error&quot;</span><br><span class="line"> &quot;OS error code  69:  Srmount error&quot;</span><br><span class="line"> &quot;OS error code  70:  Communication error on send&quot;</span><br><span class="line"> &quot;OS error code  71:  Protocol error&quot;</span><br><span class="line"> &quot;OS error code  72:  Multihop attempted&quot;</span><br><span class="line"> &quot;OS error code  73:  RFS specific error&quot;</span><br><span class="line"> &quot;OS error code  74:  Bad message&quot;</span><br><span class="line"> &quot;OS error code  75:  Value too large for defined data type&quot;</span><br><span class="line"> &quot;OS error code  76:  Name not unique on network&quot;</span><br><span class="line"> &quot;OS error code  77:  File descriptor in bad state&quot;</span><br><span class="line"> &quot;OS error code  78:  Remote address changed&quot;</span><br><span class="line"> &quot;OS error code  79:  Can not access a needed shared library&quot;</span><br><span class="line"> &quot;OS error code  80:  Accessing a corrupted shared library&quot;</span><br><span class="line"> &quot;OS error code  81:  .lib section in a.out corrupted&quot;</span><br><span class="line"> &quot;OS error code  82:  Attempting to link in too many shared libraries&quot;</span><br><span class="line"> &quot;OS error code  83:  Cannot exec a shared library directly&quot;</span><br><span class="line"> &quot;OS error code  84:  Invalid or incomplete multibyte or wide character&quot;</span><br><span class="line"> &quot;OS error code  85:  Interrupted system call should be restarted&quot;</span><br><span class="line"> &quot;OS error code  86:  Streams pipe error&quot;</span><br><span class="line"> &quot;OS error code  87:  Too many users&quot;</span><br><span class="line"> &quot;OS error code  88:  Socket operation on non-socket&quot;</span><br><span class="line"> &quot;OS error code  89:  Destination address required&quot;</span><br><span class="line"> &quot;OS error code  90:  Message too long&quot;</span><br><span class="line"> &quot;OS error code  91:  Protocol wrong type for socket&quot;</span><br><span class="line"> &quot;OS error code  92:  Protocol not available&quot;</span><br><span class="line"> &quot;OS error code  93:  Protocol not supported&quot;</span><br><span class="line"> &quot;OS error code  94:  Socket type not supported&quot;</span><br><span class="line"> &quot;OS error code  95:  Operation not supported&quot;</span><br><span class="line"> &quot;OS error code  96:  Protocol family not supported&quot;</span><br><span class="line"> &quot;OS error code  97:  Address family not supported by protocol&quot;</span><br><span class="line"> &quot;OS error code  98:  Address already in use&quot;</span><br><span class="line"> &quot;OS error code  99:  Cannot assign requested address&quot;</span><br><span class="line"> &quot;OS error code 100:  Network is down&quot;</span><br><span class="line"> &quot;OS error code 101:  Network is unreachable&quot;</span><br><span class="line"> &quot;OS error code 102:  Network dropped connection on reset&quot;</span><br><span class="line"> &quot;OS error code 103:  Software caused connection abort&quot;</span><br><span class="line"> &quot;OS error code 104:  Connection reset by peer&quot;</span><br><span class="line"> &quot;OS error code 105:  No buffer space available&quot;</span><br><span class="line"> &quot;OS error code 106:  Transport endpoint is already connected&quot;</span><br><span class="line"> &quot;OS error code 107:  Transport endpoint is not connected&quot;</span><br><span class="line"> &quot;OS error code 108:  Cannot send after transport endpoint shutdown&quot;</span><br><span class="line"> &quot;OS error code 109:  Too many references: cannot splice&quot;</span><br><span class="line"> &quot;OS error code 110:  Connection timed out&quot;</span><br><span class="line"> &quot;OS error code 111:  Connection refused&quot;</span><br><span class="line"> &quot;OS error code 112:  Host is down&quot;</span><br><span class="line"> &quot;OS error code 113:  No route to host&quot;</span><br><span class="line"> &quot;OS error code 114:  Operation already in progress&quot;</span><br><span class="line"> &quot;OS error code 115:  Operation now in progress&quot;</span><br><span class="line"> &quot;OS error code 116:  Stale NFS file handle&quot;</span><br><span class="line"> &quot;OS error code 117:  Structure needs cleaning&quot;</span><br><span class="line"> &quot;OS error code 118:  Not a XENIX named type file&quot;</span><br><span class="line"> &quot;OS error code 119:  No XENIX semaphores available&quot;</span><br><span class="line"> &quot;OS error code 120:  Is a named type file&quot;</span><br><span class="line"> &quot;OS error code 121:  Remote I/O error&quot;</span><br><span class="line"> &quot;OS error code 122:  Disk quota exceeded&quot;</span><br><span class="line"> &quot;OS error code 123:  No medium found&quot;</span><br><span class="line"> &quot;OS error code 124:  Wrong medium type&quot;</span><br><span class="line"> &quot;OS error code 125:  Operation canceled&quot;</span><br><span class="line"> &quot;OS error code 126:  Required key not available&quot;</span><br><span class="line"> &quot;OS error code 127:  Key has expired&quot;</span><br><span class="line"> &quot;OS error code 128:  Key has been revoked&quot;</span><br><span class="line"> &quot;OS error code 129:  Key was rejected by service&quot;</span><br><span class="line"> &quot;OS error code 130:  Owner died&quot;</span><br><span class="line"> &quot;OS error code 131:  State not recoverable&quot;</span><br></pre></td></tr></table></figure>


<h2 id="1-Linux帮助系统"><a href="#1-Linux帮助系统" class="headerlink" title="1.Linux帮助系统"></a>1.Linux帮助系统</h2><p><code>man</code>手册</p>
<p><code>man ls</code></p>
<p><code>ls(1)ls</code>第一部分</p>
<p><code>user commands</code> 所属部分：用户命令</p>
<p><code>info</code>手册</p>
<p><code>ls --time =atime -l</code> </p>
<p><code>man scanf</code></p>
<p><code>linux porgrammer&#39;s manual</code>：所属部分:系统开发者</p>
<blockquote>
<p>在学习使用Linux的时候，我们会遇到很多以前没有用过的命令和功能，这个时候最好的解决办法就是求助于<strong>man</strong>.</p>
</blockquote>
<p><code>man</code>的使用方法很简单，例如查看<code>ls</code>的帮助手册，可以直接使用命令<code>man ls</code>即可查看<code>ls</code>的命令帮助。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LS(1)                                       User Commands                                LS(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NAME  <span class="comment">#命令全名，简单的说明及用法</span></span><br><span class="line">       ls - list directory contents</span><br><span class="line"></span><br><span class="line">SYNOPSIS <span class="comment">#基本语法</span></span><br><span class="line">       ls [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION <span class="comment">#详细说明语法中参数的用法</span></span><br><span class="line">       List information about the FILEs (the current directory by default).  Sort entries alphabeti‐</span><br><span class="line">       cally <span class="keyword">if</span> none of -cftuvSUX nor --sort is specified.</span><br><span class="line"></span><br><span class="line">       Mandatory arguments to long options are mandatory <span class="keyword">for</span> short options too.</span><br><span class="line"></span><br><span class="line">       -a, --all</span><br><span class="line">              <span class="keyword">do</span> not ignore entries starting with .</span><br><span class="line"></span><br><span class="line">       -A, --almost-all</span><br><span class="line">              <span class="keyword">do</span> not list implied . and ..</span><br><span class="line"></span><br><span class="line">       --author</span><br><span class="line">              with -l, <span class="built_in">print</span> the author of each file</span><br><span class="line"> <span class="comment">#中间省略</span></span><br><span class="line">       -1     list one file per line</span><br><span class="line"></span><br><span class="line">       --<span class="built_in">help</span> display this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">       --version</span><br><span class="line">              output version information and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">       SIZE  may be (or may be an <span class="built_in">integer</span> optionally followed by) one of following: KB 1000, K 1024,</span><br><span class="line">       MB 1000*1000, M 1024*1024, and so on <span class="keyword">for</span> G, T, P, E, Z, Y.</span><br><span class="line"></span><br><span class="line">       Using color to distinguish file types is disabled both by  default  and  with  --color=never.</span><br><span class="line">       With --color=auto, ls emits color codes only when standard output is connected to a terminal.</span><br><span class="line">       The LS_COLORS environment variable can change the settings.  Use the dircolors <span class="built_in">command</span> to <span class="built_in">set</span></span><br><span class="line">       it.</span><br><span class="line"></span><br><span class="line">   Exit status: <span class="comment">#错误返回值</span></span><br><span class="line">       0      <span class="keyword">if</span> OK,</span><br><span class="line"></span><br><span class="line">       1      <span class="keyword">if</span> minor problems (e.g., cannot access subdirectory),</span><br><span class="line"></span><br><span class="line">       2      <span class="keyword">if</span> serious trouble (e.g., cannot access command-line argument).</span><br><span class="line"></span><br><span class="line">AUTHOR  <span class="comment">#作者</span></span><br><span class="line">       Written by Richard M. Stallman and David MacKenzie.</span><br><span class="line"></span><br><span class="line">REPORTING BUGS <span class="comment">#bug提交联系方式</span></span><br><span class="line">       Report ls bugs to bug-coreutils@gnu.org</span><br><span class="line">       GNU coreutils home page: &lt;http://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">       General <span class="built_in">help</span> using GNU software: &lt;http://www.gnu.org/gethelp/&gt;</span><br><span class="line">       Report ls translation bugs to &lt;http://translationproject.org/team/&gt;</span><br><span class="line"></span><br><span class="line">COPYRIGHT  <span class="comment">#版权保护</span></span><br><span class="line">       Copyright  ©  2011 Free Software Foundation, Inc.  License GPLv3+: GNU GPL version 3 or later</span><br><span class="line">       &lt;http://gnu.org/licenses/gpl.html&gt;.</span><br><span class="line">       This is free software: you are free to change and redistribute it.  There is NO WARRANTY,  to</span><br><span class="line">       the extent permitted by law.</span><br><span class="line"></span><br><span class="line">SEE ALSO <span class="comment">##在哪里可以看到更多关于该命令的文档</span></span><br><span class="line">       The full documentation <span class="keyword">for</span> ls is maintained as a Texinfo manual.  If the info and ls programs</span><br><span class="line">       are properly installed at your site, the <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line">              info coreutils <span class="string">&#x27;ls invocation&#x27;</span></span><br><span class="line"></span><br><span class="line">       should give you access to the complete manual.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GNU coreutils 8.12.197-032bb               September 2011                                      LS(1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>眼尖的同学应该注意到了手册中开头和结尾的地方写的<code>LS(1)</code>了，那么这是什么意思呢？它代表的是一般用户可使用的命令。</p>
</blockquote>
<p>在man中，常见的几个数字的含义如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">代号</th>
<th align="left">代表的含义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">用户在shell环境下可以操作的命令或可执行文件</td>
<td><code>man 1 ls</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">系统内核可调用的函数和工具</td>
<td><code>man 2 reboot</code></td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">一些常用的函数与函数库，大部分C的函数库</td>
<td><code>man 3 readdir</code></td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">设备文件的说明，通常是在<code>/dev</code>下的设备</td>
<td><code>man 4 null</code></td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">配置文件或某些文件的格式</td>
<td><code>man 5 interfaces</code></td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">游戏</td>
<td><code>man 6 lol</code> 😂</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">惯例与协议等，例如Linux文件系统，网络协议等</td>
<td><code>man 7 tcp</code></td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">系统管理员可用的命令</td>
<td><code>man 8 reboot</code></td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">跟kernel有关的文件</td>
<td></td>
</tr>
<tr>
<td align="center">o</td>
<td align="left">旧文档</td>
<td></td>
</tr>
<tr>
<td align="center">n</td>
<td align="left">新文档</td>
<td></td>
</tr>
<tr>
<td align="center">l</td>
<td align="left">本地文档</td>
<td></td>
</tr>
</tbody></table>
<p>在man手册中，我们可以用到的快捷键如下：</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+f(orward)</td>
<td>向下翻一页</td>
<td>Ctrl+d(own)</td>
<td>向下翻半页</td>
</tr>
<tr>
<td>Ctrl+b(ackward)</td>
<td>向上翻一页</td>
<td>Ctrl+u(p)</td>
<td>向上翻半页</td>
</tr>
<tr>
<td>/</td>
<td>查找</td>
<td>q(uit)</td>
<td>退出</td>
</tr>
</tbody></table>
<p>随堂练习：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man -f            #whatis</span><br><span class="line">man -k            #apropos</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Linux中还有一种在线求助的方式<code>info</code>,有兴趣的可以了解一下。</p>
</blockquote>
<h2 id="2-linux常用命令"><a href="#2-linux常用命令" class="headerlink" title="2.linux常用命令"></a>2.linux常用命令</h2><p>1.文件及目录相关，文件内容的修改与查看</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code>查看目录下内容</td>
<td><code>cd</code>目录跳转</td>
</tr>
<tr>
<td><code>pwd</code>打印工作目录</td>
<td><code>cp</code>拷贝</td>
</tr>
<tr>
<td><code>mv</code>移动文件及目录</td>
<td><code>rm</code>删除文件及目录</td>
</tr>
<tr>
<td><code>mkdir</code>创建目录</td>
<td><code>tree</code>打印目录树</td>
</tr>
<tr>
<td><code>tar</code>文件归档与压缩</td>
<td><code>ln</code>创建链接文件</td>
</tr>
<tr>
<td><code>touch</code>创建空白文件</td>
<td><code>head</code>查看文件头部</td>
</tr>
<tr>
<td><code>cat</code>查看文件内容</td>
<td>tail查看文件尾部</td>
</tr>
<tr>
<td><code>vim</code>文本编辑器</td>
<td><code>diff</code>对比文件</td>
</tr>
<tr>
<td><code>echo</code>打印文本</td>
<td><code>grep</code>检索信息</td>
</tr>
<tr>
<td><code>more</code>分页查看文件</td>
<td><code>wc</code>计数</td>
</tr>
<tr>
<td><code>less</code>分页查看文件</td>
<td><code>find</code>查找文件</td>
</tr>
<tr>
<td><code>which</code>查找可执行文件</td>
<td><code>whereis</code>查找可执行、源码、帮助手册</td>
</tr>
<tr>
<td><code>locate</code>定位任何文件</td>
<td></td>
</tr>
</tbody></table>
<p>2.用户相关命令，进程相关命令</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>useradd</code>新建用户</td>
<td><code>chgrp</code>修改所属组</td>
</tr>
<tr>
<td><code>userdel</code>删除用户</td>
<td><code>chmod</code>修改文件权限</td>
</tr>
<tr>
<td><code>usermod</code>修改用户</td>
<td><code>chown</code>修改文件所属用户</td>
</tr>
<tr>
<td><code>passwd</code>修改密码</td>
<td><code>logout</code>退出用户</td>
</tr>
<tr>
<td><code>su</code>切换用户</td>
<td><code>exit</code>退出用户</td>
</tr>
<tr>
<td><code>sudo</code>获取管理员权限</td>
<td></td>
</tr>
<tr>
<td><code>ps</code>打印进程</td>
<td><code>ctrl+z</code>挂起前台任务</td>
</tr>
<tr>
<td><code>kill</code>杀死进程</td>
<td><code>fg</code>将进程调至前台运行</td>
</tr>
<tr>
<td><code>pkill</code>批量杀死进程</td>
<td><code>bg</code>让挂起的进程后台执行</td>
</tr>
<tr>
<td><code>killall</code>批量杀死进程</td>
<td><code>jobs</code>查看挂起和后台进程</td>
</tr>
<tr>
<td><code>crotab</code>定时任务</td>
<td></td>
</tr>
</tbody></table>
<p>3.系统信息命令获取</p>
<table>
<thead>
<tr>
<th><code>date</code> 查看时间</th>
<th><code>dstat</code>查看系统信息</th>
</tr>
</thead>
<tbody><tr>
<td><code>df</code>查看文件系统</td>
<td><code>nmon</code>查看系统信息</td>
</tr>
<tr>
<td><code>du</code>获取目录文件大小</td>
<td><code>ifconfig</code>查看IP信息</td>
</tr>
<tr>
<td><code>free</code>查看内存</td>
<td><code>uname</code>查看OS信息</td>
</tr>
<tr>
<td><code>top</code>查看系统信息</td>
<td><code>last</code>查看最近登录</td>
</tr>
<tr>
<td><code>htop</code>查看系统信息</td>
<td><code>who</code>查看当前登录</td>
</tr>
</tbody></table>
<p>4.其他命令</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>ssh</code>远程连接</td>
<td><code>poweroff</code>关机</td>
</tr>
<tr>
<td><code>scp</code>远程拷贝</td>
<td><code>reboot</code>重启</td>
</tr>
<tr>
<td><code>wget</code>获取<code>http</code>文件</td>
<td></td>
</tr>
<tr>
<td><code>ping</code>测试远程主机</td>
<td></td>
</tr>
</tbody></table>
<h1 id="三、zsh"><a href="#三、zsh" class="headerlink" title="三、zsh"></a>三、zsh</h1><h3 id="1-通配符"><a href="#1-通配符" class="headerlink" title="1.通配符"></a>1.通配符</h3><ul>
<li><p>？</p>
<p>代表<strong>单个任意字符</strong></p>
</li>
<li><p>*</p>
<p>代表<strong>任意几个任意字符</strong></p>
</li>
</ul>
<blockquote>
<p>请看下面的例子，并自己动手尝试一下通配符的使用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">suyelu@HaiZei-Tech:~$ ls</span><br><span class="line">a.log  code  HaiZei  helloworld  你好world</span><br><span class="line">suyelu@HaiZei-Tech:~$ ls *ld</span><br><span class="line">helloworld  你好world</span><br><span class="line">suyelu@HaiZei-Tech:~$ ls ??world</span><br><span class="line">你好world</span><br><span class="line">suyelu@HaiZei-Tech:~$ ls ?????world</span><br><span class="line">helloworld</span><br><span class="line">suyelu@HaiZei-Tech:~$</span><br></pre></td></tr></table></figure>
<p>除了*<strong>**和</strong>?**这两个通配符之外，Linux中还有下面几种通配符</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>[list]</td>
<td>匹配list中的任意单一字符</td>
<td>a[xyz]b  a与b之间有且只有一个字符, 且只能是x或y或z, 如: axb, ayb, azb。</td>
</tr>
<tr>
<td>[!list]</td>
<td>匹配除list中的任意单一字符</td>
<td>a[!0-9]b  a与b之间有且只有一个字符, 但不能是数字, 如axb, aab, a-b等</td>
</tr>
<tr>
<td>[c1-c2]</td>
<td>匹配c1-c2中的任意单一字符</td>
<td>a[0-9]b  a与b之间有且只有一个字符，该字符是0-9之间的数字，如a0b, a1b，… ，a9b。</td>
</tr>
<tr>
<td>{string1,string2,…}</td>
<td>匹配 sring1 或 string2 (或更多)其一字符串</td>
<td>a{abc,xyz,123}b    a与b之间只能是abc或xyz或123这三个字符串之一。</td>
</tr>
</tbody></table>
<h3 id="2-任务管理"><a href="#2-任务管理" class="headerlink" title="2.任务管理"></a>2.任务管理</h3><p><code>PATH=$&#123;PATH&#125;:.</code></p>
<p>locate</p>
<p>1.<code>&amp;</code></p>
<p>在命令的后面加上**<code>&amp;</code>**表示后台执行的意思</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command &amp;</span><br></pre></td></tr></table></figure>


<p>2.<code>;</code></p>
<p>在命令之间以**<code>;</code>**相连，表示顺序执行的意思</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command1;command2</span><br></pre></td></tr></table></figure>
<p>3.<strong><code>&amp;&amp;</code></strong></p>
<p>命令之间以**<code>&amp;&amp;</code>**相连时，只有第一个命令成功执行，第二个命令才会执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command1 &amp;&amp; command2</span><br></pre></td></tr></table></figure>


<p>4.<strong><code>||</code></strong></p>
<p>命令之间以**<code>||</code>**相连时，如果前一个命令执行失败，则执行第二个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command1 || command2</span><br></pre></td></tr></table></figure>
<p>5.<strong><code>``</code></strong></p>
<p>命令中如果包含另一个命令，则用符号**<code>** 将它包括起来，在执行的时候系统将优先执行**</code>**中的子命令，然后将其结果代入父命令继续执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command1 `command2`</span><br></pre></td></tr></table></figure>
<p>6.<strong><code>ctrl + z</code></strong></p>
<p>在shell中执行命令时，同时按下**<code>ctrl + z</code>**可以将暂时挂起</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">suyelu@HaiZei-Tech:~$ vim helloworld.c</span><br><span class="line"></span><br><span class="line">[1]+  Stopped                 vim helloworld.c</span><br><span class="line">suyelu@HaiZei-Tech:~$</span><br></pre></td></tr></table></figure>
<blockquote>
<p>什么是挂起？</p>
</blockquote>
<ol start="7">
<li><p><strong><code>bg</code></strong></p>
<p>执行**<code>bg</code>**命令，可以将挂起的命令后台运行</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">suyelu@HaiZei-Tech:~$ vim helloworld.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[1]+  Stopped                 vim helloworld.c</span><br><span class="line">suyelu@HaiZei-Tech:~$ bg</span><br><span class="line">[1]+ vim helloworld.c &amp;</span><br><span class="line">suyelu@HaiZei-Tech:~$</span><br></pre></td></tr></table></figure>


<ol start="8">
<li><p><strong><code>fg</code></strong></p>
<p>执行命令**<code>fg</code>**可以将后台执行的命令转为前台执行</p>
</li>
<li><p><strong><code>jobs</code></strong></p>
<p>在Linux系统中，执行**<code>jobs</code>**命令可以查看所有在后台执行和挂起的任务以及任务编号</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">suyelu@HaiZei-Tech:~/code$ jobs</span><br><span class="line">[1]-  Stopped                 vim a.c  (wd: ~)</span><br><span class="line">[2]+  Stopped                 vim b.c  (wd: ~)</span><br><span class="line">[3]   Running                 ./a.out &amp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>尝试执行<strong>fg</strong>和<strong>bg</strong>加上任务编号，看看是什么效果</p>
</blockquote>
<p>%没有输入换行符zsh输出一个%座位标记</p>
<p>/tmp零时文件夹</p>
<p>BIOS：开机检测</p>
<blockquote>
<p>检测硬件环境</p>
<p>Boot Loader读内核文件</p>
<p>/sbin/init 启动进程</p>
<p>加载磁盘</p>
</blockquote>
<p>guziqiu: x :</p>
<p>x代表密码占位符</p>
<h3 id="3-管道、重定向"><a href="#3-管道、重定向" class="headerlink" title="3.管道、重定向"></a>3.管道、重定向</h3><ol>
<li><p><code>&gt;</code></p>
<p>重定向符</p>
</li>
<li><p><code>&gt;&gt;</code></p>
<p>作用于**&gt;<strong>基本相同，不同的是</strong>&gt;&gt;<strong>将内容追加到文件的末尾，而</strong>&gt;**内容覆盖原文件</p>
</li>
<li><p><code>&lt;</code></p>
<p>与**&gt;**刚好相反，是从文件到命令的重定向。它将文件的内容输出到命令作为输入</p>
</li>
<li><p><code>&lt;&lt;</code> 标记文件结尾</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; &#x2F;etc&#x2F;sysconfig&#x2F;network &lt;&lt; EOF</span><br><span class="line">HOSTNAME&#x3D;$HOST_NAME</span><br><span class="line">EOF </span><br></pre></td></tr></table></figure>
<h3 id="4-转义符"><a href="#4-转义符" class="headerlink" title="4.转义符"></a>4.转义符</h3><blockquote>
<p>在Linux中转义符**<code>\</code><strong>的应用十分广泛，除此之外，转义符还包括</strong>“”<strong>和</strong>‘’**。</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>‘’</td>
<td>硬转义,硬引用，其内部所有的shell元字符、通配符都会被关掉。注意，硬转义中不允许出现’(单引号)。</td>
</tr>
<tr>
<td>“”</td>
<td>软转义，软引用，其内部只允许出现特定的shell元字符($,`,\)：$用于变量值替换、`用于命令替换、\用于转义单个字符</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠，转义，去除其后紧跟的元字符或通配符的特殊意义。</td>
</tr>
</tbody></table>
<p>下表是部分转义字符对应表：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>\\</td>
<td>代表一个反斜线字符’’&#39;</td>
<td>092</td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NULL)</td>
<td>000</td>
</tr>
<tr>
<td>\nnn</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td>\xnnn</td>
<td>1到3位十六进制所代表的任意字符</td>
<td>三位十六进制</td>
</tr>
</tbody></table>
<h4 id="转义符在Shell中的应用"><a href="#转义符在Shell中的应用" class="headerlink" title="转义符在Shell中的应用"></a>转义符在Shell中的应用</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">suyelu@HaiZei-Tech:~$ echo -e &quot;\044&quot;</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="bash">suyelu@HaiZei-Tech:~$ <span class="built_in">echo</span>  <span class="string">&quot;\044&quot;</span></span></span><br><span class="line">\044</span><br><span class="line">suyelu@HaiZei-Tech:~$ echo  $&#x27;\044&#x27;</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="bash">suyelu@HaiZei-Tech:~$ <span class="built_in">echo</span>  $<span class="string">&#x27;\44&#x27;</span></span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>




<h2 id="附录1-Shell元字符"><a href="#附录1-Shell元字符" class="headerlink" title="附录1 Shell元字符"></a>附录1 Shell元字符</h2><blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>变量名=值，为变量赋值。注意=左右紧跟变量名和值，中间不要有空格</td>
</tr>
<tr>
<td>``</td>
<td>取命令的执行结果，与下文的$有相似之处</td>
</tr>
<tr>
<td>$</td>
<td>变量值替换，$变量名替换为shell变量的值;为避免在文本连接时混淆，请使用${变量名};$0…$9 代表shell文件的参数。**$()<strong>同``;</strong>${}<strong>限定变量名的范围；</strong>$[]**整数计算；</td>
</tr>
<tr>
<td>&gt;</td>
<td>prog &gt; file 将标准输出重定向到文件。</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>prog &gt;&gt; file 将标准输出追加到文件。</td>
</tr>
<tr>
<td>&lt;</td>
<td>prog &lt; file 从文件file中获取标准输入</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td></td>
</tr>
<tr>
<td>|</td>
<td>管道命令，例：p1 | p2 将p1的标准输出作为p2的标准输入</td>
</tr>
<tr>
<td>&amp;</td>
<td>后台运行命令，最大好处是无需等待命令执行结束，就可以在同一命令行下继续输入命令</td>
</tr>
<tr>
<td>()</td>
<td>在子shell中执行命令,在子进程中执行</td>
</tr>
<tr>
<td>{}</td>
<td>在当前shell中执行命令，或用在变量替换的界定范围(例如上面的${变量名}用法)。</td>
</tr>
<tr>
<td>[]</td>
<td>字符通配，匹配括号内之一</td>
</tr>
<tr>
<td>;</td>
<td>命令结束符。例如p1;p2表示先执行p1,再执行p2</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>前一个命令执行成功后，才继续执行下一个命令。例：p1 &amp;&amp; p2 ;若p1执行成功后，才执行p2,反之，不执行p2;</td>
</tr>
<tr>
<td>||</td>
<td>前一个命令执行失败后，才继续执行下一个命令。例：p1 || p2 ;若p1执行成功后，不执行p2,反之，才执行p2;</td>
</tr>
<tr>
<td>!</td>
<td>执行历史记录中的命令**!731**;匹配最近的一次命令**!echo**;取非<strong>ls /dev/sda[!1]</strong>;结果取反**! echo ok ;echo $?**</td>
</tr>
<tr>
<td>%</td>
<td><strong>% 1</strong>相当于<strong>fg 1</strong></td>
</tr>
<tr>
<td>^</td>
<td>取非，和**!<strong>雷同；</strong><code>^string1^string2^</code>**将上一命令的string1替换为string2</td>
</tr>
<tr>
<td>~</td>
<td>home目录</td>
</tr>
<tr>
<td>#</td>
<td>注释</td>
</tr>
<tr>
<td>*</td>
<td>通配符，任意字符</td>
</tr>
<tr>
<td>?</td>
<td>通配符，任一字符</td>
</tr>
<tr>
<td>.</td>
<td>当前目录；source</td>
</tr>
<tr>
<td>-</td>
<td>减号；上次工作目录</td>
</tr>
<tr>
<td>:</td>
<td>真值；空命令</td>
</tr>
<tr>
<td>\</td>
<td>转义</td>
</tr>
<tr>
<td>/</td>
<td>目录分割符</td>
</tr>
</tbody></table>
<h2 id="附录2-ASCII码-对照表"><a href="#附录2-ASCII码-对照表" class="headerlink" title="附录2 ASCII码 对照表"></a>附录2 ASCII码 对照表</h2><table>
<thead>
<tr>
<th>Bin(二进制)</th>
<th>Oct(八进制)</th>
<th>Dec(十进制)</th>
<th>Hex(十六进制)</th>
<th>缩写/字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0000 0000</td>
<td>0</td>
<td>0</td>
<td>00</td>
<td>NUL(null)</td>
<td>空字符</td>
</tr>
<tr>
<td>0000 0001</td>
<td>1</td>
<td>1</td>
<td>01</td>
<td>SOH(start of headline)</td>
<td>标题开始</td>
</tr>
<tr>
<td>0000 0010</td>
<td>2</td>
<td>2</td>
<td>02</td>
<td>STX (start of text)</td>
<td>正文开始</td>
</tr>
<tr>
<td>0000 0011</td>
<td>3</td>
<td>3</td>
<td>03</td>
<td>ETX (end of text)</td>
<td>正文结束</td>
</tr>
<tr>
<td>0000 0100</td>
<td>4</td>
<td>4</td>
<td>04</td>
<td>EOT (end of transmission)</td>
<td>传输结束</td>
</tr>
<tr>
<td>0000 0101</td>
<td>5</td>
<td>5</td>
<td>05</td>
<td>ENQ (enquiry)</td>
<td>请求</td>
</tr>
<tr>
<td>0000 0110</td>
<td>6</td>
<td>6</td>
<td>06</td>
<td>ACK (acknowledge)</td>
<td>收到通知</td>
</tr>
<tr>
<td>0000 0111</td>
<td>7</td>
<td>7</td>
<td>07</td>
<td>BEL (bell)</td>
<td>响铃</td>
</tr>
<tr>
<td>0000 1000</td>
<td>10</td>
<td>8</td>
<td>08</td>
<td>BS (backspace)</td>
<td>退格</td>
</tr>
<tr>
<td>0000 1001</td>
<td>11</td>
<td>9</td>
<td>09</td>
<td>HT (horizontal tab)</td>
<td>水平制表符</td>
</tr>
<tr>
<td>0000 1010</td>
<td>12</td>
<td>10</td>
<td>0A</td>
<td>LF (NL line feed, new line)</td>
<td>换行键</td>
</tr>
<tr>
<td>0000 1011</td>
<td>13</td>
<td>11</td>
<td>0B</td>
<td>VT (vertical tab)</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>0000 1100</td>
<td>14</td>
<td>12</td>
<td>0C</td>
<td>FF (NP form feed, new page)</td>
<td>换页键</td>
</tr>
<tr>
<td>0000 1101</td>
<td>15</td>
<td>13</td>
<td>0D</td>
<td>CR (carriage return)</td>
<td>回车键</td>
</tr>
<tr>
<td>0000 1110</td>
<td>16</td>
<td>14</td>
<td>0E</td>
<td>SO (shift out)</td>
<td>不用切换</td>
</tr>
<tr>
<td>0000 1111</td>
<td>17</td>
<td>15</td>
<td>0F</td>
<td>SI (shift in)</td>
<td>启用切换</td>
</tr>
<tr>
<td>0001 0000</td>
<td>20</td>
<td>16</td>
<td>10</td>
<td>DLE (data link escape)</td>
<td>数据链路转义</td>
</tr>
<tr>
<td>0001 0001</td>
<td>21</td>
<td>17</td>
<td>11</td>
<td>DC1 (device control 1)</td>
<td>设备控制1</td>
</tr>
<tr>
<td>0001 0010</td>
<td>22</td>
<td>18</td>
<td>12</td>
<td>DC2 (device control 2)</td>
<td>设备控制2</td>
</tr>
<tr>
<td>0001 0011</td>
<td>23</td>
<td>19</td>
<td>13</td>
<td>DC3 (device control 3)</td>
<td>设备控制3</td>
</tr>
<tr>
<td>0001 0100</td>
<td>24</td>
<td>20</td>
<td>14</td>
<td>DC4 (device control 4)</td>
<td>设备控制4</td>
</tr>
<tr>
<td>0001 0101</td>
<td>25</td>
<td>21</td>
<td>15</td>
<td>NAK (negative acknowledge)</td>
<td>拒绝接收</td>
</tr>
<tr>
<td>0001 0110</td>
<td>26</td>
<td>22</td>
<td>16</td>
<td>SYN (synchronous idle)</td>
<td>同步空闲</td>
</tr>
<tr>
<td>0001 0111</td>
<td>27</td>
<td>23</td>
<td>17</td>
<td>ETB (end of trans. block)</td>
<td>结束传输块</td>
</tr>
<tr>
<td>0001 1000</td>
<td>30</td>
<td>24</td>
<td>18</td>
<td>CAN (cancel)</td>
<td>取消</td>
</tr>
<tr>
<td>0001 1001</td>
<td>31</td>
<td>25</td>
<td>19</td>
<td>EM (end of medium)</td>
<td>媒介结束</td>
</tr>
<tr>
<td>0001 1010</td>
<td>32</td>
<td>26</td>
<td>1A</td>
<td>SUB (substitute)</td>
<td>代替</td>
</tr>
<tr>
<td>0001 1011</td>
<td>33</td>
<td>27</td>
<td>1B</td>
<td>ESC (escape)</td>
<td>换码(溢出)</td>
</tr>
<tr>
<td>0001 1100</td>
<td>34</td>
<td>28</td>
<td>1C</td>
<td>FS (file separator)</td>
<td>文件分隔符</td>
</tr>
<tr>
<td>0001 1101</td>
<td>35</td>
<td>29</td>
<td>1D</td>
<td>GS (group separator)</td>
<td>分组符</td>
</tr>
<tr>
<td>0001 1110</td>
<td>36</td>
<td>30</td>
<td>1E</td>
<td>RS (record separator)</td>
<td>记录分隔符</td>
</tr>
<tr>
<td>0001 1111</td>
<td>37</td>
<td>31</td>
<td>1F</td>
<td>US (unit separator)</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>0010 0000</td>
<td>40</td>
<td>32</td>
<td>20</td>
<td>(space)</td>
<td>空格</td>
</tr>
<tr>
<td>0010 0001</td>
<td>41</td>
<td>33</td>
<td>21</td>
<td>!</td>
<td>叹号</td>
</tr>
<tr>
<td>0010 0010</td>
<td>42</td>
<td>34</td>
<td>22</td>
<td>“</td>
<td>双引号</td>
</tr>
<tr>
<td>0010 0011</td>
<td>43</td>
<td>35</td>
<td>23</td>
<td>#</td>
<td>井号</td>
</tr>
<tr>
<td>0010 0100</td>
<td>44</td>
<td>36</td>
<td>24</td>
<td>$</td>
<td>美元符</td>
</tr>
<tr>
<td>0010 0101</td>
<td>45</td>
<td>37</td>
<td>25</td>
<td>%</td>
<td>百分号</td>
</tr>
<tr>
<td>0010 0110</td>
<td>46</td>
<td>38</td>
<td>26</td>
<td>&amp;</td>
<td>和号</td>
</tr>
<tr>
<td>0010 0111</td>
<td>47</td>
<td>39</td>
<td>27</td>
<td>‘</td>
<td>闭单引号</td>
</tr>
<tr>
<td>0010 1000</td>
<td>50</td>
<td>40</td>
<td>28</td>
<td>(</td>
<td>开括号</td>
</tr>
<tr>
<td>0010 1001</td>
<td>51</td>
<td>41</td>
<td>29</td>
<td>)</td>
<td>闭括号</td>
</tr>
<tr>
<td>0010 1010</td>
<td>52</td>
<td>42</td>
<td>2A</td>
<td>*</td>
<td>星号</td>
</tr>
<tr>
<td>0010 1011</td>
<td>53</td>
<td>43</td>
<td>2B</td>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>0010 1100</td>
<td>54</td>
<td>44</td>
<td>2C</td>
<td>,</td>
<td>逗号</td>
</tr>
<tr>
<td>0010 1101</td>
<td>55</td>
<td>45</td>
<td>2D</td>
<td>-</td>
<td>减号/破折号</td>
</tr>
<tr>
<td>0010 1110</td>
<td>56</td>
<td>46</td>
<td>2E</td>
<td>.</td>
<td>句号</td>
</tr>
<tr>
<td>00101111</td>
<td>57</td>
<td>47</td>
<td>2F</td>
<td>/</td>
<td>斜杠</td>
</tr>
<tr>
<td>00110000</td>
<td>60</td>
<td>48</td>
<td>30</td>
<td>0</td>
<td>数字0</td>
</tr>
<tr>
<td>00110001</td>
<td>61</td>
<td>49</td>
<td>31</td>
<td>1</td>
<td>数字1</td>
</tr>
<tr>
<td>00110010</td>
<td>62</td>
<td>50</td>
<td>32</td>
<td>2</td>
<td>数字2</td>
</tr>
<tr>
<td>00110011</td>
<td>63</td>
<td>51</td>
<td>33</td>
<td>3</td>
<td>数字3</td>
</tr>
<tr>
<td>00110100</td>
<td>64</td>
<td>52</td>
<td>34</td>
<td>4</td>
<td>数字4</td>
</tr>
<tr>
<td>00110101</td>
<td>65</td>
<td>53</td>
<td>35</td>
<td>5</td>
<td>数字5</td>
</tr>
<tr>
<td>00110110</td>
<td>66</td>
<td>54</td>
<td>36</td>
<td>6</td>
<td>数字6</td>
</tr>
<tr>
<td>00110111</td>
<td>67</td>
<td>55</td>
<td>37</td>
<td>7</td>
<td>数字7</td>
</tr>
<tr>
<td>00111000</td>
<td>70</td>
<td>56</td>
<td>38</td>
<td>8</td>
<td>数字8</td>
</tr>
<tr>
<td>00111001</td>
<td>71</td>
<td>57</td>
<td>39</td>
<td>9</td>
<td>数字9</td>
</tr>
<tr>
<td>00111010</td>
<td>72</td>
<td>58</td>
<td>3A</td>
<td>:</td>
<td>冒号</td>
</tr>
<tr>
<td>00111011</td>
<td>73</td>
<td>59</td>
<td>3B</td>
<td>;</td>
<td>分号</td>
</tr>
<tr>
<td>00111100</td>
<td>74</td>
<td>60</td>
<td>3C</td>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>00111101</td>
<td>75</td>
<td>61</td>
<td>3D</td>
<td>=</td>
<td>等号</td>
</tr>
<tr>
<td>00111110</td>
<td>76</td>
<td>62</td>
<td>3E</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>00111111</td>
<td>77</td>
<td>63</td>
<td>3F</td>
<td>?</td>
<td>问号</td>
</tr>
<tr>
<td>01000000</td>
<td>100</td>
<td>64</td>
<td>40</td>
<td>@</td>
<td>电子邮件符号</td>
</tr>
<tr>
<td>01000001</td>
<td>101</td>
<td>65</td>
<td>41</td>
<td>A</td>
<td>大写字母A</td>
</tr>
<tr>
<td>01000010</td>
<td>102</td>
<td>66</td>
<td>42</td>
<td>B</td>
<td>大写字母B</td>
</tr>
<tr>
<td>01000011</td>
<td>103</td>
<td>67</td>
<td>43</td>
<td>C</td>
<td>大写字母C</td>
</tr>
<tr>
<td>01000100</td>
<td>104</td>
<td>68</td>
<td>44</td>
<td>D</td>
<td>大写字母D</td>
</tr>
<tr>
<td>01000101</td>
<td>105</td>
<td>69</td>
<td>45</td>
<td>E</td>
<td>大写字母E</td>
</tr>
<tr>
<td>01000110</td>
<td>106</td>
<td>70</td>
<td>46</td>
<td>F</td>
<td>大写字母F</td>
</tr>
<tr>
<td>01000111</td>
<td>107</td>
<td>71</td>
<td>47</td>
<td>G</td>
<td>大写字母G</td>
</tr>
<tr>
<td>01001000</td>
<td>110</td>
<td>72</td>
<td>48</td>
<td>H</td>
<td>大写字母H</td>
</tr>
<tr>
<td>01001001</td>
<td>111</td>
<td>73</td>
<td>49</td>
<td>I</td>
<td>大写字母I</td>
</tr>
<tr>
<td>01001010</td>
<td>112</td>
<td>74</td>
<td>4A</td>
<td>J</td>
<td>大写字母J</td>
</tr>
<tr>
<td>01001011</td>
<td>113</td>
<td>75</td>
<td>4B</td>
<td>K</td>
<td>大写字母K</td>
</tr>
<tr>
<td>01001100</td>
<td>114</td>
<td>76</td>
<td>4C</td>
<td>L</td>
<td>大写字母L</td>
</tr>
<tr>
<td>01001101</td>
<td>115</td>
<td>77</td>
<td>4D</td>
<td>M</td>
<td>大写字母M</td>
</tr>
<tr>
<td>01001110</td>
<td>116</td>
<td>78</td>
<td>4E</td>
<td>N</td>
<td>大写字母N</td>
</tr>
<tr>
<td>01001111</td>
<td>117</td>
<td>79</td>
<td>4F</td>
<td>O</td>
<td>大写字母O</td>
</tr>
<tr>
<td>01010000</td>
<td>120</td>
<td>80</td>
<td>50</td>
<td>P</td>
<td>大写字母P</td>
</tr>
<tr>
<td>01010001</td>
<td>121</td>
<td>81</td>
<td>51</td>
<td>Q</td>
<td>大写字母Q</td>
</tr>
<tr>
<td>01010010</td>
<td>122</td>
<td>82</td>
<td>52</td>
<td>R</td>
<td>大写字母R</td>
</tr>
<tr>
<td>01010011</td>
<td>123</td>
<td>83</td>
<td>53</td>
<td>S</td>
<td>大写字母S</td>
</tr>
<tr>
<td>01010100</td>
<td>124</td>
<td>84</td>
<td>54</td>
<td>T</td>
<td>大写字母T</td>
</tr>
<tr>
<td>01010101</td>
<td>125</td>
<td>85</td>
<td>55</td>
<td>U</td>
<td>大写字母U</td>
</tr>
<tr>
<td>01010110</td>
<td>126</td>
<td>86</td>
<td>56</td>
<td>V</td>
<td>大写字母V</td>
</tr>
<tr>
<td>01010111</td>
<td>127</td>
<td>87</td>
<td>57</td>
<td>W</td>
<td>大写字母W</td>
</tr>
<tr>
<td>01011000</td>
<td>130</td>
<td>88</td>
<td>58</td>
<td>X</td>
<td>大写字母X</td>
</tr>
<tr>
<td>01011001</td>
<td>131</td>
<td>89</td>
<td>59</td>
<td>Y</td>
<td>大写字母Y</td>
</tr>
<tr>
<td>01011010</td>
<td>132</td>
<td>90</td>
<td>5A</td>
<td>Z</td>
<td>大写字母Z</td>
</tr>
<tr>
<td>01011011</td>
<td>133</td>
<td>91</td>
<td>5B</td>
<td>[</td>
<td>开方括号</td>
</tr>
<tr>
<td>01011100</td>
<td>134</td>
<td>92</td>
<td>5C</td>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>01011101</td>
<td>135</td>
<td>93</td>
<td>5D</td>
<td>]</td>
<td>闭方括号</td>
</tr>
<tr>
<td>01011110</td>
<td>136</td>
<td>94</td>
<td>5E</td>
<td>^</td>
<td>脱字符</td>
</tr>
<tr>
<td>01011111</td>
<td>137</td>
<td>95</td>
<td>5F</td>
<td>_</td>
<td>下划线</td>
</tr>
<tr>
<td>01100000</td>
<td>140</td>
<td>96</td>
<td>60</td>
<td>`</td>
<td>开单引号</td>
</tr>
<tr>
<td>01100001</td>
<td>141</td>
<td>97</td>
<td>61</td>
<td>a</td>
<td>小写字母a</td>
</tr>
<tr>
<td>01100010</td>
<td>142</td>
<td>98</td>
<td>62</td>
<td>b</td>
<td>小写字母b</td>
</tr>
<tr>
<td>01100011</td>
<td>143</td>
<td>99</td>
<td>63</td>
<td>c</td>
<td>小写字母c</td>
</tr>
<tr>
<td>01100100</td>
<td>144</td>
<td>100</td>
<td>64</td>
<td>d</td>
<td>小写字母d</td>
</tr>
<tr>
<td>01100101</td>
<td>145</td>
<td>101</td>
<td>65</td>
<td>e</td>
<td>小写字母e</td>
</tr>
<tr>
<td>01100110</td>
<td>146</td>
<td>102</td>
<td>66</td>
<td>f</td>
<td>小写字母f</td>
</tr>
<tr>
<td>01100111</td>
<td>147</td>
<td>103</td>
<td>67</td>
<td>g</td>
<td>小写字母g</td>
</tr>
<tr>
<td>01101000</td>
<td>150</td>
<td>104</td>
<td>68</td>
<td>h</td>
<td>小写字母h</td>
</tr>
<tr>
<td>01101001</td>
<td>151</td>
<td>105</td>
<td>69</td>
<td>i</td>
<td>小写字母i</td>
</tr>
<tr>
<td>01101010</td>
<td>152</td>
<td>106</td>
<td>6A</td>
<td>j</td>
<td>小写字母j</td>
</tr>
<tr>
<td>01101011</td>
<td>153</td>
<td>107</td>
<td>6B</td>
<td>k</td>
<td>小写字母k</td>
</tr>
<tr>
<td>01101100</td>
<td>154</td>
<td>108</td>
<td>6C</td>
<td>l</td>
<td>小写字母l</td>
</tr>
<tr>
<td>01101101</td>
<td>155</td>
<td>109</td>
<td>6D</td>
<td>m</td>
<td>小写字母m</td>
</tr>
<tr>
<td>01101110</td>
<td>156</td>
<td>110</td>
<td>6E</td>
<td>n</td>
<td>小写字母n</td>
</tr>
<tr>
<td>01101111</td>
<td>157</td>
<td>111</td>
<td>6F</td>
<td>o</td>
<td>小写字母o</td>
</tr>
<tr>
<td>01110000</td>
<td>160</td>
<td>112</td>
<td>70</td>
<td>p</td>
<td>小写字母p</td>
</tr>
<tr>
<td>01110001</td>
<td>161</td>
<td>113</td>
<td>71</td>
<td>q</td>
<td>小写字母q</td>
</tr>
<tr>
<td>01110010</td>
<td>162</td>
<td>114</td>
<td>72</td>
<td>r</td>
<td>小写字母r</td>
</tr>
<tr>
<td>01110011</td>
<td>163</td>
<td>115</td>
<td>73</td>
<td>s</td>
<td>小写字母s</td>
</tr>
<tr>
<td>01110100</td>
<td>164</td>
<td>116</td>
<td>74</td>
<td>t</td>
<td>小写字母t</td>
</tr>
<tr>
<td>01110101</td>
<td>165</td>
<td>117</td>
<td>75</td>
<td>u</td>
<td>小写字母u</td>
</tr>
<tr>
<td>01110110</td>
<td>166</td>
<td>118</td>
<td>76</td>
<td>v</td>
<td>小写字母v</td>
</tr>
<tr>
<td>01110111</td>
<td>167</td>
<td>119</td>
<td>77</td>
<td>w</td>
<td>小写字母w</td>
</tr>
<tr>
<td>01111000</td>
<td>170</td>
<td>120</td>
<td>78</td>
<td>x</td>
<td>小写字母x</td>
</tr>
<tr>
<td>01111001</td>
<td>171</td>
<td>121</td>
<td>79</td>
<td>y</td>
<td>小写字母y</td>
</tr>
<tr>
<td>01111010</td>
<td>172</td>
<td>122</td>
<td>7A</td>
<td>z</td>
<td>小写字母z</td>
</tr>
<tr>
<td>01111011</td>
<td>173</td>
<td>123</td>
<td>7B</td>
<td>{</td>
<td>开花括号</td>
</tr>
<tr>
<td>01111100</td>
<td>174</td>
<td>124</td>
<td>7C</td>
<td>|</td>
<td>垂线</td>
</tr>
<tr>
<td>01111101</td>
<td>175</td>
<td>125</td>
<td>7D</td>
<td>}</td>
<td>闭花括号</td>
</tr>
<tr>
<td>01111110</td>
<td>176</td>
<td>126</td>
<td>7E</td>
<td>~</td>
<td>波浪号</td>
</tr>
<tr>
<td>01111111</td>
<td>177</td>
<td>127</td>
<td>7F</td>
<td>DEL (delete)</td>
<td>删除</td>
</tr>
</tbody></table>
<h1 id="四、linux系统信息获取"><a href="#四、linux系统信息获取" class="headerlink" title="四、linux系统信息获取"></a>四、linux系统信息获取</h1><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>update</code></td>
<td>打印系统运行时长和平均负载</td>
</tr>
<tr>
<td><code>who</code></td>
<td>显示当前系统登录的用户信息</td>
</tr>
<tr>
<td><code>last</code></td>
<td>显示用户最近登录信息</td>
</tr>
<tr>
<td><code>date</code></td>
<td>显示或设置系统时间与日期</td>
</tr>
<tr>
<td><code>w</code></td>
<td>当前登录用户列表及正在执行的任务</td>
</tr>
<tr>
<td><code>whoami</code></td>
<td>打印当前有效的用户名称</td>
</tr>
<tr>
<td><code>uname</code></td>
<td>打印当前系统信息</td>
</tr>
<tr>
<td><code>cal</code></td>
<td>显示日历</td>
</tr>
</tbody></table>
<p><code>uptime</code>系统运行时长</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu ~ % uptime</span><br><span class="line"> 14:28:15 up 6 days, 22:24,  1 user,  load average: 1.88, 1.19, 1.01</span><br></pre></td></tr></table></figure>


<p><code>w</code>获取当前用户和正在执行的进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu ~ % w                                                                                                        [127]</span><br><span class="line"> 14:33:51 up 6 days, 22:29,  1 user,  load average: 0.96, 0.95, 0.95</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">apricity pts/0    112.54.13.167    14:00    1.00s  3.35s  0.00s w</span><br></pre></td></tr></table></figure>


<p><code>tty</code>虚拟终端  <code>from</code> 从哪里登录，<code>loging</code>在什么时候登录</p>
<p><code> last | grep  -v &quot;wtmp begins&quot; | grep -v &quot;^$&quot; | grep -v &quot;reboot&quot; |ƒ |sort | uniq -c | sort -n -r  | head -n 2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">上一次登录停留了多长时间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>






<p><code>uname</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu linux基础 % uname -a</span><br><span class="line">Linux qiu 4.15.0-117-generic #118-Ubuntu SMP Fri Sep 4 20:02:41 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apricity@qiu linux % date +&quot;%Y-%m-%d %H:%M:%S&quot;                                                                        [0]</span><br><span class="line">2020-11-29 15:40:28</span><br></pre></td></tr></table></figure>




<p>cal日历</p>
<h1 id="五、shell编程"><a href="#五、shell编程" class="headerlink" title="五、shell编程"></a>五、shell编程</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">这是注释</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  ！不是注释，指定解释器,固定格式</span></span><br><span class="line">echo &#x27;hello&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释的代码...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>




<h2 id="1-变量与局部变量"><a href="#1-变量与局部变量" class="headerlink" title="1.变量与局部变量"></a>1.变量与局部变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">变量</span></span><br><span class="line">apricity@qiu 1.shell % a=123                                                                                          [0]</span><br><span class="line">apricity@qiu 1.shell % echo $a                                                                                        [0]</span><br><span class="line">123</span><br><span class="line"></span><br><span class="line">apricity@qiu 1.shell % a = 123</span><br><span class="line">zsh: command not found: a</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量的定义</p>
<p>​    a=12</p>
<p>局部变量</p>
<p>​    local a=12</p>
<p>特殊变量</p>
<ul>
<li><p>位置变量</p>
<p>$0:获取当前执行shell脚本文件名，包括路径</p>
<p>$*:获取当前shell的所有参数</p>
<p>$#：得到当前脚本的参数个数</p>
<p>$@：获取这个程序所有的参数</p>
</li>
</ul>
</blockquote>
<p>状态变量</p>
<p>​        $?：判断上一个指令是否执行成功，0为成功，非零不成功</p>
<p>​        $$:获取当前进程的PID</p>
<p>​        $!：上一个指令的PID</p>
<h2 id="2-输入输出"><a href="#2-输入输出" class="headerlink" title="2.输入输出"></a>2.输入输出</h2><p><code>echo</code></p>
<p><code>echo -e &quot;hello\n&quot;#开启转义</code></p>
<p><code>printf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">软转义</span></span><br><span class="line">apricity@qiu 1.shell % a=&quot;first.sh:$&#123;a&#125;&quot;                                                                                    [0]</span><br><span class="line">apricity@qiu 1.shell % echo $a                                                                                              [0]</span><br><span class="line">first.sh:first.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">硬转义</span></span><br><span class="line">apricity@qiu 1.shell % a=&#x27;first.sh:$&#123;a&#125;&#x27;                                                                                    [0]</span><br><span class="line">apricity@qiu 1.shell % echo $a                                                                                              [0]</span><br><span class="line">first.sh:$&#123;a&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e “\033[32m 绿色字 \033[0m” </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">命令替换符``，替换命令</span></span><br><span class="line">apricity@qiu 1.shell % a=`pwd`                                                                                              [0]</span><br><span class="line">apricity@qiu 1.shell % pwd                                                                                                  [0]</span><br><span class="line">/home/apricity/linux/1.shell</span><br><span class="line">apricity@qiu 1.shell % echo $a                                                                                              [0]</span><br><span class="line">/home/apricity/linux/1.shell</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">apricity@qiu 1.shell % PATH=$&#123;PATH&#125;:first.sh                                                                                [0]</span><br><span class="line">apricity@qiu 1.shell % echo $PATH                                                                                           [0]</span><br><span class="line">/home/apricity/.autojump/bin:/home/apricity/.autojump/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:first.sh</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>特殊变量</p>
<p><code>echo $?</code>上一条命令的执行结果</p>
<p>read </p>
<p>​    -s静默模式输入密码</p>
<p>​    </p>
<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">__printf__</span></span>() &#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__printf__ <span class="string">&quot;hello guziqiu&quot;</span></span><br></pre></td></tr></table></figure>




<h2 id="4-流程控制语句"><a href="#4-流程控制语句" class="headerlink" title="4.流程控制语句"></a>4.流程控制语句</h2><h3 id="1-if"><a href="#1-if" class="headerlink" title="1.if"></a>1.<code>if</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> a</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> -gt 10 ]];<span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> &gt; 10&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> &lt;= 10&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> a</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;a&#125;</span> -gt 10 ]];<span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> &gt; 10&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="variable">$&#123;a&#125;</span> -eq 10 ]];<span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> = 10&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> &lt; 10&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>


<p><code>test</code>表达式</p>
<h3 id="2-while"><a href="#2-while" class="headerlink" title="2.while"></a>2.<code>while</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [[ condition ]]; do</span><br><span class="line">done</span><br></pre></td></tr></table></figure>




<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num=0</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$num</span> -lt 100 ]];<span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$&#123;num&#125;</span></span><br><span class="line">	num=$[ <span class="variable">$&#123;num&#125;</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>


<h3 id="3-case"><a href="#3-case" class="headerlink" title="3.case"></a>3.case</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">case words in</span><br><span class="line">		pattern)</span><br><span class="line">					;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> a</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$a</span> <span class="keyword">in</span></span><br><span class="line">	1)</span><br><span class="line">		<span class="built_in">echo</span> 1</span><br><span class="line">		;;</span><br><span class="line">	2)</span><br><span class="line">		<span class="built_in">echo</span> 2</span><br><span class="line">		;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> a</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$a</span> <span class="keyword">in</span></span><br><span class="line">	1)</span><br><span class="line">		<span class="built_in">echo</span> 1</span><br><span class="line">		;;</span><br><span class="line">	2)</span><br><span class="line">		<span class="built_in">echo</span> 2</span><br><span class="line">		;;</span><br><span class="line">	default)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;not found&quot;</span></span><br><span class="line">		;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>




<p>遍历当前目录所有文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `ls *.sh`;<span class="keyword">do</span>                                                                                [0]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">1.first.sh</span><br><span class="line">2.func.sh</span><br><span class="line">3.if.sh</span><br><span class="line">4.case.sh</span><br></pre></td></tr></table></figure>






<h3 id="4-for"><a href="#4-for" class="headerlink" title="4.for"></a>4.for</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for in in words; do</span><br><span class="line">done</span><br><span class="line">for (( i=0; i&lt;10; i++ )); do</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$@</span>;<span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1; i &lt;= 100; i++));<span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>






<h3 id="5-until"><a href="#5-until" class="headerlink" title="5.until"></a>5.until</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">until [[ condition ]];do</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">num=0</span><br><span class="line">until [[ <span class="variable">$num</span> -eq 100 ]];<span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$num</span></span><br><span class="line">	num=$[ <span class="variable">$&#123;num&#125;</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>






<p>100以内偶数求和</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">for</span> (( i=1; i&lt;=100; i++ ));<span class="keyword">do</span></span><br><span class="line">	<span class="keyword">if</span> [[ $[ <span class="variable">$&#123;i&#125;</span> % 2 ]  -eq 0 ]];<span class="keyword">then</span></span><br><span class="line">		sum=$[ <span class="variable">$&#123;sum&#125;</span> + <span class="variable">$&#123;i&#125;</span> ]</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;sum&#125;</span></span><br></pre></td></tr></table></figure>


<p>空格敏感，</p>
<p>=号左右不能加空格</p>
<p>$a变量名</p>
<p>$[ 整数计算 ]</p>
<p>[[ test表达式 ]]</p>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h2><p><code>declare -a a</code></p>
<blockquote>
<p>输出数组内容</p>
<p><code>$&#123;array[*]&#125;</code></p>
<p><code>$&#123;array[@]&#125;</code></p>
</blockquote>
<blockquote>
<p>确定数组元素个数</p>
<p><code>$&#123;#array[@]&#125;`



> 找到数组的下标
>
> `$&#123;!array[@]&#125;`



> 追加数组
>
> `array+=(a,b,c);`

> 数组排序
>
> `sort`

> 删除数组元素
>
> `unset`









<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apricity@qiu:~/linux/1.shell$ <span class="built_in">read</span> -a a</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ <span class="built_in">echo</span> <span class="variable">$&#123;a&#125;</span></span><br><span class="line">1</span><br><span class="line">apricity@qiu:~/linux/1.shell$ <span class="built_in">echo</span> <span class="variable">$&#123;a[1]&#125;</span></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ <span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ <span class="built_in">echo</span> <span class="variable">$&#123;a[*]&#125;</span></span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看数组下标</span></span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;!c[*]&#125;</span><br><span class="line">0 1 2</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;!c[@]&#125;</span><br><span class="line">0 1 2</span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ c+=(4 5 6)</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;c[@]&#125;</span><br><span class="line">0 1 3 4 5 6</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;c[@]&#125; | sort</span><br><span class="line">0 1 3 4 5 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ unset c</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;c[@]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu:~/linux/1.shell$ d=(1 2  3  4 5  6 7 8)</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;d[*]&#125;</span><br><span class="line">1 2 3 4 5 6 7 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;a[*]&#125;</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;a[1]&#125;</span><br><span class="line">2</span><br><span class="line">apricity@qiu:~/linux/1.shell$ unset a[1]</span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;a[1]&#125;</span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;a[*]&#125;</span><br><span class="line">1 3 4 5 6 7</span><br><span class="line"></span><br><span class="line">apricity@qiu:~/linux/1.shell$ echo $&#123;!a[*]&#125;</span><br><span class="line">0 2 3 4 5 6</span><br></pre></td></tr></table></figure>






素数筛



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">if [[ $# -ne 2 ]];then</span><br><span class="line">	echo &quot;error&quot;</span><br><span class="line">	exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">start=$1</span><br><span class="line">end=$2</span><br><span class="line"></span><br><span class="line">declare -a prime</span><br><span class="line"></span><br><span class="line">function init_prime() &#123;</span><br><span class="line">	local end=$1</span><br><span class="line">	local i</span><br><span class="line">	prime[1]=1</span><br><span class="line">	for (( i=2; i &lt;= $&#123;end&#125;; i++ ));do</span><br><span class="line">		for (( j=$[ 2 * $&#123;i&#125; ]; j &lt;= $&#123;end&#125;; j+=i ));do</span><br><span class="line"><span class="meta">			prime[$</span><span class="bash">&#123;j&#125;]=1</span></span><br><span class="line">		done</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_prime $&#123;end&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (( i=$&#123;start&#125;; i&lt;=$&#123;end&#125;; i++ ));do</span><br><span class="line">	if [[ $&#123;prime[$i]&#125;x == x ]];then</span><br><span class="line">		sum=$[ $&#123;sum&#125; + $&#123;i&#125; ]</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $&#123;sum&#125;</span><br></pre></td></tr></table></figure>






# 六、文件及目录



### 1.目录

`cd`切换到当前目录

`cd ..`切换到上层目录

`cd.`  切换到当前目录

`cd~/cd` 回到自己家目录

`cd -`回到 上次工作目录

`cd ~guziqiu/`切换到guziqiu的目录





`pwd` 打印当前工作目录



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -ald run/                                                                                             [0]</span><br><span class="line">drwxr-xr-x 21 root root 660 Dec  2 18:14 run/</span><br></pre></td></tr></table></figure>




`pwd -L`显示逻辑工作目录

`pwd -P`显示物理工作目录

（链接文件）

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apricity@qiu run % pwd                                                                                                       [0]</span><br><span class="line">/var/run</span><br><span class="line">apricity@qiu run % pwd -L                                                                                                    [0]</span><br><span class="line">/var/run</span><br><span class="line">apricity@qiu run % pwd -P                                                                                                    [0]</span><br><span class="line">/run</span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln ./1.shell/test/ .                                                                                    [0]</span><br><span class="line">ln: ./1.shell/test/: hard link not allowed for directory</span><br><span class="line"><span class="meta">#</span><span class="bash">hard link硬链接</span></span><br></pre></td></tr></table></figure>


`mkdir -p`自动创建父目录





!加一个命令匹配命令或者history里面的行数会输出显示该命令



`./a.out`

`./`是当前目录的意思





### 2.文件及目录管理



`cp [irapdslu]`

> ➢选项
> ➢`-i`: 若文件存在，询问用户
> ➢`-r`:递归复制
> `-a`:pdr的集合
> ➢`-p`:连同文件属性一起拷贝
> ➢`-d`: 若源文件为连接文件的属性，则复制连接文件的属性
> ➢`-s`:拷贝为软连接
> ➢`-1`:拷贝为硬连接
> ➢`-u`:源文件比目的文件新才拷贝
> ➢尝试: `cp filel file2 . dir`



`rm`

> `rm [irf]``
>
> ``-i`:互动模式
>
> `-r`:递归删除
>
> `-f`:force
>
> 



`mv`

> `mv [ifu]`
>
> `-i`:互动模式
>
> `-u`: 源文件更新才会移动
>
> `-f`:force



### 3.文件内容查阅

`cat`正向连续读

> ➢`cat [-AbEnTv] <file>`
> ➢选项:
> ➢`-A`:相当于-vET
> ➢-`V`:列出看不出的字符
> `-E`:显示断行符为`$`
> ➢`-T`:显示TAB为`^I`
> ➢`-b`:列出行号
> ➢`-n`:列出行号，连同空行也编号







`tac`反向连续读

`nl`输出行号显示文件

>➢`nl [-bnw] <file>`
>➢选项
>➢`-b`:行号指定的方式
>		`-b a`:相当于cat -n
>		`-b t`:相当于cat -b
>➢`-n`:列出行号的表示方法
>		`-n ln`:行号在屏幕最左边显示
>		`-n rn`:行号在自己字段的最右边显示
>		`-n rz`:行号在自己字段的最右边显示，前面自动补全0
>➢`-w <num>`:行号所占位数







`more`一页一页的显示内容



>MORE按页查看
>`more file`
>➢`/string`向下查找string关键字
>➢`:f`显示文件名称和当前显示的行数
>➢`q`离开
>







`less`与相似但是可以上下翻看

>LESS按页查看
>
>➢`less file`
>➢`/string`向下查找  `n`:继续向下查找
>➢`/?string`反向查找`N`:继续反向查询







`head`只看头几行

> HEAD查看头几行
> ➢`head [-n num] <file>`
> ➢`-nnum`:显示前num行
> ➢`-n -num`:除了后num行外，其他的都显示





`tail`只看尾几行

>TAIL查看末尾几行
>➢`tail [-n num] <file>`
>➢`-n num`:显示文件后num行
>➢`-n +num`:除了前num行，其他的都显示





`od`以二进制形式查看文件内容

>OD二_进制文件查看
>➢`od [-t TYPE] <file>`
>➢`-t` :
>	➢`a`:默认字符输出
>	➢`c`:ASCII字符输出
>	➢`d[size]`:十进制输出，每个数占用size bytes
>	➢`f[size]`:浮点数输出...
>	➢`o[size]`:八进制输出....
>	➢`x[size]:`十六进制输出...



more和all





### 4.修改文件时间与新建文件

> ➢文件的三个时间
> 	➢`mtime`:内容数据改动时才更新这个时间;
> 	➢`ctime`:文件的权限，属性改动时更新这个时间
> 	➢`atime`:文件的内容被取用access时，更新这个时间
> ➢`ls -1 --time=ctime /etc/hostname`







> ➢`touch [ - -acdmt] <file>`
> ➢`-a`:仅修改访问时间
> ➢`-c`:仅修改文件的时间，若文件不存在，不新建
> ➢`-d`:修改文件日期
> `-m`:仅修改mtime
> ➢`-t`:修改文件时间[ yymmddhhmm]

### 5.文件隐藏属性

> ➢`chattr [+-=][ASacdistu] <file_ or_ dir>`
> ➢`A`:不修改atime
> ➢`S`:同步写入
> ➢`a`:只能增加数据
> ➢`c`:自动压缩，解压
> ➢`d`:不会被dump程序备份
> ➢`i`:不能删除，修改，建立连接
> ➢`s`:文件删除时，直接从磁盘删除
> ➢`u`:文件删除时，数据内容存在磁盘中





> ➢`lsattr [-adR] <file_ or_ dir>`
> ➢`-a`:打印隐藏文件的隐藏属性
> ➢`-d`:如果是目录，仅打印目录的信息
> ➢`-R`:递归





### 6.文件的特殊权限



`set_iuid`




| 权限         |      | 作用对象               | 效果                                   |
| ------------ | ---- | ---------------------- | -------------------------------------- |
| `set_uid`    | S    | 二进制程序文件，非脚本 | 用户在执行改程序时获得程序所有者权限   |
| `set_gid`    | s    | 目录和二进制文件       | 用户在该目录里，有效组变为目录所属组， |
| `sticky bit` | t    | 目录                   | 在该目录下，用户只能删除自己创建的内容 |

`chmod +t file`



### 7.命令与文件的查询



`whereis`寻找特定文件

>➢`whereis [ - .bmsu] <file_or_dir>`
>➢`-b`:只查找二进制文件
>➢`-m`: 只查找manual路径下的文件
>➢`-s`:只查找source源文件
>`-u`:查找其他文件

`which`寻找执行文件，查找path路径下所有可执行文件



`locate` 搜索文件（可部分查找）

>`LOCATE`模糊定位
>➢`locate [-ir] keyword`
>➢`-i`:忽略大小写
>➢`-r`:后面可接正则表达式
>➢相关文件: `/ect/updatedb . conf`
>➢`/var/lib/mlocate`



`find`多样化高级查找

>`FIND`高级査找
>
>find 目录 -name 目录名
>
>➢`find [PATH] [ option] [action ]`
>➢与用户或用户组相关的参数:
>➢`-uid n`:用户UID为n
>➢`-gid n`:群组Gid为n
>➢`-user name`: 用户名为name
>➢`-group name`:群组名为name
>➢`-nouser`:文件所有者不存在
>➢`nogroup`:文件所在组不存在
>
>
>
>➢与文件权限及名称有关的参数:
>➢`-name filename`: 文件名为filename
>➢`-size [+-] SIZE`:查找比SIZE大或小的
>➢`-type TYPE`: `f b c d l s p` 
>➢`-perm mode`: mode刚好等于的文件
>➢-`perm -mode`:全部包含mode的文件
>➢`find -exec ls -l &#123;&#125; \;`
>
>-exec 命令的开始
>
>\命令结尾
>
>
>
>〉`find [PATH] [option] [ action]`
>与时间相关的参数: -`atime, -ctime, -mtime`
>`-mtime n`: n天前的“一天之内’修改的文件amin
>〉`-mtime +n`: n天之前，不包含n，修改过的文件
>〉`-mtime - -n`: n天之内，包含n,修改过的文件
>》`-newer file`: 比file还要新的文件





<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> ls -al `which passwd`                                                                                                     [10]</span><br><span class="line">-rwsr-xr-x 1 root root 59640 Mar 23  2019 /usr/bin/passwd</span><br></pre></td></tr></table></figure>






## linux三剑客awk

awk文本数据处理

`awk [-Ffv] 'BEGIN&#123; commands&#125; pattern &#123; commands&#125; END &#123; commands&#125;' file`

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">last | grep -v &quot;^$&quot; | grep -v &quot;wtmp&quot; | grep -v &quot;still&quot;| head -5 | awk &#x27;BEGIN &#123;print &quot;start\n&quot;&#125; &#123;if ($1 == &quot;apricity&quot;) &#123;print $10&#125;&#125; END &#123;printf(&quot;%s\n&quot;,&quot;Bye&quot;)&#125;&#x27;| grep -v &quot;^$&quot; |cut -c 2-6 |awk -F: -v hour=0 -v min=0 &#x27;&#123;hour+=$1;min+=$2&#125; END &#123;if (min&gt;=60) &#123;hour+=min/60;min=min%60&#125; printf(&quot;%d hours, %d min&quot;,hour,min)&#125;&#x27;</span><br><span class="line">3 hours, 2 min%</span><br></pre></td></tr></table></figure>










# 七、数据提取操作







| 命令    | 说明             | 命令    | 说明                 |
| ------- | ---------------- | ------- | -------------------- |
| `cut`   | 切分             | `grep`  | 检索                 |
| `sort`  | 排序             | `wc`    | 统计字符、字数、行数 |
| `uniq`  | 去重             | `tee`   | 双向重导项           |
| `split` | 文件切分         | `xargs` | `参数代换`           |
| `tr`    | 替换、压缩和删除 |         |                      |



## 1.cut 切分

>`➢cut [-dfc] <file>`
>
>​	`-d c`:以c字符分割(c在字符中)
>
>​	`-f num`: 显示num字段的内容`[n- ; n-m;-m]`
>​    `-b num`: 字节
>​	`-c num`: 字符

`cut -d : -f 1`

## 2.grep检索

>`grep [-acinv] <string> <fi1e>`
>	`-a`:将二进制文件以普通文件的形式搜寻数据
>	`-c`:统计搜寻到的次数
>
>​	`-C`:统计
>
>​	`-i`:忽略大小写
>​	`-n`:顺序输出行号
>​	`-v`:反向输出(输出没找到的)

`grep -v "^$"` 过滤空白符

​	



`ps -ef`   linux下任务管理器





 



## 3.sort排序



>➢`sort [ - fbMnrtuk] <file_ or_ stdio>`
>➢`-f`:忽略大小写
>➢`-b`:忽略最前面的空格符
>➢`-M`:以月份名称排序
>➢`-n`:以纯数字方式排序
>   `  -r`:反向排序
>➢`-u`:uniq
>➢`-t`:分割符，默认[TAB ]
>➢`-k`:以那个区间排序



## 4.WC统计字符,字数,行数

>`wc [ - lwm] <file_or_stdin>`
>➢`-1`:仅列出行号
>➢`-w`:仅列出多少字
>➢`-m`:仅列出多少字符



## 5.UNIQ去重

> ➢`uniq [-ic]`
> ➢`-i`:忽略大小写字符的不同
> ➢`-c`:进行计数





## 6.TEE 双向重导项

> `tee [-a] file`
> `-a`:append

 

## 7.SPLIT文件切分

> ➢`split [-bl] <file> PREFIX` 
> ➢`-b SIZE`: 切分为SIZE大小的文件
> ➢`-l num`: 以num行为大小切分

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /etc/ | split -l 10</span><br><span class="line">  ls                                                                     [0]</span><br><span class="line">xaa  xab  xac  xad  xae  xaf  xag  xah  xai  xaj  xak  xal  xam  xan  xao  xap  xaq  xar  xas</span><br></pre></td></tr></table></figure>


## 8.xargs参数代换

> ➢`xargs [ -0pne] <command>`
> ➢`-0`:将特殊字符还原为普通字符
> ➢`-eEOF`: 当xargs读到EOF时停止
> ➢`-p`:执行指令前询问
> ➢`-n num`: 每次执行command时需要的参数个数

<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/etc/&quot;</span> | xargs ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; . /bin /etc&quot;</span> | xargs -e<span class="string">&quot;/bin&quot;</span> ls                                [0]</span><br><span class="line">xaa  xab  xac  xad  xae  xaf  xag  xah	xai  xaj  xak  xal  xam  xan  xao  xap	xaq  xar  xas</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat /etc/passwd | cut -d : -f 1  |xargs -p -n 1 id</span><br><span class="line"></span><br></pre></td></tr></table></figure>




## 9.tr 对标准输入的字符替换,压缩,删除

> ➢`tr [cdst] <第一字符集> <第二字符集>`
> ➢`c` 用字符集二取代所有不属于第一字符集的字符
> ➢`d`删除所有属于第一字符集的字符
> ➢`s`将连续重复的字符以单独一个字符表示
> ➢`t`先删除第一字符集较第二字符集多出的字符

` man ls | tr -sc "a-zA-Z" " "`

`man ls | tr -sc "a-zA-Z" "\n" | sort | uniq -c | sort -nr | head -9`



## 10.数据提取练习



> 1.tr命令对文件的重命名，内容的替换操作



> #“1 2 3 4 5 6 7 9 a v 你好 . /8”
> #求以上字符串中所有数字之和

`echo "1 2 3 4 5 6 7 9 a v 你好 . /8" | tr -c "1-9" "\n" | grep -v "^$" | awk '&#123;sum+=$1&#125; END &#123;print sum&#125;'`
`45`

> #echo “ABCefg” >> test.log
>
> #请将该文件中所有大写字母转换为小写


 `echo  ABCefg | tr 'A-Z' 'a-z'`



> 2.找到`PATH`变量中的最后一个路径。



`echo $&#123;PATH&#125; | tr ":" "\n" | tail -1`



> 3.使用`last`命令,输出所有的关机信息。



`ast | grep "reboot"`



> 4.将`/etc/passwd`中的内容按照用户名排序。

`cat /etc/passwd | sort -t : -k 1`



> 5.将`/etc/passwd`中的内容按`uid`排序。

`cat /etc/passwd | sort -t : -k 3`



> 6.在云主机上查找系统登录用户的总人次。

`last | grep -v "^$" | grep -v "wtmp" | grep -v "reboot"  | wc -l`



> 7.将云主机中登录的所有用户名，按照次数排序，并输出次数。

`last | grep -v "^$" | grep -v "wtmp" | grep -v "reboot"  | cut -d " " -f 1 | sort | uniq  -c`
    105 apricity
     10 guziqiu
      9 root
      3 test

> 8.将本地的`/etc`目录下的文件及目录，每十条保存到一个文件中。

`ls /etc/ | split -l 10`

> 9.将`/etc/passwd`中存放的第10到20个用户，输出`uid`，`gid`和`groups`。

`cat /etc/passwd| head -n 20 | tail -n 10 | cut -d : -f 1 | xargs -n 1 id`

> 10.将按照用户名查看`/etc/passwd`中的用户，读到`'sync'`用户结束。

​		`cat /etc/passwd | cut -d : -f 1 | xargs -e"sync"`



> 11.词频统计

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用下面这个命令生成一个文本文件。</span><br><span class="line">cat &gt;&gt; a.txt &lt;&lt; <span class="string">xxx</span></span><br><span class="line"><span class="string">nihao hello hello 你好 </span></span><br><span class="line"><span class="string">nihao</span></span><br><span class="line"><span class="string">hello </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ls</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cd</span></span><br><span class="line"><span class="string">world</span></span><br><span class="line"><span class="string">pwd</span></span><br><span class="line"><span class="string">xxx</span></span><br></pre></td></tr></table></figure>
统计a.txt中各词的词频，并按照从大到小的顺序输出。

`cat a.txt | tr -s " " "\n" | sort | uniq -c | sort -n -r | awk '&#123;print $2, $1&#125;'`

`cat a.txt | tr  " " "\n" | grep -v "^$" | sort | uniq -c | sort -r`









# 八、软/硬链接



ext4文件系统将系统划分为inode、block、spuerblock（）

## 1.block

>文件是存储在硬盘上的，硬盘的最小存储单位叫做扇区`sector`，每个扇区存储`512字节`。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个块`block`。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是`4KB`，即连续八个`sector`组成一个`block`。



## 2.inode文件结点

> 文件数据存储在块中，那么还必须找到一个地方存储文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种存储文件元信息的区域就叫做`inode`，中文译名为`索引节点`，也叫`i节点`。因此，一个文件必须占用一个`inode`，但至少占用一个`block`。

- 元信息 → inode
- 数据 → block

------



>`inode`包含很多的文件元信息，但不包含文件名，例如：字节数、属主`UserID`、属组`GroupID`、读写执行权限、时间戳等。
>
>而文件名存放在目录当中，但`Linux`系统内部不使用文件名，而是使用`inode号码`识别文件。对于系统来说文件名只是`inode号码`便于识别的别称。





## 3.硬链接

> 通过文件系统的`inode`链接来产生的新的文件名，而不是产生新的文件，称为硬链接。
>
> 一般情况下，每个`inode`号码对应一个文件名，但是`Linux`允许多个文件名指向同一个`inode`号码。意味着可以使用不同的文件名访问相同的内容。



`ln 源文件 目标`



> 运行该命令以后，源文件与目标文件的`inode`号码相同，都指向同一个`inode`。`inode`信息中的链接数这时就会增加`1`。

> 当一个文件拥有多个硬链接时，对文件内容修改，会影响到所有文件名；但是删除一个文件名，不影响另一个文件名的访问。删除一个文件名，只会使得`inode`中的链接数减`1`。



> 需要注意的是不能对目录做硬链接。
>
> 通过`mkdir`命令创建一个新目录，其硬链接数应该有`2`个，因为常见的目录本身为`1`个硬链接，而目录下面的隐藏目录`.（点号）`是该目录的又一个硬链接，也算是`1`个连接数。
>
> 直观理解是，如果允许硬链接指向目录，假设目录.../d1/...与.../d2/...互为硬链接，那么在d1下必然包含目录项“..”，试问这个“..”应该指向d1还是d2?





## 4.软连接

类似于Windows的快捷方式功能的文件，可以快速连接到目标文件或目录，称为软链接。

`ln -s 源文件或目录 目标文件或目录`

>软链接就是再创建一个独立的文件，而这个文件会让数据的读取指向它连接的那个文件的文件名。
>
>例如，文件`A`和文件`B`的`inode`号码虽然不一样，但是文件`A`的内容是文件`B`的路径。读取文件`A`时，系统会自动将访问者导向文件`B`。这时，文件`A`就称为文件`B`的软链接`soft link`或者符号链接`symbolic link`。



>这意味着，文件`A`依赖于文件`B`而存在，如果删除了文件`B`，打开文件`A`就会报错。
>
>这是软链接与硬链接最大的不同：
>
>文件`A`指向文件`B`的文件名，而不是文件`B`的`inode`号码，
>
>文件`B`的`inode`链接数不会因此发生变化。







# 九、shell实现线性筛



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [[ $# -ne 2 ]];then</span><br><span class="line">	echo &quot;Usage: $0 start end&quot;</span><br><span class="line">	exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">start=$1</span><br><span class="line">end=$2</span><br><span class="line"></span><br><span class="line">declare -a prime</span><br><span class="line">sum=0</span><br><span class="line">for (( i=2; i&lt;=$&#123;end&#125;; i++ ));do</span><br><span class="line">	if [[ $&#123;prime[$i]&#125;x == x ]];then</span><br><span class="line">		prime[0]=$[ $&#123;prime[0]&#125; + 1 ]</span><br><span class="line"><span class="meta">		prime[$</span><span class="bash">&#123;prime[0]&#125;]=<span class="variable">$&#123;i&#125;</span></span></span><br><span class="line">	fi</span><br><span class="line">	for (( j=1; j&lt;=$&#123;prime[0]&#125;; j++ ));do</span><br><span class="line">		if [[ $[ $i * $&#123;prime[$j]&#125; ] -gt $&#123;end&#125; ]];then</span><br><span class="line">			break;</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">	done</span><br><span class="line">done</span><br><span class="line">for (( i=1; i&lt;=$&#123;prime[0]&#125;; i++ ));do</span><br><span class="line">	sum=$[ $&#123;sum&#125; + $&#123;prime[$i]&#125; ]</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure>






# 十、seq









1.替换文件每行中第一个出现的正则表达式，并打印结果:
`sed 's/&#123;&#123;regex&#125;&#125;/&#123;&#123;replace&#125;&#125;/&#39; &#123;&#123;filename&#125;&#125;</code></p>
</blockquote>
<p>2.***Replace all occurrences of an extended regular expression in a file, and print the result:<br><code>sed -r &#39;s/&#123;&#123;regex&#125;&#125;/&#123;&#123;replace&#125;&#125;/g&#39; &#123;&#123;filename&#125;&#125;</code></p>
<p><code>/g</code>全局替换</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">at a.log | sed <span class="string">&#x27;s/abc/123/&#x27;</span>                  </span><br><span class="line">123123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"> </span><br><span class="line">123</span><br><span class="line"></span><br><span class="line"> cat a.log | sed -r <span class="string">&#x27;s/abc/123/g&#x27;</span>                                         </span><br><span class="line">123123  123</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"> </span><br><span class="line">123</span><br></pre></td></tr></table></figure>


<p>3.Replace all occurrences of a string in a file, overwriting the file (i.e. in-place):<br><code>sed -i &#39;s/&#123;&#123;find&#125;&#125;/&#123;&#123;replace&#125;&#125;/g&#39; &#123;&#123;filename&#125;&#125;</code></p>
<p>4.- Replace only on lines matching the line pattern:<br>   <code>sed &#39;/&#123;&#123;line_pattern&#125;&#125;/s/&#123;&#123;find&#125;&#125;/&#123;&#123;replace&#125;&#125;/&#39; &#123;&#123;filename&#125;&#125;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed  &#x27;/1/s/abc/123/&#x27; a.log                                                                          </span><br><span class="line">123123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">cat a.log                                                                                         </span><br><span class="line">abc123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abc</span><br></pre></td></tr></table></figure>


<p>替换常用</p>
<ol start="5">
<li>***Delete lines matching the line pattern:<br><code>sed &#39;/&#123;&#123;line_pattern&#125;&#125;/d&#39; &#123;&#123;filename&#125;&#125;</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除5-7行</span></span><br><span class="line">apricity@Apricity test % cat a.log | sed &quot;5,7d&quot;                         </span><br><span class="line">abc123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apricity@Apricity test % cat a.log                                       </span><br><span class="line">abc123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">script</span></span><br><span class="line">echo &quot;abc&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">END</span></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">只删一行</span></span><br><span class="line">apricity@Apricity test % cat a.log | sed &quot;/script/d&quot;                                                                          [0]</span><br><span class="line">abc123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"></span><br><span class="line">echo &quot;abc&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">END</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure>


<p>6.***Replace separator / by any other character not used in the find or replace patterns, e.g., #: </p>
<p><code>sed &#39;s#&#123;&#123;find&#125;&#125;#&#123;&#123;replace&#125;&#125;#&#39; &#123;&#123;filename&#125;&#125;</code></p>
<p>可以用<code>#.,</code>代替<code>/</code></p>
<p>7.Print the first 11 lines of a file:<br><code>sed 11q &#123;&#123;filename&#125;&#125;</code></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-08%20%E4%B8%8A%E5%8D%8811.53.06.png" alt="截屏2020-12-08 上午11.53.06"></p>
<p>将123全部替换为abc</p>
<p>8.将行首替换为<code>$</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/^/\$/g&#x27; a.log                                                       </span><br><span class="line"><span class="meta">$</span><span class="bash">abc123  abc</span></span><br><span class="line"><span class="meta">$</span><span class="bash">frrrrrrtyd</span></span><br><span class="line"><span class="meta">$</span><span class="bash">axcvrewgfdddddds</span></span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="bash"><span class="variable">$#script</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;abc&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="comment">#END</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">abc</span></span><br></pre></td></tr></table></figure>




<p>9.找到//里面的内容并且删除直到行尾</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> cat a.log | sed &#x27;/script/,$d&#x27;                                           </span><br><span class="line">abc123  abc</span><br><span class="line">frrrrrrtyd</span><br><span class="line">axcvrewgfdddddds</span><br><span class="line"></span><br></pre></td></tr></table></figure>








<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><h2 id="1-vim"><a href="#1-vim" class="headerlink" title="1.vim"></a>1.vim</h2><p>快速跳转：</p>
<blockquote>
<p>行首                    0</p>
<p>行尾                    $</p>
<p>文件开始      gg</p>
<p>文件末尾        GG</p>
<p>任意行                :12,12G</p>
</blockquote>
<p>复制</p>
<blockquote>
<p>拷贝         yy</p>
<p>剪切            dd</p>
<p>多行操作   3yy/dd</p>
</blockquote>
<p>删除</p>
<blockquote>
<p>x  删除</p>
<p>2dd</p>
<p>d2G         删除两行</p>
</blockquote>
<p>vimtuter帮助手册</p>
<p>linux</p>
<blockquote>
<p>linux历史     </p>
<p>linux本质：linux内核操作系统，其他功能是各开发商开发</p>
<p>unix：云计算后开始减少</p>
</blockquote>
<h2 id="2-shell"><a href="#2-shell" class="headerlink" title="2.shell"></a>2.shell</h2><p>zsh</p>
<blockquote>
<p>zsh相关文件</p>
<blockquote>
<p>zshenv：一般放环境变量</p>
<p>zprofile：用于用户login时读入（执行）的配置</p>
<p>zshrc：用户开启交互是命令行时读入的配置</p>
</blockquote>
<p>环境变量概念:</p>
<p>环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。</p>
<p>执行命令的本质：从文件系统调用执行文件，返回结果</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-15%20%E4%B8%8A%E5%8D%8811.47.50.png" alt="截屏2020-12-15 上午11.47.50"></p>
<p>僵尸进程，父亲生了孩子，孩子没有被回收</p>
<p>man手册</p>
<blockquote>
<p>man  </p>
<p>tldr</p>
<p>man -k</p>
<p>检索   前后移动</p>
<p>Baidu</p>
<p>查找命令</p>
<p>tab          自动补全命令</p>
<p>man -k</p>
<ul>
<li>man -k：根据关键字搜索联机帮助，是一种模糊搜索。例如要查找”passwd”相关的信息，使用man -k passwd会找到很多和passwd相关的帮助页。</li>
<li>man -f：关键字精确搜索，与-k不同，它只搜索与关键字完全匹配的帮助页</li>
</ul>
</blockquote>
<h2 id="3-linux具体使用"><a href="#3-linux具体使用" class="headerlink" title="3.linux具体使用"></a>3.linux具体使用</h2><p>文件及目录</p>
<p>远程拷贝ssh  、sshfs、scp</p>
<p>sshfs:远程挂载</p>
<p>文件查阅  <a href="#3.%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E9%98%85">查阅</a></p>
<blockquote>
<p><code>cat</code></p>
<p><code>head</code></p>
<ul>
<li>-n&lt;行数&gt; 显示的行数。</li>
</ul>
<p><code>tail</code></p>
<ul>
<li>-n&lt;行数&gt; 显示文件的尾部 n 行内容</li>
</ul>
<p><code>tail -f</code></p>
<ul>
<li><p>-f 循环读取</p>
</li>
<li><pre><code>tail -f notes.log
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  此命令显示 notes.log 文件的最后 10 行。当将某些行添加至 notes.log 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。</span><br><span class="line"></span><br><span class="line">&#96;more&#96; </span><br><span class="line"></span><br><span class="line">&#96;less&#96;可回看、检索信息高亮显示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">移动和复制</span><br><span class="line"></span><br><span class="line">&#96;cp&#96;</span><br><span class="line"></span><br><span class="line">&#96;mv&#96;</span><br><span class="line"></span><br><span class="line">&#96;ln&#96;硬链接，软链接</span><br><span class="line"></span><br><span class="line">&#96;rm&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件类型及权限  </span><br><span class="line"></span><br><span class="line">七种：</span><br><span class="line"></span><br><span class="line">普通文件</span><br><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">字符</span><br><span class="line"></span><br><span class="line">块</span><br><span class="line"></span><br><span class="line">管道</span><br><span class="line"></span><br><span class="line">链接</span><br><span class="line"></span><br><span class="line">socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">权限 &#96;rwx&#96;   </span><br><span class="line"></span><br><span class="line">&gt;目录&#96;x&#96;可以&#96;cd&#96;进去</span><br><span class="line"></span><br><span class="line">&gt;用户分组 &#96;ugo&#96;</span><br><span class="line"></span><br><span class="line">&gt;命令</span><br><span class="line"></span><br><span class="line">&gt;&#96;chmod、chgrp、chown、usermod&#96;</span><br><span class="line"></span><br><span class="line">&gt;特殊权限：</span><br><span class="line"></span><br><span class="line">&gt;&#96;set uid&#96;</span><br><span class="line"></span><br><span class="line">&gt;只能改自己的权限</span><br><span class="line"></span><br><span class="line">&gt;&#96;set gid&#96;		用户临时进入目录时，创建一个文件时，该用户会临时变成目录所属组</span><br><span class="line"></span><br><span class="line">&gt;&#96;sed uid&#96;		当用户执行文件时，用户临时拥有此文件，如密码文件</span><br><span class="line"></span><br><span class="line">&gt;&#96;sbit&#96;黏着位		目录下的文件只能被所属者删掉</span><br><span class="line"></span><br><span class="line">&gt;隐藏属性  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.文件时间</span><br><span class="line"></span><br><span class="line">&#96;atime&#96;		访问时间，跟新过于频繁也不好，耗时</span><br><span class="line"></span><br><span class="line">&#96;ctime&#96;		修改时间</span><br><span class="line"></span><br><span class="line">&#96;mtime&#96;		修正时间   ls默认</span><br><span class="line"></span><br><span class="line">&#96;touch&#96;       创建文件，修改时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件定位：</span><br><span class="line"></span><br><span class="line">特殊文件：</span><br><span class="line"></span><br><span class="line">&#96;which&#96;</span><br><span class="line"></span><br><span class="line">&#96;whereis&#96;</span><br><span class="line"></span><br><span class="line">普通文件</span><br><span class="line"></span><br><span class="line">&#96;locate&#96;  	db updatedb(基于数据库)</span><br><span class="line"></span><br><span class="line">&#96;find&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据处理[数据提取操作](#七、数据提取操作)</span><br><span class="line"></span><br><span class="line">cut		</span><br><span class="line"></span><br><span class="line">tr</span><br><span class="line"></span><br><span class="line">sort</span><br><span class="line"></span><br><span class="line">uniq</span><br><span class="line"></span><br><span class="line">grep</span><br><span class="line"></span><br><span class="line">awk</span><br><span class="line"></span><br><span class="line">sed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重定向</span><br><span class="line"></span><br><span class="line">\&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&gt;&gt;</span><br><span class="line"></span><br><span class="line">&lt;</span><br><span class="line"></span><br><span class="line">&lt;&lt;</span><br><span class="line"></span><br><span class="line">&#x2F;\&#96;a\&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读入数据:read</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">vim 1.sh</span><br><span class="line">read a</span><br><span class="line">read b</span><br><span class="line">echo$[ $a + $b ]</span><br><span class="line"></span><br><span class="line">vim 1.in</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">bash 1.sh &lt; 1.in</span><br><span class="line">5</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim 2.sh</span><br><span class="line">str=&#x27;&#x27;</span><br><span class="line">read str</span><br><span class="line">echo $&#123;str&#125;</span><br><span class="line">vim 2.in</span><br><span class="line">guziqiu is 18years old.</span><br><span class="line"></span><br><span class="line">bash 2.sh &lt; 2.in</span><br></pre></td></tr></table></figure>






<p>进程管理</p>
<blockquote>
<p><code>fg</code></p>
<p><code>bg</code></p>
<p><code>jobs</code></p>
</blockquote>
<p>定时任务</p>
<blockquote>
<p>crontab -e</p>
</blockquote>
<p>系统信息获取</p>
<blockquote>
<p><code>unname</code></p>
<p><code>top</code></p>
<p><code>free</code></p>
<p><code>dstat</code></p>
<p><code>htop</code></p>
<p><code>nmon</code></p>
<p><code>uptime</code></p>
</blockquote>
<h2 id="4-shell编程"><a href="#4-shell编程" class="headerlink" title="4.shell编程"></a>4.shell编程</h2><p>变量</p>
<blockquote>
<p>命令替换符</p>
<p>特殊变量</p>
<p><code>$0￥</code></p>
<p><code>$#</code></p>
<p><code>$?</code></p>
<p><code>$@</code></p>
<p><code>$*</code></p>
</blockquote>
<p>=两边没有空格</p>
<p>输入输出</p>
<blockquote>
<p>read </p>
<p>echo </p>
<p>printf </p>
</blockquote>
<p>分支</p>
<blockquote>
<p>test表达式 </p>
<p>​        man test</p>
<p>整数判断：整数计算</p>
<p>字符串     ==</p>
</blockquote>
<blockquote>
<p>if [[  ]]</p>
</blockquote>
<blockquote>
<p>case</p>
</blockquote>
<p>循环 for </p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in `seq 1 100`</span><br></pre></td></tr></table></figure>

<p><code>for (( i =1;  i&lt;= 100;i++ ))</code>(推荐)</p>
<p><code>while</code></p>
<p><code>until</code></p>
</blockquote>
<p>函数</p>
<p>数组</p>
<blockquote>
<p>数组初始化</p>
<p>unset</p>
<p>遍历</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/1.png" alt="1"></p>
]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>面试笔试算法下</title>
    <url>/2020/12/22/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E4%B8%8B/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="1-线段树"><a href="#1-线段树" class="headerlink" title="1.线段树"></a>1.线段树</h1><h2 id="0-线段树结构"><a href="#0-线段树结构" class="headerlink" title="0.线段树结构"></a>0.线段树结构</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.22.png" alt="截屏2020-12-31 上午11.32.22" style="zoom: 50%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.35.png" alt="截屏2020-12-31 上午11.32.35" style="zoom:50%;" />





<h2 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1.问题背景"></a>1.问题背景</h2><ol>
<li>单点修改，区间查询（基础版）</li>
<li>区间修改，区间查询（进阶版）</li>
<li>单点修改，单点查询（用不着线段树）</li>
<li>区间修改，单点查询（是第二种情况的特例）</li>
</ol>
<h2 id="2-线段树区间查询及单点修改"><a href="#2-线段树区间查询及单点修改" class="headerlink" title="2.线段树区间查询及单点修改"></a>2.线段树区间查询及单点修改</h2><h3 id="1-操作"><a href="#1-操作" class="headerlink" title="1.操作"></a>1.操作</h3><p>Modify(7,9) ：修改7位置上的值为9</p>
<p>Query(2, 6) : 查询[2,6]区间的和值==&gt; 30</p>
<p>Modify(2,3) ：修改2位置上的值为3</p>
<p>Query(2, 6) : 查询[2,6]区间的和值==&gt; 25</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.10.png" alt="截屏2020-12-31 上午11.32.10" style="zoom:50%;" />



<h3 id="2-具体过程"><a href="#2-具体过程" class="headerlink" title="2.具体过程"></a>2.具体过程</h3><p>1）Modify(2,3)<!--图中0--1出有错误,tree[0]=8 --></p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.42.png" alt="截屏2020-12-31 上午11.32.42" style="zoom:50%;" />



<p>2）将2上面的值改为3</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.48.png" alt="截屏2020-12-31 上午11.32.48" style="zoom:50%;" />

<p>3）更新根节点上的和值</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.56.png" alt="截屏2020-12-31 上午11.32.56" style="zoom:50%;" />

<p>4）Query(2, 6) :</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.33.02.png" alt="截屏2020-12-31 上午11.33.02" style="zoom:50%;" />





<h2 id="3-基础版线段树"><a href="#3-基础版线段树" class="headerlink" title="3.基础版线段树"></a>3.基础版线段树</h2><ol>
<li>线段树是对于一维序列的一种维护结构</li>
<li>采用的分治的思想，将总区间分成左右两部分，一直进行下去，直到区间中只剩下一个节点为止</li>
<li>线段树的叶子结点，代表了原序列中的单个位置的值</li>
<li>如果采用完全二叉树的存储结构的话，最起码需要 $4n$ 的存储空间</li>
<li>当面对区间修改的时候，基础版的线段树效率上还不如直接在一维序列上修改</li>
<li>只适用于单点修改，区间查询</li>
</ol>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.37.41.png" alt="截屏2020-12-31 上午11.37.41"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//海贼OJ222</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> max_num;<span class="comment">//结点和值</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">&#125; tree[MAX_N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> arr[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> ind)</span> </span>&#123;<span class="comment">//更新结点的和值</span></span><br><span class="line">    tree[ind].max_num = max(tree[ind &lt;&lt; <span class="number">1</span>].max_num, tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].max_num);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//创建线段树,在tree[ind]上插入l，r</span></span><br><span class="line">    tree[ind].l = l;</span><br><span class="line">    tree[ind].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;<span class="comment">//l==r，l、r各代表一个值，不能再分裂</span></span><br><span class="line">        tree[ind].max_num = arr[l];<span class="comment">//将值挂在叶子结点上</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build_tree(ind * <span class="number">2</span>, l, mid);<span class="comment">//递归左子树</span></span><br><span class="line">    build_tree(ind * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);<span class="comment">//递归右子树</span></span><br><span class="line">    update(ind);<span class="comment">//更新和值</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;<span class="comment">//修改tree[ind]上tree[k]的值为value,ind代表当前节点的编号</span></span><br><span class="line">    <span class="keyword">if</span> (tree[ind].l == tree[ind].r) &#123;</span><br><span class="line">        tree[ind].max_num = val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[ind].l + tree[ind].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= mid ) &#123;</span><br><span class="line">        modify(ind &lt;&lt; <span class="number">1</span>, k, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        modify(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, k, val);</span><br><span class="line">    &#125;</span><br><span class="line">    update(ind);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">//查询[x,y]的和值</span></span><br><span class="line">    <span class="keyword">if</span> (tree[ind].l &gt;= x &amp;&amp; tree[ind].r &lt;= y) &#123;<span class="comment">//要查找的值在这个根的</span></span><br><span class="line">        <span class="keyword">return</span> tree[ind].max_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[ind].l + tree[ind].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= x) &#123;<span class="comment">//在左子树中查找</span></span><br><span class="line">        ans = max(ans, Query(ind &lt;&lt; <span class="number">1</span>, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) &#123;<span class="comment">//在右子树中查找</span></span><br><span class="line">        ans = max(ans, Query(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    build_tree(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: modify(<span class="number">1</span>, b, c); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (b &gt; c) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-2147483648&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; Query(<span class="number">1</span>, b, c) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>==&gt;总结</p>
<p>单点查询：log(n)</p>
<p>区间查询：log(n)</p>
<blockquote>
<p>1.若采用完全能二叉树的存储方式，n个节点的线段树，最多需要多少个节点空间？</p>
<p>$n + n - 1 + 2n = 4n -1$</p>
<p>2.如何做区间修改</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8810.56.59.png" alt="截屏2020-12-31 下午10.56.59"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8810.59.54.png" alt="截屏2020-12-31 下午10.59.54"></p>
<p>其实节点上l，r可以省略</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.01.08.png" alt="截屏2020-12-31 下午11.01.08"></p>
<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//海贼OJ222</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> max_num;<span class="comment">//子树的和值</span></span><br><span class="line">&#125; tree[MAX_N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> arr[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> ind)</span> </span>&#123;<span class="comment">//更新结点的和值</span></span><br><span class="line">    tree[ind].max_num = max(tree[ind &lt;&lt; <span class="number">1</span>].max_num, tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].max_num);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//创建线段树,在ind上插入l，r</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;<span class="comment">//l==r，l、r各代表一个值，不能再分裂</span></span><br><span class="line">        tree[ind].max_num = arr[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build_tree(ind * <span class="number">2</span>, l, mid);</span><br><span class="line">    build_tree(ind * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    update(ind);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;<span class="comment">//在tree[ind](ind当前节点位置）维护的区间[l, r],上将tree[k]的值修改为val、</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[ind].max_num = val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= mid ) &#123;</span><br><span class="line">        modify(ind &lt;&lt; <span class="number">1</span>, l, mid, k, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        modify(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, k, val);</span><br><span class="line">    &#125;</span><br><span class="line">    update(ind);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">//查询</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;<span class="comment">//要查找的值在这个根的</span></span><br><span class="line">        <span class="keyword">return</span> tree[ind].max_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= x) &#123;<span class="comment">//在左子树中查找</span></span><br><span class="line">        ans = max(ans, Query(ind &lt;&lt; <span class="number">1</span>, l, mid, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) &#123;<span class="comment">//在右子树中查找</span></span><br><span class="line">        ans = max(ans, Query(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<span class="comment">//n,数组长度，m,操作数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    build_tree(<span class="number">1</span>, <span class="number">1</span>, n);<span class="comment">//初始化线段树tree,根节点的范围是[1, n]</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: modify(<span class="number">1</span>, <span class="number">1</span>, n, b, c); <span class="keyword">break</span>;<span class="comment">//在根节点[1, n]上修改tree[b]的值为c</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (b &gt; c) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-2147483648&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; Query(<span class="number">1</span>, <span class="number">1</span>, n, b, c) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//在根节点tree[1,n]上查找[b, c]区间上的和值</span></span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="5-线段树区间修改"><a href="#5-线段树区间修改" class="headerlink" title="5.线段树区间修改"></a>5.线段树区间修改</h2><p>明朝时期有一位官员，皇帝下放粮食，下发到县令手里，县令自己拿着粮食，不下发，突然有一天，皇帝要微服私访，此时县令下发粮食</p>
<h3 id="1-Modify-0-6-3"><a href="#1-Modify-0-6-3" class="headerlink" title="1.Modify(0, 6, +3)"></a>1.Modify(0, 6, +3)</h3><p>1)在区间[0, 6]的结点上加3，此时在懒标记上加3而不是在叶子结点上加3，县令自己拿了粮食不下发给百姓</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.02.12.png" alt="截屏2020-12-31 下午11.02.12" style="zoom: 67%;" />



<p>2)叶子结点的值不变，但是区间根节点的值发生改变，农民没有拿到粮食，但是县令拿到了，县令上报农民已经拿到了粮食，向上更新区间和值</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.05.35.png" alt="截屏2020-12-31 下午11.05.35" style="zoom: 67%;" />

<h3 id="2-Query-2-7"><a href="#2-Query-2-7" class="headerlink" title="2.Query(2,7)"></a>2.Query(2,7)</h3><p>1）查询[2,7]区间上的和值</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.07.33.png" alt="截屏2020-12-31 下午11.07.33" style="zoom:67%;" />



<p>2）开始递归向下查找</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.08.27.png" alt="截屏2020-12-31 下午11.08.27" style="zoom:67%;" />





<p>3） <code>2 &lt; 4</code>  = ( 9 / 2) 到左子树查找</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.09.27.png" alt="截屏2020-12-31 下午11.09.27" style="zoom:67%;" />



<p>4)左子树中有懒标记，皇帝要来视察民情，县令下方粮食，懒标记下沉，</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.09.58.png" alt="截屏2020-12-31 下午11.09.58" style="zoom:67%;" />



<ol start="5">
<li><p>继续向下查询，</p>
<p><code>2 = 2</code>  = ( 4 / 2 )  向左子树递归</p>
</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.10.12.png" alt="截屏2020-12-31 下午11.10.12" style="zoom:67%;" />



<p>6)左子树有懒标记，懒标记下沉</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.10.24.png" alt="截屏2020-12-31 下午11.10.24" style="zoom:67%;" />



<ol start="7">
<li><code>2 &gt; 1</code> = 2 / 2 ,在右子树中查询，</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.10.38.png" alt="截屏2020-12-31 下午11.10.38" style="zoom:67%;" />



<p>8）找到节点2,更新结点的值，返回节点2的值</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.10.57.png" alt="截屏2020-12-31 下午11.10.57" style="zoom:67%;" />



<ol start="9">
<li>向上回溯，(4/2 + 1) = <code>3 &gt; 2</code>，4 &lt; 7  递归到右子树</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.11.10.png" alt="截屏2020-12-31 下午11.11.10" style="zoom:67%;" />



<ol start="10">
<li>结点的区间在待查找区间范围内，直接返回3-4结点的值</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.11.22.png" alt="截屏2020-12-31 下午11.11.22" style="zoom:67%;" />



<p>11） 向上回溯，(0 + 9) / 2  + 1= 5  &lt; 7 递归到右结点5–-9</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.11.39.png" alt="截屏2020-12-31 下午11.11.39" style="zoom:67%;" />





<p>12） (5 + 9) / 2 = 7 == 7,递归5–9左子树</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.11.51.png" alt="截屏2020-12-31 下午11.11.51" style="zoom:67%;" />

<ol start="13">
<li>找到结点 ，返回值</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.12.06.png" alt="截屏2020-12-31 下午11.12.06" style="zoom:67%;" />



<ol start="14">
<li>向上回溯，返回区间和值</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.12.16.png" alt="截屏2020-12-31 下午11.12.16" style="zoom:67%;" />







<h2 id="6-进阶版线段树"><a href="#6-进阶版线段树" class="headerlink" title="6.进阶版线段树"></a>6.进阶版线段树</h2><ol>
<li>优化掉了代码实现中的：l，r。区间变量</li>
<li>可以用于区间更新，区间查询</li>
<li>增加了懒标记，达到能够区间更新的目的</li>
<li>懒标记是需要向下下沉的</li>
<li>==标记下沉发生在递归之前，向上更新发生在具有修改操作的递归之后==</li>
</ol>
<h2 id="7-代码实现"><a href="#7-代码实现" class="headerlink" title="7.代码实现"></a>7.代码实现</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8810.48.39.png" alt="截屏2020-12-31 下午10.48.39"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> intl;</span><br><span class="line">intl flag = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    intl sum;<span class="comment">//和值</span></span><br><span class="line">    intl tag;<span class="comment">//懒标记</span></span><br><span class="line">&#125; tree[MAX_N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">intl arr[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(intl ind)</span> </span>&#123;<span class="comment">//更新tee[ind]结点和值</span></span><br><span class="line">    tree[ind].sum = tree[ind &lt;&lt; <span class="number">1</span>].sum + tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    <span class="comment">//tree[ind].sum = tree[ind * 2].sum + tree[ind * 2 + 1].sum;</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(intl index, intl left, intl right)</span> </span>&#123;<span class="comment">//懒标记下沉</span></span><br><span class="line">    <span class="keyword">if</span> (tree[index].tag) &#123;<span class="comment">//如果存在懒标记值 &gt; 0</span></span><br><span class="line">        intl mid = (left + right) &gt;&gt;  <span class="number">1</span>;</span><br><span class="line">        intl value = tree[index].tag;</span><br><span class="line">        tree[index &lt;&lt; <span class="number">1</span>].sum += value * (mid - left + <span class="number">1</span>);<span class="comment">//懒标记下沉左子树</span></span><br><span class="line">        tree[index &lt;&lt; <span class="number">1</span>].tag += value;</span><br><span class="line">        tree[index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += value * (right - mid);<span class="comment">//right - (mid + 1)+1//懒标记下沉右子树</span></span><br><span class="line">        tree[index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].tag += value;</span><br><span class="line">        tree[index].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(intl index, intl left, intl right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//初始化线段树tree[index],线段树区间为[left, right],right = n,即有n个值要存在线段树中</span></span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;<span class="comment">//左右区间相等，即为叶子节点，存放值</span></span><br><span class="line">        tree[index].sum = arr[left];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    intl mid = (left + right) &gt;&gt;  <span class="number">1</span>;</span><br><span class="line">    build_tree(index &lt;&lt; <span class="number">1</span>, left, mid);<span class="comment">//</span></span><br><span class="line">    build_tree(index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">    update(index);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(intl index, intl left, intl right, intl x, intl y, intl value)</span> </span>&#123;</span><br><span class="line">    <span class="function">flag &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;modify(%lld, %lld, %lld) : %lld, %lld, %lld, %lld\n&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                       x, y, value, index, left, right, tree[index].sum</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">    <span class="comment">//从根节点tree[index]开始查询，根节点的区间是[left, right],找到区间[x, y],把[x, y]区间上的值加上value</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= left &amp;&amp; right &lt;= y) &#123;<span class="comment">//待操作区间在包含区间的范围内，即要修改的区间比根节点区间大</span></span><br><span class="line">        tree[index].sum += value * (right - left + <span class="number">1</span>);</span><br><span class="line">        tree[index].tag += value;<span class="comment">//懒标记，皇帝给农民发放粮食，县令不放</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    down(index, left, right);<span class="comment">//懒标记下沉，皇帝要微服私访，县令下发粮食</span></span><br><span class="line">    intl mid = (left + right) &gt;&gt;  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= x) &#123;</span><br><span class="line">        modify(index &lt;&lt; <span class="number">1</span>, left, mid, x, y, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) &#123;</span><br><span class="line">        modify (index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, x, y, value);</span><br><span class="line">    &#125;</span><br><span class="line">    update(index);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">intl <span class="title">Query</span><span class="params">(intl index, intl left, intl right, intl x, intl y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= left &amp;&amp; right &lt;= y) &#123;<span class="comment">//要查询的区间[x, y]在[left, right]范围内</span></span><br><span class="line">        <span class="keyword">return</span> tree[index].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    down(index, left, right);</span><br><span class="line">    intl mid = (left + right) &gt;&gt;  <span class="number">1</span>;</span><br><span class="line">    intl ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= x) &#123;</span><br><span class="line">        ans += Query(index &lt;&lt; <span class="number">1</span>, left, mid, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) &#123;</span><br><span class="line">        ans += Query(index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    intl n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (intl i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, arr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    build_tree(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    intl a, b, c, d;</span><br><span class="line">    <span class="keyword">for</span> (intl i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">                    modify(<span class="number">1</span>, <span class="number">1</span>, n, b, c, d);</span><br><span class="line">                &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (b &gt; c) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>( <span class="string">&quot;0\n&quot;</span> );</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Query(<span class="number">1</span>, <span class="number">1</span>, n, b, c));<span class="comment">//从根节点开始查询，根节点的范围是[1,n],查询[b,c]区间范围内的值</span></span><br><span class="line">                &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="2-从递推动归-上"><a href="#2-从递推动归-上" class="headerlink" title="2.从递推动归(上)"></a>2.从递推动归(上)</h1><h2 id="1-兔子繁殖问题"><a href="#1-兔子繁殖问题" class="headerlink" title="1.兔子繁殖问题"></a>1.兔子繁殖问题</h2><p>兔子繁殖问题：斐波那切数列</p>
<p><strong>题目：</strong>如果1对兔子每月能生1对小兔子，而每对小兔在它出生后的第3个月就可以生1对小兔子，如果从1对初生的小兔子开始，1年后能繁殖多少兔子?</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%888.10.32.png" alt="截屏2021-01-01 下午8.10.32" style="zoom: 80%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/IMG_20210101_194745.jpg" style="zoom:15%;" />





<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%888.12.49.png" alt="截屏2021-01-01 下午8.12.49"></p>
<blockquote>
<p>思考：当存在n = 40,程序会有什么问题？当n=60呢？</p>
</blockquote>
<ol>
<li><p>程序运行效率问题(会出现重复计算的现象，如下图)</p>
<p>解决方法：递归过程加记忆化(用数组记忆)  或  改成逆向递推求解(从f(1)求解到f(n),利用循环求解)</p>
</li>
<li><p>程序计算结果超出整数范围，结果溢出出错</p>
<p>解决方法：改成大整数求解</p>
</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%888.15.11.png" alt="截屏2021-01-01 下午8.15.11" style="zoom:67%;" />





<h2 id="2-如何求解递推问题"><a href="#2-如何求解递推问题" class="headerlink" title="2.如何求解递推问题"></a>2.如何求解递推问题</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%888.27.42.png" alt="截屏2021-01-01 下午8.27.42" style="zoom: 80%;" />



<blockquote>
<p>递推问题求解套路</p>
</blockquote>
<ol>
<li>确定递推状态，一个数学符号 + 一个数学符号的语义解释</li>
<li>确定递推公式，推导递推状态符号的自我表示方法</li>
<li>程序实现，（递归+记忆化 / 循环实现）</li>
</ol>
<h3 id="确定递推状态"><a href="#确定递推状态" class="headerlink" title="确定递推状态"></a>确定递推状态</h3><p>注意：这是学习递推问题的重中之重。学习确定递推状态的技巧。</p>
<p>$f(x) = y$</p>
<p>y：问题中的求解量，也是我们所谓的因变量</p>
<p>x：问题中直接影响求解量的部分，也是我们所谓的自变量</p>
<p>本质：就是寻找问题中的自变量与因变量</p>
<h3 id="推导递推公式"><a href="#推导递推公式" class="headerlink" title="推导递推公式"></a>推导递推公式</h3><p>本质：分析状态中的容斥关系(互相排斥)</p>
<p>$f(n)=f(n-1)+f(n-2)$</p>
<p>$f(n-1)$，代表 n-1个月的兔子数量，恰巧等于第 n 个月的成年兔子数量</p>
<p>$f(n-2)$，代表 n-2个月的兔子数量，恰巧等于第 n 个月的幼年兔子数量</p>
<p>所谓的推导，就是推导上面的这两句话的内容</p>
<h2 id="3-爬楼梯问题"><a href="#3-爬楼梯问题" class="headerlink" title="3.爬楼梯问题"></a>3.爬楼梯问题</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lALPDiQ3NHubpPPNB3LNCzg_2872_1906.png_720x720g.jpg" alt="lALPDiQ3NHubpPPNB3LNCzg_2872_1906.png_720x720g" style="zoom:80%;" />



<h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><p>$f(n)$ 代表爬 n 节楼梯的方法总数</p>
<h3 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h3><p>$f(n)=f(n - 2) + f(n - 3)$</p>
<p>==&gt;用容斥原理对最后一种台阶的情况进行分类，展开讨论，分类后求和(站在最后面往前看)</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%8811.03.04.png" alt="截屏2021-01-01 下午11.03.04" style="zoom:67%;" />

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%8811.00.14.png" alt="截屏2021-01-01 下午11.00.14" style="zoom:67%;" />





<h2 id="4-凑钱币问题"><a href="#4-凑钱币问题" class="headerlink" title="4.凑钱币问题"></a>4.凑钱币问题</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lALPDgfLP1Vs-lrNCBrNC5Q_2964_2074.png_720x720g.jpg" alt="lALPDgfLP1Vs-lrNCBrNC5Q_2964_2074.png_720x720g"></p>
<h3 id="状态定义-1"><a href="#状态定义-1" class="headerlink" title="状态定义"></a>状态定义</h3><p>$f(n, m)$ 代表用前 n 种钱币，拼凑 m 元钱的方案总数</p>
<h3 id="递推公式-1"><a href="#递推公式-1" class="headerlink" title="递推公式"></a>递推公式</h3><p>$f(n, m) = f(n - 1, m) + f(n, m - val[n])*1$</p>
<p>没有使用n种钱币的方法+使用n种钱币的方法（拼凑m元钱的方案中减去最后一种钱币金额，确保最后一种金额只能为第n中钱币，即val[n]）</p>
<p>==&gt;递推技巧：用容斥原理对最后一种钱币讨论：（使用了第n种钱币/没有使用第n种钱币）拼凑了m元钱 </p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lADPDhYBOei5ckPNA3_NBQA_1280_895.jpg_720x720g.jpg" alt="lADPDhYBOei5ckPNA3_NBQA_1280_895.jpg_720x720g" style="zoom:80%;" />





<h2 id="5-墙壁涂色"><a href="#5-墙壁涂色" class="headerlink" title="5.墙壁涂色"></a>5.墙壁涂色</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lALPDhYBOeiGuN3NB-7NC1w_2908_2030.png_720x720g-1.jpg" alt="lALPDhYBOeiGuN3NB-7NC1w_2908_2030.png_720x720g-1"></p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>技巧：先按照非环情况做，保证所有方案之间，相邻墙壁颜色不同，最后再保证首尾颜色不同</p>
<h4 id="状态定义-2"><a href="#状态定义-2" class="headerlink" title="状态定义"></a>状态定义</h4><p>$f(n, i, j)$ 代表 n 块墙壁，第一块涂颜色 i，最后一块涂颜色 j 的方案总数</p>
<h4 id="递推公式-2"><a href="#递推公式-2" class="headerlink" title="递推公式"></a>递推公式</h4><p>$f(n, i, j) = \sum_{k}{f(n-1,i,k)}\ |\ k \ne j$</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lADPDhJzu0Qm8ZvNA3_NBQA_1280_895.jpg_720x720g.jpg" alt="lADPDhJzu0Qm8ZvNA3_NBQA_1280_895.jpg_720x720g" style="zoom:80%;" />

<hr>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>基于第一种做法，优化状态定义，忽略第一块的颜色</p>
<p>$f(n, 2, 3) == f(n, 1 , 3)$,即可以忽略i这个变量，变成隐藏的变量</p>
<h4 id="状态定义-3"><a href="#状态定义-3" class="headerlink" title="状态定义"></a>状态定义</h4><p>$f(n, j)$ 代表 n 块墙壁，第一块涂颜色 0，最后一块涂颜色 j 的方案总数，总方案数：$f(n,j)*3$</p>
<h4 id="递推公式-3"><a href="#递推公式-3" class="headerlink" title="递推公式"></a>递推公式</h4><p>$f(n, j) = \sum_{k}{f(n-1,k)}\ |\ k \ne j$</p>
<p>==&gt;$(f(n,1) + f(n,2))*3 = f(n,1) * 6$</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lADPDgfLP1XmGrbNA3_NBQA_1280_895.jpg_720x720g.jpg" alt="lADPDgfLP1XmGrbNA3_NBQA_1280_895.jpg_720x720g" style="zoom:80%;" />









<hr>
<h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><p>单刀直入，直接定义状态，求什么定义什么</p>
<h4 id="状态定义-4"><a href="#状态定义-4" class="headerlink" title="状态定义"></a>状态定义</h4><p>$f(n)$ 代表 n 块墙壁，首尾颜色不同的方法总数</p>
<h4 id="递推公式-4"><a href="#递推公式-4" class="headerlink" title="递推公式"></a>递推公式</h4><p>$f(n) = f(n-1) + 2 \times f(n-2)$</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lADPDg7mPJ-KA9LNA3_NBQA_1280_895.jpg_720x720g.jpg" alt="lADPDg7mPJ-KA9LNA3_NBQA_1280_895.jpg_720x720g" style="zoom:80%;" />



<p>1，3不同的方案总数，1，3不同，4颜色一定，3属于正常状态，所以1，3不同的方案总数为$1 \times f(n-1) = f(n-1)$</p>
<p>1和3颜色不同的方法，1，3颜色不同  ==&gt;1,2相同颜色，即1，3颜色不同的方案总数等于1，2相同颜色的方案总数；1，2不同的方案总数为$f(n-2)$,由于4有两种方案，计算总方案数时需要乘以2</p>
<p>总方案数$f(n)=1\times f(n-1)+2\times f(n-2)$</p>
<h2 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4.代码演示"></a>4.代码演示</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8A%E5%8D%8810.34.06.png" alt="截屏2021-01-04 上午10.34.06"></p>
<p>$f(n)=f(n-1)\times (k-2) + (k-1) \times f(n-2)$</p>
<p>(1,3不同+1,3相同)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义一个大整型数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigInt</span> :</span> <span class="keyword">public</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    BigInt() &#123;</span><br><span class="line">        push_back(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        push_back(x);</span><br><span class="line">        process_digit();</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>*(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="function">BigInt <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        ret *= x;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(); i++) at(i) *= x;</span><br><span class="line">        process_digit();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> BigInt &amp;num) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size()) push_back(num[i]);</span><br><span class="line">            <span class="keyword">else</span> at(i) += num[i];</span><br><span class="line">         &#125;</span><br><span class="line">        process_digit();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInt &amp;num) &#123;</span><br><span class="line">        <span class="function">BigInt <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        ret += num;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process_digit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (at(i) &lt; <span class="number">10</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == size()) push_back(<span class="number">0</span>);</span><br><span class="line">            at(i + <span class="number">1</span>) += at(i) / <span class="number">10</span>;</span><br><span class="line">            at(i) %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> BigInt &amp;num) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        out &lt;&lt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;<span class="comment">//n块墙壁k种颜色</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    BigInt f[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    f[<span class="number">1</span>] = k;<span class="comment">//有一块墙壁，，k种颜色，k&gt;=1</span></span><br><span class="line">    f[<span class="number">2</span>] = k * (k - <span class="number">1</span>);<span class="comment">//有两块墙壁，k种颜色,k&gt;=2</span></span><br><span class="line">    f[<span class="number">0</span>] = k * (k - <span class="number">1</span>) * (k - <span class="number">2</span>);<span class="comment">//有三块墙壁,k&gt;=3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i % <span class="number">3</span>] = f[(i - <span class="number">1</span>) % <span class="number">3</span>] * (k - <span class="number">2</span>) + f[(i - <span class="number">2</span>) % <span class="number">3</span>] * (k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n % <span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="3-从递推到动归-下"><a href="#3-从递推到动归-下" class="headerlink" title="3.从递推到动归(下)"></a>3.从递推到动归(下)</h1><blockquote>
<p>2021.1.4</p>
</blockquote>
<h2 id="1-数字三角形"><a href="#1-数字三角形" class="headerlink" title="1.数字三角形"></a>1.数字三角形</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%8812.32.26.png" alt="截屏2021-01-04 下午12.32.26" style="zoom:80%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%8812.32.26.png" alt="截屏2021-01-04 下午12.32.26" style="zoom:80%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%8812.32.59.png" alt="截屏2021-01-04 下午12.32.59" style="zoom:80%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%8812.45.491.png" alt="截屏2021-01-04 下午12.45.491" style="zoom:80%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/0012.png" alt="0012" style="zoom:80%;" />





<h3 id="惊人的发现"><a href="#惊人的发现" class="headerlink" title="惊人的发现"></a>惊人的发现</h3><p>$f(i, j)$ 代表从底边走到 i, j 点的最大值</p>
<p>$f(i, j)$ 代表从顶点走到 i, j 点的最大值</p>
<ol>
<li>数学符号完全一致</li>
<li>语义信息不同</li>
<li>递归公式不同</li>
<li>结论：数学符号无法完全代表状态定义</li>
</ol>
<h3 id="两种方法的对比"><a href="#两种方法的对比" class="headerlink" title="两种方法的对比"></a>两种方法的对比</h3><p>本质：两种状态定义方式的对比</p>
<ol>
<li>第一种：不用做边界判断，最终结果，直接存储在 $f[0][0]$</li>
<li>第二种：需要做边界判断，最终结果，存储在一组数据中</li>
<li>结论：第一种要比第二种优秀</li>
</ol>
<h2 id="2-数学归纳法"><a href="#2-数学归纳法" class="headerlink" title="2.数学归纳法"></a>2.数学归纳法</h2><p>用数学归纳法验证动态规划是否是正确的</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%883.41.45.png" alt="截屏2021-01-04 下午3.41.45" style="zoom:90%;" />





<h2 id="3-动态规划问题的求解套路"><a href="#3-动态规划问题的求解套路" class="headerlink" title="3.动态规划问题的求解套路"></a>3.动态规划问题的求解套路</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%883.49.09.png" alt="截屏2021-01-04 下午3.49.09" style="zoom:80%;" />

<ol>
<li>第一步：确定动归状态</li>
<li>第二步：推导状态转移方程，理解：转移、决策</li>
<li>第三步：正确性证明，利用数学归纳法</li>
<li>第四步：程序实现</li>
<li>所谓的转移，把所有决定 $f(i, j)$ 最优值的状态，放入到决策过程中。</li>
</ol>
<h2 id="4-递推问题求解方向"><a href="#4-递推问题求解方向" class="headerlink" title="4.递推问题求解方向"></a>4.递推问题求解方向</h2><p>1.我从哪里来：一般用for循环求解</p>
<p>例如：数字三角形、兔子繁殖问题、钱币问题、墙壁涂色…</p>
<p>2.我到哪里去：递归</p>
<p>例如：杂务(P1113)、神经网络(P1038)、旅行计划(P1137)…(P洛谷)</p>
<h3 id="补充-拓扑序"><a href="#补充-拓扑序" class="headerlink" title="补充:拓扑序"></a>补充:拓扑序</h3><p>图形结构是最最抽象的数据结构，必须理解成思维逻辑结构</p>
<ol>
<li>拓扑序是一种图形结构上的依赖顺序，一个图的拓扑序不唯一</li>
<li>拓扑序的本质作用：是把图形结构上变成一个一维序列</li>
<li>图形结构不能用循环遍历的，一维序列可以</li>
<li>所有递推问题中的状态更新过程，本质上满足拓扑序</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%884.28.08.png" alt="截屏2021-01-04 下午4.28.08" style="zoom:80%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%884.28.17.png" alt="截屏2021-01-04 下午4.28.17" style="zoom:80%;" />

<h2 id="5-例题1：最长上升子序列"><a href="#5-例题1：最长上升子序列" class="headerlink" title="5.例题1：最长上升子序列"></a>5.例题1：最长上升子序列</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%884.34.45.png" alt="截屏2021-01-04 下午4.34.45"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%884.41.03.png" alt="截屏2021-01-04 下午4.41.03"></p>
<h3 id="状态定义-5"><a href="#状态定义-5" class="headerlink" title="状态定义"></a>状态定义</h3><p>$f(i)$ 代表以为 i 为结尾的，最长上升子序列的长度</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>$f(i) = max\left{f(j)\right} + 1 | j &lt; i, val[j] &lt; val[i] $</p>
<p>状态转移的时间复杂度：$O(n^2)$</p>
<p>后续重点：优化转移过程</p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[MAX_N + <span class="number">5</span>];<span class="comment">//子序列</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>];<span class="comment">//记录上升子序列最长长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">//记录最长长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;<span class="comment">//在子序列中寻扎比他小的值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt;= arr[i]) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, dp[i]);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a href="#5.3.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E4%BC%98%E5%8C%96">5.3.最长上升子序列优化</a></p>
<h2 id="6-例题2-最长公共子序列"><a href="#6-例题2-最长公共子序列" class="headerlink" title="6.例题2:最长公共子序列"></a>6.例题2:最长公共子序列</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.24.57.png" alt="截屏2021-01-05 上午9.24.57" style="zoom:80%;" />

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.27.11.png" alt="截屏2021-01-05 上午9.27.11" style="zoom:80%;" />

<h3 id="状态定义-6"><a href="#状态定义-6" class="headerlink" title="状态定义"></a>状态定义</h3><p>$f(i,j)$ 代表第一个字符串取前 i 位，第二个字符串取前 j 位的，最长公共子序列的长度</p>
<h3 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>$f(i,j) = \left{\begin{aligned} &amp; max[f(i - 1, j), f(i, j - 1)] &amp;val(i) \neq val(j)\ &amp; f(i - 1, j - 1) &amp;val(i) = val(j)\end{aligned} \right.$</p>
<p>状态转移的时间复杂度：$O(n \times m)$</p>
<p>学习的重点：注意到，参与决策的状态数量，是会根据条件不同而改变的</p>
<h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="built_in">string</span> s1, s2;</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>][MAX_N + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s2.size(); j++) &#123;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[s1.size()][s2.size()] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="7-课后作业题"><a href="#7-课后作业题" class="headerlink" title="7.课后作业题"></a>7.课后作业题</h2><ol>
<li><strong><a href="http://oj.haizeix.com/problem/46">HZOJ46-切割回文</a></strong></li>
<li><strong><a href="http://oj.haizeix.com/problem/47">HZOJ47-0/1背包</a></strong></li>
<li><strong><a href="http://oj.haizeix.com/problem/48">HZOJ48-完全背包</a></strong></li>
<li><strong><a href="http://oj.haizeix.com/problem/49">HZOJ49-多重背包</a></strong></li>
</ol>
<h1 id="4-动归习题"><a href="#4-动归习题" class="headerlink" title="4.动归习题"></a>4.动归习题</h1><h2 id="1-切割回文"><a href="#1-切割回文" class="headerlink" title="1.切割回文"></a>1.切割回文</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-09%20%E4%B8%8B%E5%8D%882.43.31.png" alt="截屏2021-01-09 下午2.43.31"></p>
<p><strong>状态定义</strong></p>
<p>$dp[i]$ 代表取字符串的前 $i$ 位，最少分成多少段回文串</p>
<p><strong>状态转移</strong></p>
<p>$dp[i] = min(dp[j]) + 1\ |\ s[j + 1, i]\ is\ palindrome$</p>
<ol>
<li>根据状态转移，算法时间复杂度$O(n^2)$</li>
<li>所以，我们需要对转移阶段进行优化</li>
<li>动态规划优化章节的时候，重点解决</li>
</ol>
<h2 id="2-切割回文代码实现"><a href="#2-切割回文代码实现" class="headerlink" title="2.切割回文代码实现"></a>2.切割回文代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>];<span class="comment">//dp[i] 代表取字符串的前i位，最少分成多少段回文串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_palindrome</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//判断i~j是否是回文字符串</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] - s[j]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//s[i] != s[j]</span></span><br><span class="line">        i++,j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_palindrome(s, j, i - <span class="number">1</span>))<span class="comment">//是回文串</span></span><br><span class="line">                dp[i] = min(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[s.size()] - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="#5.4%E5%88%87%E5%89%B2%E5%9B%9E%E6%96%87">5.4切割回文</a></p>
<h2 id="3-HZOJ47-0-1背包"><a href="#3-HZOJ47-0-1背包" class="headerlink" title="3.HZOJ47-0/1背包"></a>3.HZOJ47-0/1背包</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8A%E5%8D%8811.09.46.png" alt="截屏2021-01-13 上午11.09.46"></p>
<p><strong>状态定义</strong></p>
<p>$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，得到物品的最大价值</p>
<p><strong>状态转移</strong></p>
<p>$$dp[i][j] = max\left{\begin{aligned}&amp;dp[i-1][j]&amp;没选第 i 件\&amp;dp[i-1][j-v[i]]+w[i] &amp;选了第 i 件\end{aligned}\right.$$</p>
<p>𝑉𝑖,𝑊𝑖,分别代表第i件物品的重量𝑉𝑖和价值𝑊𝑖。</p>
<ol>
<li>第一种程序实现，状态如何定义的，程序就如何实现</li>
<li>第二种程序实现，使用滚动数组，对代码进行了空间优化</li>
<li>第三种程序实现，将程序中的 $dp$ 数组变成一维的，并且修改了更新顺序</li>
</ol>
<h2 id="4-0-1背包代码演示"><a href="#4-0-1背包代码演示" class="headerlink" title="4.0/1背包代码演示"></a>4.0/1背包代码演示</h2><h3 id="1-方法一"><a href="#1-方法一" class="headerlink" title="1.方法一"></a>1.方法一</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_V 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[MAX_N + <span class="number">5</span>], w[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>][MAX_V + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; n;<span class="comment">//背包的最大承重v和物品数n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">  		<span class="comment">//物品从第一件开始,输入第i件物品的重量v[i]和价值w[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) </span><br><span class="line">              dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">            <span class="comment">//前 i 个物品，背包最大承重为 j 的情况下，得到物品的最大价值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-利用滚动数组进行优化"><a href="#2-利用滚动数组进行优化" class="headerlink" title="2.利用滚动数组进行优化"></a>2.利用滚动数组进行优化</h3><p>减少存储空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_V 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[MAX_N + <span class="number">5</span>], w[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][MAX_V + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; n;<span class="comment">//背包的最大承重v和物品数n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];<span class="comment">//物品从第一件开始,输入第i件物品的重量v[i]和价值w[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">            dp[i % <span class="number">2</span>][j] = dp[(i - <span class="number">1</span>) % <span class="number">2</span>][j];</span><br><span class="line">            <span class="comment">//此处只访问了dp[i]和dp[i-1]两行，可以利用滚动数组进行优化</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) dp[i % <span class="number">2</span>][j] = max(dp[i % <span class="number">2</span>][j], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][j - v[i]] + w[i]);</span><br><span class="line">            <span class="comment">//dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);</span></span><br><span class="line">            <span class="comment">//前 i 个物品，背包最大承重为 j 的情况下，得到物品的最大价值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n % <span class="number">2</span>][V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-优化"><a href="#3-优化" class="headerlink" title="3.优化"></a>3.优化</h3><p>将程序中的 $dp$ 数组变成一维的，并且修改了更新顺序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_V 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_V + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V, n; <span class="comment">//背包的最大承重V和物品数n。</span></span><br><span class="line">    <span class="keyword">int</span> v, w; <span class="comment">//物品的重量v和价值w</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; n; </span><br><span class="line">    <span class="comment">//for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span></span><br><span class="line">    <span class="comment">//物品从第一件开始,输入第i件物品的重量v[i]和价值w[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v; j--) &#123;</span><br><span class="line">          <span class="comment">//dp[j] = dp[j];</span></span><br><span class="line">            <span class="comment">//if (j &gt;= v) dp[j] = max(dp[j], dp[j - v] + w);</span></span><br><span class="line">            <span class="comment">//前 i 个物品，背包最大承重为 j 的情况下，得到物品的最大价值</span></span><br><span class="line">          dp[j] = max(dp[j], dp[j - v] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解：</p>
<p>1.j为什么逆序</p>
<p>==&gt;需要理解为什么是一维的</p>
<p>dp数组经过$dp[j] = max(dp[j], dp[j - v] + w)$后变成了$dp[i][j]$的含义,之前是$dp[i - 1][j]$的含义</p>
<p>$dp[j]$更新需要$dp[j]$和$dp[j - v]$的值(相对于二维数组来说，此处需要$dp[i - 1][j]$和$dp[i - 1][j - v]$的值，即上一行的数据)，如果从前面开始更新数据，后面需要的数组会被新一层的数据覆盖,所以需要从后面开始更新</p>
<p>2.为什么不需要v、w数组</p>
<p>读入一件商品，处理一件商品</p>
<p>3.dp数组为什么第一维没了</p>
<p>dp数组的含义没有变,只是在代码实现中变成了一维的</p>
<h2 id="5-海贼-OJ-48-完全背包"><a href="#5-海贼-OJ-48-完全背包" class="headerlink" title="5.海贼 OJ-48-完全背包"></a>5.海贼 OJ-48-完全背包</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%882.38.25.png" alt="截屏2021-01-13 下午2.38.25"></p>
<p><strong>状态定义</strong></p>
<p>$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，最大价值</p>
<p><strong>状态转移</strong></p>
<p>$$dp[i][j] = max\left{\begin{aligned}&amp;dp[i-1][j]&amp;没选第 i 件\&amp;dp[i][j-v[i]]+w[i] &amp;选了若干个第 i 件\end{aligned}\right.$$</p>
<p>(0/1背包)$dp[i-1][j-v[i]]+w[i] 选了第 i 件$</p>
<p>程序实现的时候，参考01背包的程序实现，将逆向刷表，改成正向刷表</p>
<h2 id="6-完全背包代码演示"><a href="#6-完全背包代码演示" class="headerlink" title="6.完全背包代码演示"></a>6.完全背包代码演示</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V, n, w, v;</span><br><span class="line">    <span class="comment">//第一行为两个整数𝑁、𝑉(1≤𝑁,𝑉≤10000)，分别代表题目描述中的物品种类数量N和背包容量V。</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;<span class="comment">//c = v,v = w</span></span><br><span class="line">        <span class="comment">//第 𝑖 行两个整数𝐶𝑖、𝑉𝑖，分别代表每种物品的体积和价值。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &lt;= V; j++) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - v] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处我们需要正向刷表，因为我们需要$dp[j - v[i]]$能够代表$dp[i][j - v[i]]$的值</p>
<p>$dp[i][j-v[i]]+w[i] 选了若干个第 i 件$此处需要的第$i$行的$dp[j-v[i]]$而不是需要第$i - 1$行的$dp[j-v[i]]$</p>
<h2 id="7-海贼-OJ-49-多重背包"><a href="#7-海贼-OJ-49-多重背包" class="headerlink" title="7.海贼 OJ-49-多重背包"></a>7.海贼 OJ-49-多重背包</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%883.17.52.png" alt="截屏2021-01-13 下午3.17.52"></p>
<p><strong>问题模型转换</strong></p>
<ol>
<li>多重背包，每类物品多了一个数量限制</li>
<li>01背包，每种物品只有一个</li>
<li>将多重背包中的数量限制，当做多个单一物品来处理</li>
<li>至此就将多重背包，转成了0/1背包问题</li>
</ol>
<p><strong>状态定义</strong></p>
<p>$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，最大价值</p>
<p><strong>状态转移</strong></p>
<p>$$dp[i][j] = max\left{\begin{aligned}&amp;dp[i-1][j]&amp;没选第 i 件\&amp;dp[i-1][j-v[i]]+w[i] &amp;选了第 i 件\end{aligned}\right.$$</p>
<h2 id="8-多重背包代码演示"><a href="#8-多重背包代码演示" class="headerlink" title="8.多重背包代码演示"></a>8.多重背包代码演示</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> V, n, v, w, s;</span><br><span class="line">    <span class="comment">//第一行输入两个数𝑉、𝑛，分别代表背包的最大承重和物品种类数。</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//𝑉𝑖、𝑊𝑖、𝑆𝑖，分别代表第 𝑖 种物品的重量、价值和数量。</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s; k++) &#123;</span><br><span class="line">          <span class="comment">//对数量分类，对每一种情况进行讨论</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v; j--) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - v] + w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a href="#5.2.%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%9A%84%E4%BC%98%E5%8C%96">5.2.多重背包的优化</a></p>
<h2 id="9-海贼-OJ-50-扔鸡蛋"><a href="#9-海贼-OJ-50-扔鸡蛋" class="headerlink" title="9.海贼 OJ-50-扔鸡蛋"></a>9.海贼 OJ-50-扔鸡蛋</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%883.56.18.png" alt="截屏2021-01-13 下午3.56.18"></p>
<p><strong>状态定义</strong></p>
<p>$dp[n][m]$ 用 n 个鸡蛋，测 m 层楼，最坏情况下最少测$dp[n][m]$次</p>
<p><strong>状态转移</strong></p>
<p>$$dp[n][m] = min(max\left{\begin{aligned}&amp;dp[n-1][k-1]+1&amp;鸡蛋碎了\&amp;dp[n][m-k]+1 &amp;鸡蛋没碎\end{aligned})\right.$$</p>
<p>楼层数k，最少min,最坏max,对于每一个枚举的k值中选一个值最小的方案，对于每一个确定的k值，都有两种解决方式，在这两种解决方式中取一个最大值</p>
<ol>
<li>程序所使用的存储空间与楼层数量强相关</li>
<li>楼层数量达到了 $2^{31}$，所以在这种状态定一下不可行</li>
<li>状态定义不可行，我们就需要优化状态定义</li>
<li>时间复杂度 $O(n \times m^2)$，当 m 过大的时候，无法通过时间限制</li>
</ol>
<h2 id="10-扔鸡蛋代码演示"><a href="#10-扔鸡蛋代码演示" class="headerlink" title="10.扔鸡蛋代码演示"></a>10.扔鸡蛋代码演示</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100000</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>][MAX_M + <span class="number">5</span>];</span><br><span class="line"><span class="comment">//dp[n][m]用n个鸡蛋，测 m 层楼，最坏情况下最少测dp[n][m]次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//输入两个数字 𝑛,𝑚（1≤𝑛≤32,1≤𝑚&lt;231），代表 𝑛 个鸡蛋和 𝑚 层楼。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) dp[<span class="number">1</span>][i] = i;</span><br><span class="line">  	<span class="comment">//一个鸡蛋测i层楼,有i种方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;<span class="comment">//从两个鸡蛋开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;<span class="comment">//楼层</span></span><br><span class="line">            dp[i][j] = j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j; k++) &#123;<span class="comment">//</span></span><br><span class="line">                dp[i][j] = min(dp[i][j], max(dp[i - <span class="number">1</span>][k - <span class="number">1</span>], dp[i][j - k]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30分，</p>
<p>时间复杂度$O(n \times m^2)$</p>
<p><a href="##5.1.%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96">扔鸡蛋问题优化</a></p>
<h1 id="5-动态规划优化的分类"><a href="#5-动态规划优化的分类" class="headerlink" title="5. 动态规划优化的分类"></a>5. 动态规划优化的分类</h1><ol>
<li>状态转移过程的优化，不改变状态定义，使用一些特殊的数据结构或者算法专门优化转移过程</li>
<li>程序实现的优化，例如：01背包问题。状态定义没有变、转移过程也没变。</li>
<li>状态定义的优化，大量训练，才能培养出来的能力，从源头进行优化</li>
<li>状态定义-&gt;源头，转移过程-&gt;过程，程序实现-&gt;结果</li>
</ol>
<p>程序优化：01背包，钱币问题，滚动数组</p>
<h2 id="5-1-扔鸡蛋问题的优化"><a href="#5-1-扔鸡蛋问题的优化" class="headerlink" title="5.1.扔鸡蛋问题的优化"></a>5.1.扔鸡蛋问题的优化</h2><h3 id="转移过程优化"><a href="#转移过程优化" class="headerlink" title="转移过程优化"></a><strong>转移过程优化</strong></h3><p>$$dp[n][m] = min(max\left{\begin{aligned}&amp;dp[n-1][k-1]+1&amp;鸡蛋碎了\&amp;dp[n][m-k]+1 &amp;鸡蛋没碎\end{aligned})\right.$$</p>
<p>$dp[n][m]$ 用 n 个鸡蛋，测 m 层楼，最坏情况下最少测$dp[n][m]$次</p>
<p>通过观察 k 与 $dp[n-1][k-1]$与 $dp[n][m-k]$之间的关系，最优的转移 k 值，一定发生在两个函数的交点处</p>
<p>k增加，$dp[n-1][k-1]$增加，$dp[n][m-k]$减小(如果不理解，可以假如用1(n-1=1)个鸡蛋，测m(k - 1 = m)层楼有m种方法理解)</p>
<p>交叉点出的值满足：$dp[n-1][k-1] \le dp[n][m-k]$</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%888.39.00.png" alt="截屏2021-01-13 下午8.39.00"></p>
<p>m1&lt;m2  ==&gt; k1&lt;=k2</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%888.42.19.png" alt="截屏2021-01-13 下午8.42.19"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%888.48.59.png" alt="截屏2021-01-13 下午8.48.59"></p>
<p>优化掉 min 以后，总体时间复杂度变成了 $O(n \times m)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100000</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>][MAX_M + <span class="number">5</span>];</span><br><span class="line"><span class="comment">//dp[n][m]用n个鸡蛋，测 m 层楼，最坏情况下最少测dp[n][m]次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//输入两个数字 𝑛,𝑚（1≤𝑛≤32,1≤𝑚&lt;231），代表 𝑛 个鸡蛋和 𝑚 层楼。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) dp[<span class="number">1</span>][i] = i;<span class="comment">//一个鸡蛋测i层楼,有i种方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;<span class="comment">//从两个鸡蛋开始</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m; j++) &#123;<span class="comment">//楼层</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//1.</span></span><br><span class="line">            <span class="comment">//while(k &lt; j &amp;&amp; dp[i - 1][k - 1] &lt; dp[i][j - k]) ++k;</span></span><br><span class="line">            <span class="comment">//dp[i][j] = max(dp[i - 1][k -1], dp[i][j - k]) + 1;</span></span><br><span class="line">            <span class="comment">//2.</span></span><br><span class="line">            <span class="keyword">if</span>(k &lt; j &amp;&amp; dp[i - <span class="number">1</span>][k - <span class="number">1</span>] &lt; dp[i][j - k]) ++k;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][k <span class="number">-1</span>], dp[i][j - k]) + <span class="number">1</span>;</span><br><span class="line">           <span class="comment">// while(dp[i - 1][k - 1 + 1] &lt;= dp[i][j - k + 1]) ++k;</span></span><br><span class="line">             <span class="comment">//   dp[i][j] = dp[i][j - k] + 1;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>60</p>
<h3 id="状态定义的优化"><a href="#状态定义的优化" class="headerlink" title="状态定义的优化"></a><strong>状态定义的优化</strong></h3><ol>
<li>原状态定义所需存储空间与 m 相关，m 值域大，所以存不下</li>
<li>当发现某个自变量与因变量之间存在相关性的时候，两者即可对调</li>
<li>$dp[n][m]=k$ 重定义为$dp[n][k]=m$，代表 n 个鸡蛋扔 k 次，最多测多少层楼</li>
<li>k 的值域小，当 n=2 时，$k \le \sqrt{2m}$ </li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8A%E5%8D%885.57.48.png" alt="截屏2021-01-14 上午5.57.48"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8A%E5%8D%885.58.43.png" alt="截屏2021-01-14 上午5.58.43"></p>
<p><strong>状态转移方程：</strong>$dp[n][k] = dp[n-1][k-1]+dp[n][k-1] + 1$</p>
<p>本质上已经不是一个动态规划题目了，实际上变成了一个递推问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_K 100000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAX_N + <span class="number">5</span>][MAX_K + <span class="number">5</span>];</span><br><span class="line"><span class="comment">//dp[n][k]代表 n 个鸡蛋扔 k 次，最多测多少层楼</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_K; i++) dp[<span class="number">1</span>][i] = i;<span class="comment">//1个鸡蛋测i层楼有i种方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= MAX_K; k++) &#123;</span><br><span class="line">            dp[i][k] = dp[i - <span class="number">1</span>][k - <span class="number">1</span>] + dp[i][k - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(dp[n][k] &lt; m) k++;<span class="comment">//n个鸡蛋扔k次不足以测m层楼的时候增加k</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//输入两个数字 𝑛,𝑚（1≤𝑛≤32,1≤𝑚&lt;231），代表 𝑛 个鸡蛋和 𝑚 层楼。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve(n, m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>100</p>
<p>动态数组优化存储空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_K 100000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">2</span>][MAX_K + <span class="number">5</span>];</span><br><span class="line"><span class="comment">//dp[n][m]用n个鸡蛋，测 m 层楼，最坏情况下最少测dp[n][m]次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_K; i++) dp[<span class="number">1</span>][i] = i;<span class="comment">//1个鸡蛋测i层楼有i种方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= MAX_K; k++) &#123;</span><br><span class="line">            dp[i % <span class="number">2</span>][k] = dp[(i - <span class="number">1</span>) % <span class="number">2</span>][k - <span class="number">1</span>] + dp[i % <span class="number">2</span>][k - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(dp[n % <span class="number">2</span>][k] &lt; m) k++;<span class="comment">//n个鸡蛋扔k次不足以测m层楼的时候增加k</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//输入两个数字 𝑛,𝑚（1≤𝑛≤32,1≤𝑚&lt;231），代表 𝑛 个鸡蛋和 𝑚 层楼。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve(n, m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="5-2-多重背包的优化"><a href="#5-2-多重背包的优化" class="headerlink" title="5.2.多重背包的优化"></a>5.2.多重背包的优化</h2><p>[7.海贼 OJ-49-多重背包](#7.海贼 OJ-49-多重背包)</p>
<h3 id="二进制拆分法"><a href="#二进制拆分法" class="headerlink" title="二进制拆分法"></a>二进制拆分法</h3><ol>
<li>本质上，对于某一类物品，我们具体要选择多少件，才是最优答案</li>
<li>普通的单一拆分法，实际上只是想枚举某个物品选择 1–s 件的所有情况</li>
<li>二进制拆分法可以达到相同的效果，拆分出来的物品数量会更少</li>
<li>拿14举例，普通拆分法 14 份，二进制拆分法 4 份物品(1 2 4 7)</li>
</ol>
<p><strong>时间复杂度：</strong>$O(nm\sum_{i=1}^{i=n}{logs_i})$</p>
<p><strong>最优时间复杂度：</strong>$O(nm)$，借助单调队列，后续再讲</p>
<p><strong>01背包时间复杂度：</strong>$O(nm)$</p>
<p><strong>完全背包时间复杂度：</strong>$O(nm)$</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8A%E5%8D%887.25.53.png" alt="截屏2021-01-14 上午7.25.53"></p>
<h3 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> V, n, v, w, s;</span><br><span class="line">    <span class="comment">//第一行输入两个数𝑉、𝑛，分别代表背包的最大承重和物品种类数。</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//v、w、s代表物品的重量、价值和数量。</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; s; k *= <span class="number">2</span>) &#123;<span class="comment">//当前一共有多少物品</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; s) k = s;</span><br><span class="line">            s -= k;<span class="comment">//减去物品加上的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= k * v; j--) &#123;<span class="comment">//当前这一堆的总重量为k * v</span></span><br><span class="line">                dp[j] = max(dp[j], dp[j - k * v] + k * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-3-最长上升子序列优化"><a href="#5-3-最长上升子序列优化" class="headerlink" title="5.3.最长上升子序列优化"></a>5.3.最长上升子序列优化</h2><p><a href="#5.%E4%BE%8B%E9%A2%981%EF%BC%9A%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97">5.例题1：最长上升子序列</a></p>
<h3 id="状态定义-7"><a href="#状态定义-7" class="headerlink" title="状态定义"></a>状态定义</h3><p>$dp[i]$，代表以 i 位做为结尾的最长上升子序列的长度</p>
<h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>$dp[i] = max(dp[j]) + 1 | val_j &lt; val_i$</p>
<h3 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h3><ol>
<li>维护一个单调数组 len，len[i] 代表长度为 i 的序列，结尾最小值</li>
<li>$dp[i]$ 在转移的时候，在 len 数组中查找第一个 $len[k]&gt;=val_i$ 的位置，$dp[i] = k$</li>
<li>更新 $len[k] = val_i$</li>
<li>需要明确，len 数组为什么是单调的</li>
<li>证明过程：假设，更新前是单调的，更新以后，一定是单调的</li>
<li>在 len 数组中查找位置 k，实际上就是二分算法搞定</li>
</ol>
<p><strong>时间复杂度：</strong>$O(nlogl)$</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8B%E5%8D%883.06.40.png" alt="截屏2021-01-14 下午3.06.40"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8B%E5%8D%883.06.40.png" alt="截屏2021-01-14 下午3.06.51"></p>
<h3 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[MAX_N + <span class="number">5</span>];<span class="comment">//长度为i的序列的最小值</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//二分查找</span></span><br><span class="line">    <span class="comment">//在arr数组中查找第一个大于等于x的值</span></span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = n, mid;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; x) head = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tail = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, val;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(len, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(len));<span class="comment">//极大值</span></span><br><span class="line">    len[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//极小值，0的位置为极小值，其他位置为极大值</span></span><br><span class="line">   <span class="comment">// for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, val[i]);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">        dp[i] = binary_search(len, ans + <span class="number">1</span>,val);<span class="comment">//找到第一个&gt;=val[i]的值</span></span><br><span class="line">        len[dp[i]] = val;</span><br><span class="line">        ans = max(dp[i], ans);<span class="comment">//最后一位有记录的下标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-4切割回文"><a href="#5-4切割回文" class="headerlink" title="5.4切割回文"></a>5.4切割回文</h2><p><a href="#1.%E5%88%87%E5%89%B2%E5%9B%9E%E6%96%87">4.1.切割回文</a></p>
<p>提前处理得到 mark 数组，$mark[i]$ 存储的是所有以 i 位置做为结尾的回文串的起始坐标，在转移过程中，利用 mark 数组，就可以避免掉大量的无用循环遍历过程。</p>
<p><strong>时间复杂度：</strong>$O(n+m)$，m 是字符串中回文串的数量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>];<span class="comment">//取字符串的前i位，最少分成多少段回文串</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mark[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="comment">//以 i 位置做为结尾的回文串的起始坐标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//回文字符串</span></span><br><span class="line">    <span class="keyword">while</span> (s[i] == s[j]) &#123;</span><br><span class="line">        mark[j + <span class="number">1</span>].push_back(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//以j+1为结尾的回文串的起始坐标i+1 </span></span><br><span class="line">        --i, ++j;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &gt;= s.size()) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;<span class="comment">//一个长度为n(1≤𝑛≤500000)的字符串S，只包含小写字母。</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;<span class="comment">//提前处理得到 mark 数组</span></span><br><span class="line">        expand(s, i, i);<span class="comment">//处理奇数类型字符串</span></span><br><span class="line">        (i + <span class="number">1</span> &lt; s.size()) &amp;&amp; expand(s, i, i + <span class="number">1</span>);</span><br><span class="line">      	<span class="comment">//处理偶数类型的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); i++) &#123;</span><br><span class="line">        dp[i] = i;<span class="comment">//初始化dp[i],取字符串的前i位，最少分成多少段回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mark[i].size(); j++) &#123;</span><br><span class="line">            dp[i] = min(dp[i], dp[mark[i][j] - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[s.size()] - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//分多少段-1==&gt;切多少刀</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="6-树状数组"><a href="#6-树状数组" class="headerlink" title="6.树状数组"></a>6.树状数组</h1><p>2021.1.17 20:00</p>
<h2 id="6-1前缀和与差分"><a href="#6-1前缀和与差分" class="headerlink" title="6.1前缀和与差分"></a>6.1前缀和与差分</h2><h3 id="原数组、前缀和、差分数组"><a href="#原数组、前缀和、差分数组" class="headerlink" title="原数组、前缀和、差分数组"></a>原数组、前缀和、差分数组</h3><ol>
<li><p>原数组：${a_1, a_2,a_3,….,a_n}$</p>
</li>
<li><p>前缀和：$S_i=\sum_{k=1}^{k=i}{a_i}$，$a_i=S_i-S_{i-1}$</p>
</li>
<li><p>差分数组：$X_i=a_i-a_{i-1}$</p>
<p>$X_1 + X_2 + X_3 = (a_1 - a_0) + (a_2 - a_1) + (a_3 - a_2) = a_3 $</p>
</li>
<li><p>X 数组是 a 数组的差分数组，a 数组是 S 数组的差分数组</p>
</li>
<li><p>S 数组是 a 数组的前缀和数组，a 数组是 X 数组的前缀和数组</p>
</li>
<li><p>前缀和数组以及差分数组，并没有增加信息，只是信息的另外一种表示形式</p>
</li>
<li><p>前缀和数组用来优化==区间和==操作</p>
</li>
<li><p>差分数组用来优化==区间修改==操作</p>
</li>
</ol>
<h3 id="问题1：原数组区间和操作"><a href="#问题1：原数组区间和操作" class="headerlink" title="问题1：原数组区间和操作"></a>问题1：原数组区间和操作</h3><p>a 数组上的操作：$O(n)$</p>
<p>S 数组上的操作：$O(1)，S_i - S_{j-1}=a[j,i]区间和$</p>
<h3 id="问题2：原数组区间元素修改（加法）"><a href="#问题2：原数组区间元素修改（加法）" class="headerlink" title="问题2：原数组区间元素修改（加法）"></a>问题2：原数组区间元素修改（加法）</h3><p>$a={a_1,a_2,a_3,a_4,a_5,a_6}$</p>
<p>$X={X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5}$</p>
<p>${a_1,a_2+d,a_3+d,a_4+d,a_5,a_6}$</p>
<p>$X={X_1=a_1-a_0,X_2=a_2-a_1+d,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4-d,X_6=a_6-a_5}$</p>
<p>a 数组时间复杂度：$O(n)$</p>
<p>X 数组时间复杂度：$O(1)$</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%888.51.02.png" alt="截屏2021-01-17 下午8.51.02"></p>
<h2 id="6-2树状数组"><a href="#6-2树状数组" class="headerlink" title="6.2树状数组"></a>6.2树状数组</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%888.54.51.png" alt="截屏2021-01-17 下午8.54.51"></p>
<ol>
<li><p>lowbit 函数求数字 i，二进制表示中的最低1所在的位权</p>
</li>
<li><p>lowbit(x) = x &amp; -x</p>
<p>正数=原码，负数=补码=正数的反码+1，</p>
</li>
<li><p>树状数组本质上是对前缀和数组的一种优化，主要体现在单点修改操作上</p>
</li>
<li><p>前缀和查询 $O(logn)$，单点修改$O(logn)$</p>
</li>
<li><p>相比于最普通的前缀和数组，查询方面变差，单点修改操作变好，综合时间复杂度变好</p>
</li>
<li><p>查询的时候，向前统计，$i$ 的前一位 $i-lowbit(i)$</p>
</li>
<li><p>修改的时候，向后修改，$i$ 的后一位 $i + lowbit(i)$</p>
</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.04.29.png" alt="截屏2021-01-17 下午9.04.29"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.10.13.png" alt="截屏2021-01-17 下午9.10.13"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.10.55.png" alt="截屏2021-01-17 下午9.10.55"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.16.13.png" alt="截屏2021-01-17 下午9.16.13"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.17.02.png" alt="截屏2021-01-17 下午9.17.02"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.37.27.png" alt="截屏2021-01-17 下午9.37.27"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>方便区间修改版</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">int</span> c[MAX_N + <span class="number">5</span>];<span class="comment">//维护的是原数组的差分数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//单点修改</span></span><br><span class="line">    <span class="comment">//在c[n]中的c[i]加x</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        c[i] += x;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//前缀和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;<span class="comment">//原数组前n项和为第i项的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-3海贼-OJ-329-弱化的整数问题"><a href="#6-3海贼-OJ-329-弱化的整数问题" class="headerlink" title="6.3海贼 OJ-329-弱化的整数问题"></a>6.3海贼 OJ-329-弱化的整数问题</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.43.34.png" alt="截屏2021-01-17 下午9.43.34"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.43.50.png" alt="截屏2021-01-17 下午9.43.50"></p>
<p><strong>引入差分数组</strong></p>
<p>$a={a_1,a_2,a_3,a_4,a_5,a_6}$</p>
<p>$X={X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5}$</p>
<p>${a_1,a_2+d,a_3+d,a_4+d,a_5,a_6}$</p>
<p>$X={X_1=a_1-a_0,X_2=a_2-a_1+d,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4-d,X_6=a_6-a_5}$</p>
<p>引入差分数组 X，将原数组 a 上的区间加操作，转换成 X 数组上的两次【单点操作】</p>
<p>对于查询原数组 a[i] 的值，等价于查询 X 数组前 i 位的【前缀和】</p>
<p><strong>结论</strong></p>
<p>由于，既要维护【前缀和】，又要进行【单点修改】，所以可以使用树状数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">int</span> c[MAX_N + <span class="number">5</span>];<span class="comment">//维护的是原数组的差分数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//单点修改</span></span><br><span class="line">    <span class="comment">//在c[n]中的c[i]加x</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        c[i] += x;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//前缀和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;<span class="comment">//原数组前n项和为第i项的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, pre, a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;<span class="comment">//第一行一个整数𝑁,代表序列𝐴的长度</span></span><br><span class="line">    <span class="comment">//第二行是由空格分隔开的𝑁个数，分别代表𝐴1，𝐴2……𝐴𝑛</span></span><br><span class="line">    pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;<span class="comment">//a代表当前输入的值</span></span><br><span class="line">        add(i, a - pre, n);<span class="comment">//pre代表上一个输出的值</span></span><br><span class="line">        pre = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;<span class="comment">//接下来一行是一个整数𝑚，代表操作的次数。</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//接下来𝑚行，每行代表这一条指令如题目所述</span></span><br><span class="line">    <span class="keyword">int</span> l, r, d, x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="keyword">switch</span> (str[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: &#123;</span><br><span class="line">                      <span class="comment">// 第一类指令形如𝐶 𝑙 𝑟 𝑑(1≤𝑙≤𝑟≤𝑁)，表示把数列中第𝑙...𝑟之间的数都加𝑑(0≤𝑑≤100000)</span></span><br><span class="line">                      <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; d;</span><br><span class="line">                      add(l, d, n);</span><br><span class="line">                      add(r + <span class="number">1</span>, -d, n);</span><br><span class="line">                  &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: &#123;</span><br><span class="line">                      <span class="built_in">cin</span> &gt;&gt; x;<span class="comment">//第二类指令形如𝑄 𝑥(𝑥≤𝑁)，表示询问序列中第𝑥个数的值。</span></span><br><span class="line">                      <span class="built_in">cout</span> &lt;&lt; query(x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-4-海贼-OJ-330-加强的整数问题"><a href="#6-4-海贼-OJ-330-加强的整数问题" class="headerlink" title="6.4 海贼 OJ-330-加强的整数问题"></a>6.4 海贼 OJ-330-加强的整数问题</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%8810.29.57.png" alt="截屏2021-01-17 下午10.29.57"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%8810.30.10.png" alt="截屏2021-01-17 下午10.30.10"></p>
<p><strong>引入差分数组</strong></p>
<p>参考 HZOJ-329 的解法，主要为了维护原数组上的区间修改操作</p>
<p><strong>原数组上的区间和问题转化</strong></p>
<p>$a={a_1,a_2,a_3,a_4,a_5,a_6}$</p>
<p>$X={X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5}$</p>
<p>$Query(l, r) = S(r) - S(l - 1)$，重点分析 S 怎么求，会求 S，万事大吉</p>
<p>$S_i= \sum_{k=1}^{i}\sum_{y=1}^{k}{X_y} = \sum_{k=1}{i}{(i + 1)X_k-k<em>X_k}=(i + 1)\sum_{k=1}^{i}{X_k-\sum_{k=1}^{i}k</em>X_k}$</p>
<p>设$Y_i = i \times X_i$</p>
<p>$S_i=(i + 1)\sum_{k=1}^{i}{X_k-\sum_{k=1}^{i}{Y_k}}$</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%8810.27.25.png" alt="截屏2021-01-17 下午10.27.25"></p>
<p><strong>结论</strong></p>
<p>$S_i$ 可以通过维护 X 与 Y 两个序列的前缀和得到</p>
<p>所以可以通过维护两个与差分数组 X 相关的前缀和数组，从而得到原数组 a 的前缀和值</p>
<p>需要维护两个：树状数组</p>
<p><strong>代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c[<span class="number">2</span>][MAX_N + <span class="number">5</span>];<span class="comment">//差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k, <span class="keyword">long</span> <span class="keyword">long</span> i, <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在c[k][i]的位置加x</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        c[k][i] += x;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k, <span class="keyword">long</span> <span class="keyword">long</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询c[k][i]的前缀和</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        sum += c[k][i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> i)</span> </span>&#123;<span class="comment">//S[i]前i项和</span></span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>) * query(<span class="number">0</span>, i) - query(<span class="number">1</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> i, <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;<span class="comment">//在c[][i]位置上加上x</span></span><br><span class="line">    add(<span class="number">0</span>, i, x, n);</span><br><span class="line">    add(<span class="number">1</span>, i, i * x, n);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> m, n;</span><br><span class="line">    <span class="comment">//第一行包含两个整数𝑁,𝑀(1≤𝑁,𝑀≤100000)，代表序列的长度和询问的次数.</span></span><br><span class="line">    <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">//第二行包含𝑁个整数，表示初始的序列𝐴(−1000000000≤𝐴𝑖≤1000000000)。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>, pre = <span class="number">0</span>, a; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; a;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a);</span><br><span class="line">        modify(i, a - pre, n);</span><br><span class="line">        pre = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>, l, r, d; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; s;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">switch</span> (s[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: &#123;<span class="comment">//&quot;C a b c&quot;表示给[a, b]区间中的值全部增加c (-10000 ≤ c ≤ 10000)。</span></span><br><span class="line">                      <span class="comment">//cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;</span></span><br><span class="line">                      <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;l, &amp;r, &amp;d);</span><br><span class="line">                      modify(l, d, n);</span><br><span class="line">                      modify(r + <span class="number">1</span>, -d, n);</span><br><span class="line">                  &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: &#123;<span class="comment">//&quot;Q a b&quot; 询问[a, b]区间中所有值的和。</span></span><br><span class="line">                      <span class="comment">//cin &gt;&gt; l &gt;&gt; r;</span></span><br><span class="line">                      <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, S(r) - S(l - <span class="number">1</span>));</span><br><span class="line">                      <span class="comment">//cout &lt;&lt; (S(r) - S(l - 1)) &lt;&lt; endl;</span></span><br><span class="line">                  &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="7-树状数组习题"><a href="#7-树状数组习题" class="headerlink" title="7.树状数组习题"></a>7.树状数组习题</h1><h2 id="一、海贼-OJ-331-丢失的奶牛1"><a href="#一、海贼-OJ-331-丢失的奶牛1" class="headerlink" title="一、海贼 OJ-331-丢失的奶牛1"></a>一、海贼 OJ-331-丢失的奶牛1</h2><ol>
<li>理解标记数组，标记数组记录的是每一个下标知否可用，可用为1，不可用为0</li>
<li>根据题意，我们从后向前，依次确定每一头奶牛的编号</li>
<li>例如，当前奶牛比他前面的2个奶牛编号大的话，当前奶牛的编号就是当前剩余可用编号中的第三大的编号</li>
<li>如何找到可用的第 x 大的编号，可以在标记数组的前缀和数组上做二分查找</li>
<li>设计到标记数组的前缀和维护和单点更新，所以可以使用树状数组</li>
<li>时间复杂度：$O(nlogn)$</li>
</ol>
<p>相似问题：海贼 OJ-332-买票</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX_N 80000</span><br><span class="line">int c[MAX_N + 5];</span><br><span class="line">#define lowbit(x) (x &amp; -x)</span><br><span class="line">void add(int i, int x, int n) &#123;</span><br><span class="line">    while (i &lt;&#x3D; n) &#123;</span><br><span class="line">        c[i] +&#x3D; x;</span><br><span class="line">        i +&#x3D; lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int i) &#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    while (i) &#123;</span><br><span class="line">        sum +&#x3D; c[i];</span><br><span class="line">        i -&#x3D; lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int cnt[MAX_N + 5];</span><br><span class="line">int ind[MAX_N + 5];</span><br><span class="line"></span><br><span class="line">void read() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ind[1] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 2; i &lt;&#x3D; n; i++) cin &gt;&gt; cnt[i];</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        add(i, 1, n);</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int binary_search(int n, int x) &#123;</span><br><span class="line">    int head &#x3D; 1, tail &#x3D; n, mid;</span><br><span class="line">    while (head &lt; tail) &#123;</span><br><span class="line">        mid &#x3D; (head + tail) &gt;&gt; 1;</span><br><span class="line">        if (query(mid) &lt; x) head &#x3D; mid + 1;</span><br><span class="line">        else tail &#x3D; mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    for (int i &#x3D; n; i &gt;&#x3D; 1; --i) &#123;</span><br><span class="line">        ind[i] &#x3D; binary_search(n, cnt[i] + 1);</span><br><span class="line">        add(ind[i], -1, n);</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void output() &#123;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ind[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    read();</span><br><span class="line">    solve();</span><br><span class="line">    output();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>332</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX_N 200000</span><br><span class="line">int c[MAX_N + 5];</span><br><span class="line">#define lowbit(x) (x &amp; -x)</span><br><span class="line">void add(int i, int x, int n) &#123;</span><br><span class="line">    while (i &lt;&#x3D; n) &#123;</span><br><span class="line">        c[i] +&#x3D; x;</span><br><span class="line">        i +&#x3D; lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int i) &#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    while (i) &#123;</span><br><span class="line">        sum +&#x3D; c[i];</span><br><span class="line">        i -&#x3D; lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int cnt[MAX_N + 5];</span><br><span class="line">int val[MAX_N + 5];</span><br><span class="line">int ind[MAX_N + 5];</span><br><span class="line">int ans[MAX_N + 5];</span><br><span class="line"></span><br><span class="line">int binary_search(int n, int x) &#123;</span><br><span class="line">    int head &#x3D; 1, tail &#x3D; n, mid;</span><br><span class="line">    while (head &lt; tail) &#123;</span><br><span class="line">        mid &#x3D; (head + tail) &gt;&gt; 1;</span><br><span class="line">        if (query(mid) &lt; x) head &#x3D; mid + 1;</span><br><span class="line">        else tail &#x3D; mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void read() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; cnt[i] &gt;&gt; val[i];</span><br><span class="line">        add(i, 1, n);</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    for (int i &#x3D; n; i &gt;&#x3D; 1; --i) &#123;</span><br><span class="line">        ind[i] &#x3D; binary_search(n, cnt[i] + 1);</span><br><span class="line">        add(ind[i], -1, n);</span><br><span class="line">        ans[ind[i]] &#x3D; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void output() &#123;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        i &#x3D;&#x3D; 1 || cout &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    read();</span><br><span class="line">    solve();</span><br><span class="line">    output();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="二、海贼-OJ-328-楼兰图腾1"><a href="#二、海贼-OJ-328-楼兰图腾1" class="headerlink" title="二、海贼 OJ-328-楼兰图腾1"></a>二、海贼 OJ-328-楼兰图腾1</h2><ol>
<li>求在当前位置之前，小于当前位置值的元素数量，当前元素值记为 X，元素数量记为 a，元素位置记为 i</li>
<li>前面小于 $X$ 的元素数量是 $a$</li>
<li>后面小于 $X$ 的元素数量是$X - a - 1$</li>
<li>前面大于 $X$ 的元素数量 $i - a - 1$</li>
<li>后面大于X 的元素数量$n-X-i+a+1$</li>
<li>解题关键：前面小于 $X$ 的元素数量是 $a$</li>
<li>标记数组，记录当前位置之前有哪些元素出现过，出现过标记为 1，否则标记为 0</li>
<li>$a$ 等于标记数组在 $X$ 位置之前的前缀和</li>
<li>对于标记数组的单点修改及前缀和查询，所以可以使用树状数组</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX_N 200000</span><br><span class="line">long long c[MAX_N + 5];</span><br><span class="line">#define lowbit(x) (x &amp; -x)</span><br><span class="line">void add(long long i, long long x, long long n) &#123;</span><br><span class="line">    while (i &lt;&#x3D; n) &#123;</span><br><span class="line">        c[i] +&#x3D; x;</span><br><span class="line">        i +&#x3D; lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long query(long long i) &#123;</span><br><span class="line">    long long sum &#x3D; 0;</span><br><span class="line">    while (i) &#123;</span><br><span class="line">        sum +&#x3D; c[i];</span><br><span class="line">        i -&#x3D; lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long n;</span><br><span class="line">long long val[MAX_N + 5];</span><br><span class="line"></span><br><span class="line">void read() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (long long i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve(long long &amp;x, long long &amp;y) &#123;</span><br><span class="line">    x &#x3D; y &#x3D; 0;</span><br><span class="line">    for (long long i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        long long a1 &#x3D; query(val[i]);</span><br><span class="line">        long long a2 &#x3D; val[i] - a1 - 1;</span><br><span class="line">        long long b1 &#x3D; i - a1 - 1;</span><br><span class="line">        long long b2 &#x3D; n - val[i] - b1;</span><br><span class="line">        x +&#x3D; b1 * b2;</span><br><span class="line">        y +&#x3D; a1 * a2;</span><br><span class="line">        add(val[i], 1, n);</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    read();</span><br><span class="line">    long long a, b;</span><br><span class="line">    solve(a, b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="三、海贼-OJ-333-区间最大子段和1"><a href="#三、海贼-OJ-333-区间最大子段和1" class="headerlink" title="三、海贼 OJ-333-区间最大子段和1"></a>三、海贼 OJ-333-区间最大子段和1</h2><ol>
<li>线段树有点点儿难度的题目</li>
<li>每个节点：区间和值，最大子段和值，左侧最大子段和，右侧最大子段和</li>
<li>特殊性质：递归遍历时，是按照下标顺序得到的每一个查询区间内的线段树的节点</li>
<li>$|①②③④⑤|$，就是按照①②③④⑤的顺序遍历得到的每一个节点</li>
<li>代码有点儿复杂，学会了，代码思维会更上一层楼</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX_N 500000</span><br><span class="line">#define L(ind) (ind &lt;&lt; 1)</span><br><span class="line">#define R(ind) (ind &lt;&lt; 1 | 1)</span><br><span class="line">#define SUM(ind) tree[ind].sum</span><br><span class="line">#define INMAX(ind) tree[ind].inmax</span><br><span class="line">#define LMAX(ind) tree[ind].lmax</span><br><span class="line">#define RMAX(ind) tree[ind].rmax</span><br><span class="line">struct Data&#123;</span><br><span class="line">    int sum, inmax, lmax, rmax;</span><br><span class="line">&#125; _tree[(MAX_N &lt;&lt; 2) + 5];</span><br><span class="line">Data *tree &#x3D; _tree + 1;</span><br><span class="line">int n, m, flag;</span><br><span class="line">int val[MAX_N + 5];</span><br><span class="line"></span><br><span class="line">void UP(int a, int b, int c) &#123;</span><br><span class="line">    SUM(a) &#x3D; SUM(b) + SUM(c);</span><br><span class="line">    LMAX(a) &#x3D; max(LMAX(b), SUM(b) + LMAX(c));</span><br><span class="line">    RMAX(a) &#x3D; max(RMAX(c), SUM(c) + RMAX(b));</span><br><span class="line">    INMAX(a) &#x3D; max(max(INMAX(b), INMAX(c)), RMAX(b) + LMAX(c));</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build(int ind, int l, int r) &#123;</span><br><span class="line">    if (l &#x3D;&#x3D; r) &#123;</span><br><span class="line">        SUM(ind) &#x3D; INMAX(ind) &#x3D; LMAX(ind) &#x3D; RMAX(ind) &#x3D; val[l];</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid &#x3D; (l + r) &gt;&gt; 1;</span><br><span class="line">    build(ind &lt;&lt; 1, l, mid);</span><br><span class="line">    build(ind &lt;&lt; 1 | 1, mid + 1, r);</span><br><span class="line">    UP(ind, ind &lt;&lt; 1, ind &lt;&lt; 1 | 1);</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void modify(int ind, int l, int r, int i, int x) &#123;</span><br><span class="line">    if (l &#x3D;&#x3D; r) &#123;</span><br><span class="line">        SUM(ind) &#x3D; INMAX(ind) &#x3D; LMAX(ind) &#x3D; RMAX(ind) &#x3D; x;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid &#x3D; (l + r) &gt;&gt; 1;</span><br><span class="line">    if (i &lt;&#x3D; mid) &#123;</span><br><span class="line">        modify(ind &lt;&lt; 1, l, mid, i, x);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        modify(ind &lt;&lt; 1 | 1, mid + 1, r, i, x);</span><br><span class="line">    &#125;</span><br><span class="line">    UP(ind, ind &lt;&lt; 1, ind &lt;&lt; 1 | 1);</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void query(int ind, int l, int r, int x, int y) &#123;</span><br><span class="line">    if (x &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; y) &#123;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            tree[0] &#x3D; tree[ind];</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            UP(-1, 0, ind);</span><br><span class="line">            tree[0] &#x3D; tree[-1];</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid &#x3D; (l + r) &gt;&gt; 1;</span><br><span class="line">    if (x &lt;&#x3D; mid) &#123;</span><br><span class="line">        query(ind &lt;&lt; 1, l, mid, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    if (y &gt; mid) &#123;</span><br><span class="line">        query(ind &lt;&lt; 1 | 1, mid + 1, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    build(1, 1, n);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        int k, x, y;</span><br><span class="line">        cin &gt;&gt; k &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        switch (k) &#123;</span><br><span class="line">            case 1: &#123;</span><br><span class="line">                if (x &gt; y) swap(x, y);</span><br><span class="line">                flag &#x3D; 1;</span><br><span class="line">                query(1, 1, n, x, y);</span><br><span class="line">                cout &lt;&lt; INMAX(0) &lt;&lt; endl;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case 2: &#123;</span><br><span class="line">                modify(1, 1, n, x, y);</span><br><span class="line">            &#125; break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    solve();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="8-字符串的匹配算法-上"><a href="#8-字符串的匹配算法-上" class="headerlink" title="8.字符串的匹配算法(上)"></a>8.字符串的匹配算法(上)</h1><h2 id="8-1暴力匹配算法"><a href="#8-1暴力匹配算法" class="headerlink" title="8.1暴力匹配算法"></a>8.1暴力匹配算法</h2><ol>
<li>字符串匹配问题：单模匹配问题，顾名思义，只有一个模式串</li>
<li>依次对齐模式串和文本串的每一位，直到匹配成功</li>
<li>关键：不重不漏的找到答案</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8A%E5%8D%8810.36.32.png" alt="截屏2021-01-18 上午10.36.32"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>; t[j]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i + j] &amp;&amp; s[i + j] == t[j]) <span class="keyword">continue</span>;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;match(%s, %s) = %d\n&quot;</span>, s, t, brute_force(s, t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="8-2KMP-算法"><a href="#8-2KMP-算法" class="headerlink" title="8.2KMP 算法"></a>8.2KMP 算法</h2><ol>
<li><p>KMP 算法中，模式串中的第三部分的重要性</p>
</li>
<li><p>第三部分是可以帮助我们加快匹配速度的，避免掉大量无用的匹配尝试</p>
</li>
<li><p>KMP 算法保证不漏：第三部分匹配到的是模式串的最长前缀</p>
</li>
<li><p>普通编码：获得 NEXT 数组，使用 NEXT 数组</p>
</li>
<li><p>高级编码：抽象化了一个状态机模型，j 所指向的就是状态机中的位置</p>
</li>
<li><p>getNext 方法相当于根据输入字符，进行状态跳转，实际上就是改变 j 的值</p>
</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%884.43.10.png" alt="截屏2021-01-18 下午4.43.10"></p>
<p>next数组:</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%885.08.27.png" alt="截屏2021-01-18 下午5.08.27"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%885.12.55%201.png" alt="截屏2021-01-18 下午5.12.55 1"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>; t[j]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i + j] &amp;&amp; s[i + j] == t[j]) <span class="keyword">continue</span>;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//预处理t字符串，储存在next数组中，next数组存储匹配到字符串的下标</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;<span class="comment">//指向上一位next数组的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;<span class="comment">//遍历t字符串</span></span><br><span class="line">      <span class="comment">//如果上一位next数组的值不为-1且当前数组位置的值和字符串不匹配，</span></span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; t[j + <span class="number">1</span>] != t[i]) j = next[j];</span><br><span class="line">      <span class="comment">//字符串j+1位!=当前位置,但是t[j]=t[i - 1],</span></span><br><span class="line">      <span class="comment">//如果要使t[j + 1] = t[i],就可以跟着next[j]往回走，</span></span><br><span class="line">      <span class="comment">//直到t[j + 1] = t[i]或者没有找到，直到j = -1</span></span><br><span class="line">        <span class="keyword">if</span> (t[j + <span class="number">1</span>] == t[i]) j += <span class="number">1</span>;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化next数组</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">int</span> *next = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n + <span class="number">1</span>);</span><br><span class="line">    getNext(t, next);</span><br><span class="line">    <span class="comment">//输出next数组的值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%d &quot;, next[i]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//使用next数组进行匹配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="comment">//s[i]!=t[j+1]</span></span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; s[i] - t[j + <span class="number">1</span>]) j = next[j];  </span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j + <span class="number">1</span>]) j += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t[j + <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> i - n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;brute_force(%s, %s) = %d\n&quot;</span>, s, t, brute_force(s, t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;kmp(%s, %s) = %d\n&quot;</span>, s, t, kmp(s, t));</span><br><span class="line">        <span class="comment">//printf(&quot;brute_force(%s, %s) = %d\n&quot;, s, t, brute_force(s, t));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对代码进行优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; t[j] &amp;&amp; flag; j++) &#123;</span><br><span class="line">            flag = flag &amp;&amp; (s[i + j] &amp;&amp; s[i + j] == t[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">int</span> &amp;j, <span class="keyword">char</span> input, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//传入j和当前位置的字符串</span></span><br><span class="line">    <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; t[j + <span class="number">1</span>] != input) j = next[j];</span><br><span class="line">    <span class="keyword">if</span> (t[j + <span class="number">1</span>] == input) j += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">int</span> *next = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n + <span class="number">1</span>);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; t[i]; i++) next[i] = getNext(t, j, t[i], next);<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getNext(t, j, s[i], next) != n - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - n + <span class="number">1</span>;<span class="comment">//匹配完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;brute_force(%s, %s) = %d\n&quot;</span>, s, t, brute_force(s, t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;kmp(%s, %s) = %d\n&quot;</span>, s, t, kmp(s, t));</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="8-3SUNDAY-算法"><a href="#8-3SUNDAY-算法" class="headerlink" title="8.3SUNDAY 算法"></a>8.3SUNDAY 算法</h2><ol>
<li>SUNDAY 算法理解的核心，在于理解黄金对齐点位</li>
<li>是文本串的匹配尾部，一定会出现在模式串中的字符</li>
<li>应该和模式串中最后一位出现该字符的位置对齐</li>
<li>第一步：预处理每一个字符在模式串中最后一次出现的位置</li>
<li>第二步：模拟暴力匹配算法过程，失配的时候，文本串指针根据预处理信息向后移动若干位</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.06.30.png" alt="截屏2021-01-18 下午9.06.30"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.06.51.png" alt="截屏2021-01-18 下午9.06.51"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.07.10.png" alt="截屏2021-01-18 下午9.07.10"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.30.57.png" alt="截屏2021-01-18 下午9.30.57"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.30.43.png" alt="截屏2021-01-18 下午9.30.43"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; t[j] &amp;&amp; flag; j++) &#123;</span><br><span class="line">            flag = flag &amp;&amp; (s[i + j] &amp;&amp; s[i + j] == t[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sunday</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> offset[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(t), m = <span class="built_in">strlen</span>(s);</span><br><span class="line">  	<span class="comment">//第一次匹配的时候会从t字符串末尾开始匹配</span></span><br><span class="line"> 	 <span class="comment">//初始化offset数组，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) offset[i] = n + <span class="number">1</span>;</span><br><span class="line"> 	 <span class="comment">//假如所有字符都没没有出现过，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; t[i]; i++) offset[t[i]] = n - i;</span><br><span class="line">  	<span class="comment">//遍历t字符串,字符串出现在倒数第n-i位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + n &lt;= m; i += offset[s[i + n]]) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; t[j] &amp;&amp; flag; j++) &#123;</span><br><span class="line">            flag = flag &amp;&amp; (s[i + j] == t[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;brute_force(%s, %s) = %d\n&quot;</span>, s, t, brute_force(s, t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sunday(%s, %s) = %d\n&quot;</span>, s, t, sunday(s, t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brute_force(123456789, aeadaeadaeae) = -1</span><br><span class="line">sunday(123456789, aeadaeadaeae) = -1</span><br><span class="line">brute_force(hello, ll) = 2</span><br><span class="line">sunday(hello, ll) = 2</span><br><span class="line">brute_force(world, ld) = 3</span><br><span class="line">sunday(world, ld) = 3</span><br><span class="line">brute_force(haizei, hu) = -1</span><br><span class="line">sunday(haizei, hu) = -1</span><br></pre></td></tr></table></figure>




<h1 id="9-字符串匹配算法-中"><a href="#9-字符串匹配算法-中" class="headerlink" title="9 字符串匹配算法(中)"></a>9 字符串匹配算法(中)</h1><h2 id="9-1字符串的哈希匹配算法"><a href="#9-1字符串的哈希匹配算法" class="headerlink" title="9.1字符串的哈希匹配算法"></a>9.1字符串的哈希匹配算法</h2><h3 id="HAIZEIOJ-275-兔子与兔子"><a href="#HAIZEIOJ-275-兔子与兔子" class="headerlink" title="HAIZEIOJ-275.兔子与兔子"></a>HAIZEIOJ-275.兔子与兔子</h3><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.16.17.png" alt="截屏2021-01-19 下午2.16.17"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.16.34.png" alt="截屏2021-01-19 下午2.16.34"></p>
<ol>
<li>可以使用哈希操作判断两个字符串是否相等</li>
<li>哈希值不同的话，两个字符串一定不相等，从而就不需要按位比较了</li>
<li>$H = (\sum_{k=0}^{n-1}{C_k\times base^k})%P$</li>
<li>在文本串上，每一位字符串哈希值的前缀和，方便以后求区间和</li>
<li>$H(i,j)=(HS_j-HS_{i-1})\times (base^i)^{-1}%P $//求i~j的哈希值</li>
</ol>
<h3 id="快速求逆元的推导过程"><a href="#快速求逆元的推导过程" class="headerlink" title="快速求逆元的推导过程"></a>快速求逆元的推导过程</h3><p>$$<br>\begin{aligned}<br>x\times x^{-1}&amp;\equiv1\ (mod\ P) \<br>令：P%x&amp;=r \<br>P &amp;= kx+r \<br>kx+r &amp;\equiv0\ (mod\ P) \<br>kr^{-1}+x^{-1} &amp;\equiv0\ (mod\ P) \<br>x^{-1} &amp;\equiv-kr^{-1}\ (mod\ P)<br>\end{aligned}<br>$$</p>
<h3 id="哈希值的计算"><a href="#哈希值的计算" class="headerlink" title="哈希值的计算"></a>哈希值的计算</h3><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.36.27.png"></p>
<p>逆元</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.41.05.png" alt="截屏2021-01-19 下午2.41.05"></p>
<p>逆元的推导：*</p>
<p>r=P%x</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.41.13.png" alt="截屏2021-01-19 下午2.41.13"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> inv[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//求1~7的7的逆元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">7</span>; i++) &#123;<span class="comment">//P = 7</span></span><br><span class="line">        <span class="comment">//inv[i] = (-(7/i) * inv[7 % i]);==&gt;是负数，将负数变成正数</span></span><br><span class="line">        inv[i] = ((-(<span class="number">7</span> / i) * inv[<span class="number">7</span> % i]) % <span class="number">7</span> + <span class="number">7</span>) % <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; inv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2:4</span><br><span class="line">3:5</span><br><span class="line">4:2</span><br><span class="line">5:3</span><br><span class="line">6:6</span><br></pre></td></tr></table></figure>


<h2 id="9-2-shift-and-算法"><a href="#9-2-shift-and-算法" class="headerlink" title="9.2 shift_and 算法"></a>9.2 shift_and 算法</h2><ol>
<li>第一步对模式串做特殊处理，把每一种字符出现的位置，转换成相应的二进制编码</li>
<li>后续匹配的过程中跟模式串一毛钱关系都没有</li>
<li>$p_i = (p_{i-1}&lt;&lt;1 | 1) &amp; d[s_i]$</li>
<li>$p_i$第 j 位二进制为1，代表当前位置为结尾，可以匹配成功模式串的第 j 位</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%888.38.00.png" alt="截屏2021-01-19 下午8.38.00"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.46.34.png" alt="截屏2021-01-19 下午2.46.34"></p>
<p>i = 1,P = 010000</p>
<p>i = 4, P = 010010</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;<span class="comment">//暴力匹配算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; t[j] &amp;&amp; flag; j++) &#123;</span><br><span class="line">            flag = flag &amp;&amp; (s[i + j] &amp;&amp; s[i + j] == t[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift_and</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, n = <span class="number">0</span>;<span class="comment">//处理模式串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; t[i]; n++,i++) d[t[i]] |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        p = (p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &amp; d[s[i]];</span><br><span class="line">        <span class="keyword">if</span> (p &amp; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>))) <span class="keyword">return</span> i - n + <span class="number">1</span>;<span class="comment">//判断p的第n位是否为1，是：完全匹配成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;brute_force(%s, %s) = %d\n&quot;</span>, s, t, brute_force(s, t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shitf_and(%s, %s) = %d\n&quot;</span>, s, t, shift_and(s, t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="9-3-字典树结构"><a href="#9-3-字典树结构" class="headerlink" title="9.3 字典树结构"></a>9.3 字典树结构</h2><ol>
<li>也叫做：前缀索引树</li>
<li>把每个字符串按照前缀的顺序插入到树形结构中</li>
<li>字典树可以用于==字符串的排序==，时间复杂度 $O(n)$</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="comment">//字典树</span></span><br><span class="line">    <span class="keyword">int</span> flag;<span class="comment">//标记当前结点是否独立成词</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>[<span class="title">BASE</span>];</span><span class="comment">//假如只有26个字符串</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;next, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;next));<span class="comment">//将p的子树的每一个值都初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *p, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[ind] == <span class="literal">NULL</span>)  p-&gt;next[ind] = getNewNode();</span><br><span class="line">        p = p-&gt;next[ind];<span class="comment">//向下走动一个结点，继续向下插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        clear(root-&gt;next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root, <span class="keyword">int</span> k, <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    s[k] = <span class="number">0</span>;<span class="comment">//字符串的最后一位为0</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;flag) &#123;<span class="comment">//当前结点独立成词</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;<span class="comment">//遍历子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;<span class="comment">//当前子节点为空</span></span><br><span class="line">        <span class="comment">//当前子节点不为空继续向下遍历</span></span><br><span class="line">        s[k] = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">        output(root-&gt;next[i], k + <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        insert(root, str);</span><br><span class="line">    &#125;</span><br><span class="line">    output(root, <span class="number">0</span>, str);<span class="comment">//深度优先遍历，当前字典树所在结点地址root，所在层数0， 字符串</span></span><br><span class="line">    clear(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="9-4-海贼-OJ-282-最大异或对"><a href="#9-4-海贼-OJ-282-最大异或对" class="headerlink" title="9.4 海贼 OJ-282-最大异或对"></a>9.4 海贼 OJ-282-最大异或对</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%8811.52.03.png" alt="截屏2021-01-19 下午11.52.03"></p>
<ol>
<li>思考：如何使得异或结果尽可能大</li>
<li>结论：参与异或运算的两个数字，参与异或运算的每一位尽可能不同</li>
<li>问题转换为：确定一个数字的情况下，找到从高为到低位与当前数字尽量不同的另外一个数字</li>
<li>把每个数字看成一个二进制字符串，插入到字符串中，采用贪心策略进行选择</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 310000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 31</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Node *next[<span class="number">2</span>];</span><br><span class="line">&#125; tree[MAX_N * BASE + <span class="number">5</span>];<span class="comment">//假如 每个都是32位，所以需要flag</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;tree[cnt++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//插入x</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = !!(x &amp; (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">        <span class="comment">//归一化，将(1 &lt;&lt; i) 转换成0或1,(1 &lt;&lt; 1) == 2,!!(1 &amp; 2) = 0,!!(2 &amp; 2) = 1</span></span><br><span class="line">        <span class="comment">//ind = (x &amp; (1 &lt;&lt; i)) % 2;</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[ind] == <span class="literal">NULL</span>) root-&gt;next[ind] = getNewNode();</span><br><span class="line">        root = root-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//求和x所能形成的最大异或和</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = !(x &amp; (<span class="number">1</span> &lt;&lt; i));<span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[ind]) &#123;<span class="comment">//判断第i位异或结果能不能为1</span></span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i);<span class="comment">//将ans的第i为置为1</span></span><br><span class="line">            root = root-&gt;next[ind];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = root-&gt;next[!ind];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> val [MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    insert(root, a);</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">while</span> (n --) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        ans = max(query(root, a), ans);</span><br><span class="line">        insert(root, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="10-字符串匹配算法-下"><a href="#10-字符串匹配算法-下" class="headerlink" title="10 字符串匹配算法(下)"></a>10 字符串匹配算法(下)</h1><p>字典树是字典数据的另一种表现形式，本质字典树+AC自动机s</p>
<h2 id="10-1多模匹配问题"><a href="#10-1多模匹配问题" class="headerlink" title="10.1多模匹配问题"></a>10.1多模匹配问题</h2><ol>
<li>有多个模式串的匹配问题，就是多模匹配问题</li>
<li>Step1：多个模式串，建立成一棵字典树</li>
<li>Step2：和文本串的每一位对齐匹配，模拟暴力匹配算法的过程</li>
</ol>
<h2 id="10-2AC-自动机的思想"><a href="#10-2AC-自动机的思想" class="headerlink" title="10.2AC 自动机的思想"></a>10.2AC 自动机的思想</h2><ol>
<li>当匹配成功文本串中的 she 时，也就意味着后续一定会匹配成功 he</li>
<li>she 对应了字典树中的节点 P，he 对应了字典树中的节点Q</li>
<li>P 和 Q 就是等价匹配节点，如果从 P 引出一条边指向 Q，就可以加速匹配过程</li>
<li>在 P 下面查找节点的操作，等价于在 Q 下面查找节点的操作</li>
<li>这条等价关系边，通常在 AC 自动机上叫做 【Fail 指针】</li>
<li>AC 自动机 = Trie + Fail 指针(字典树+fai指针)</li>
<li>子节点的 Fail 指针是需要参照父节点的 Fail指针信息的，最简单的建立方式，就是采用【层序遍历】</li>
<li>没做优化的 AC 自动机，本质上是一个 NFA（非确定型有穷状态自动机）</li>
<li>通俗理解：根据当前状态 p，以及输入字符 c，无法通过一步操作确定状态</li>
<li>第二种理解：当前状态，并不代表唯一状态。(当前状态、当前状态的fail的状态，当前状态的fail的fail的状态)</li>
</ol>
<p><strong>AC 自动机优化：</strong>使用路径压缩思想，使状态转移时可以一步跳转到目标状态。</p>
<p>优化以后的 AC 自动机，更像 DFA（确定性有穷状态自动机）。</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-24%20%E4%B8%8B%E5%8D%884.30.09.png" alt="截屏2021-01-24 下午4.30.09"></p>
<h2 id="10-3代码实现"><a href="#10-3代码实现" class="headerlink" title="10.3代码实现"></a>10.3代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;<span class="comment">//是否独立成词，1是，0不是</span></span><br><span class="line">    <span class="keyword">int</span> tag[BASE];<span class="comment">//记录每一条边是否被优化过：1字典树中的边，0：ac自动机中的边</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>[<span class="title">BASE</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">fail</span>;</span><span class="comment">//等价关系指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> node_cnt = <span class="number">0</span>;<span class="comment">//记录当前环境一共有多少个节点</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node_cnt += <span class="number">1</span>;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;next, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;next));</span><br><span class="line">    p-&gt;fail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *root, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;<span class="comment">//以字典树的形式插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[ind] == <span class="literal">NULL</span>) root-&gt;next[ind] = getNewNode();<span class="comment">//要插入的新节点为空</span></span><br><span class="line">        root-&gt;tag[ind] = <span class="number">1</span>;</span><br><span class="line">        root = root-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    root-&gt;str = strdup(str);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_ac</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//建立ac自动机</span></span><br><span class="line">    <span class="comment">//用层序遍历的方式遍历，建立fail指针,层序遍历使用队列</span></span><br><span class="line">    Node **q = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *) * (node_cnt + <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    root-&gt;fail = <span class="literal">NULL</span>;<span class="comment">//初始化根节点fail指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;<span class="comment">//初始化其他节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root-&gt;next[i] = root;<span class="comment">//根节点的next为空，默认指向根节点</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;next[i]-&gt;fail = root;<span class="comment">//根节点下面的第一层fail默认指向根节点</span></span><br><span class="line">        q[tail++] = root-&gt;next[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;<span class="comment">//当队列不为空</span></span><br><span class="line">        Node *p = q[head++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">            Node *c = p-&gt;next[i], *k = p-&gt;fail;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;<span class="comment">//当前节点没有子孩子</span></span><br><span class="line">                p-&gt;next[i] = k-&gt;next[i];<span class="comment">//没有子孩子，直接指向fail指向的节点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k &amp;&amp; k-&gt;next[i] == <span class="literal">NULL</span>) k = k-&gt;fail;<span class="comment">//fail不为空且没有子孩子则直接指向fail</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">NULL</span>) k = root;</span><br><span class="line">            <span class="keyword">if</span> (k-&gt;next[i]) k = k-&gt;next[i];<span class="comment">//k-&gt;next[i] != NULL,fail指向的节点那个节点和c指向的节点对应</span></span><br><span class="line">            c-&gt;fail = k;</span><br><span class="line">            q[tail++] = c;<span class="comment">//c节点压入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(Node *root, <span class="keyword">const</span> <span class="keyword">char</span> *text)</span> </span>&#123;<span class="comment">//AC自动机的匹配过程</span></span><br><span class="line">    Node *p = root;<span class="comment">//当前状态的位置</span></span><br><span class="line">    Node *q;<span class="comment">//下一次要跳转的状态</span></span><br><span class="line">  <span class="comment">// for (int i = 0; text[i]; i++) &#123;//遍历文本串的每一位</span></span><br><span class="line">    <span class="comment">//     int ind = text[i] - &#x27;a&#x27;;</span></span><br><span class="line">    <span class="comment">//      while (p &amp;&amp; p-&gt;next[ind] == NULL ) p = p-&gt;fail;//找不到文本串的内容，就通过fail指针向上跳</span></span><br><span class="line">    <span class="comment">//      if (p == NULL) p = root;;</span></span><br><span class="line">    <span class="comment">//      if (p-&gt;nex[ind]) p = p-&gt;ext[ind];</span></span><br><span class="line">    <span class="comment">//      q = p;</span></span><br><span class="line">    <span class="comment">//      while (q) &#123;//当前的是fail对应的指针独立成词</span></span><br><span class="line">    <span class="comment">//      if (q-&gt;flag == 1) printf(&quot;find : %s\n&quot;, q-&gt;str);//输出</span></span><br><span class="line">    <span class="comment">//          q = q-&gt;fail;</span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">    <span class="comment">//      if (q-&gt;flag == 1) printf(&quot;find : %s\n&quot;, q-&gt;str);//p所在的节点独立成词</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// 优化，将空节点指向fail</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; text[i]; i++) &#123;<span class="comment">//遍历文本串的每一位</span></span><br><span class="line">        <span class="keyword">int</span> ind = text[i] -<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        p = p-&gt;next[ind];</span><br><span class="line">        q = p;</span><br><span class="line">        <span class="keyword">while</span> (q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q-&gt;flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;find : %s\n&quot;</span>, q-&gt;str);</span><br><span class="line">            q = q-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;tag[i]) clear(root-&gt;next[i]);<span class="comment">//是字典树上的边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        insert(root, str);</span><br><span class="line">    &#125;</span><br><span class="line">    build_ac(root);<span class="comment">//建立AC自动机</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;build ac\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    match(root, str);<span class="comment">//匹配文本串</span></span><br><span class="line">    clear(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">say</span><br><span class="line">she</span><br><span class="line">shr</span><br><span class="line">he</span><br><span class="line">her</span><br><span class="line">sasherhs</span><br></pre></td></tr></table></figure>


<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build ac</span><br><span class="line">find : she</span><br><span class="line">find : he</span><br><span class="line">find : he</span><br></pre></td></tr></table></figure>


<h2 id="10-4字符串统计"><a href="#10-4字符串统计" class="headerlink" title="10.4字符串统计"></a>10.4字符串统计</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-25%20%E4%B8%8B%E5%8D%885.01.20.png" alt="截屏2021-01-25 下午5.01.20"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-25%20%E4%B8%8B%E5%8D%885.01.42.png" alt="截屏2021-01-25 下午5.01.42"></p>
<ol>
<li><p>AC 自动机裸题</p>
</li>
<li><p>解题的关键，在于如何维护每一个单词的计数量</p>
</li>
<li><p>使用幼儿园必知必会的指针技巧维护的</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 20000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag, *cnt;<span class="comment">//是否独立成词,指针ans中的某个元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">26</span>], fail;<span class="comment">//26条边,英文单词有26个,存储单词所在数组的下标编号</span></span><br><span class="line">&#125; tree[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> que[MAX_N + <span class="number">5</span>], head, tail;<span class="comment">//队列</span></span><br><span class="line"><span class="keyword">int</span> *ans[MAX_N + <span class="number">5</span>];<span class="comment">//ans[i]:第i个单词出现的次数</span></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>, cnt = <span class="number">2</span>;<span class="comment">//根节点编号,当前可用节点编号</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100005</span>];<span class="comment">//文本串,即字符串 S,仅由小写字母组成，长度不超过 10^5,表示蒜头君看的文章</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNewNode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cnt++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;<span class="comment">//在字典树中插入单词</span></span><br><span class="line">    <span class="keyword">int</span> p = root;<span class="comment">//p指向根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = str[i] - <span class="string">&#x27;a&#x27;</span>;<span class="comment">//第i位所对应根的编号</span></span><br><span class="line">        <span class="keyword">if</span> (tree[p].next[ind] == <span class="number">0</span>) tree[p].next[ind] = getNewNode();<span class="comment">//p节点的第ind条边</span></span><br><span class="line">        p = tree[p].next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    tree[p].flag = <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (tree[p].cnt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tree[p].cnt = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        tree[p].cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;<span class="comment">//建立fail指针</span></span><br><span class="line">    <span class="comment">//初始化队列</span></span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    tree[root].fail = <span class="number">0</span>;<span class="comment">//初始化根节点的fail指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;<span class="comment">//初始化根节点的子孩子</span></span><br><span class="line">        <span class="keyword">if</span> (tree[root].next[i] == <span class="number">0</span>) &#123;<span class="comment">//没有第i个子孩子，直接指向根节点</span></span><br><span class="line">            tree[root].next[i] = root;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[tree[root].next[i]].fail = root;<span class="comment">//根节点的第i个子孩子的fail指针</span></span><br><span class="line">        que[tail++] = tree[root].next[i];<span class="comment">//入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> p = que[head++];<span class="comment">//取出当前节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;<span class="comment">//扫描当前节点的子孩子，建立fail指针</span></span><br><span class="line">            <span class="keyword">int</span> c = tree[p].next[i], k = tree[p].fail;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                tree[p].next[i] = tree[k].next[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            k = tree[k].next[i];</span><br><span class="line">            tree[c].fail = k;</span><br><span class="line">            que[tail++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = root;<span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = str[i] - <span class="string">&#x27;a&#x27;</span>, q;</span><br><span class="line">        p = tree[p].next[ind];</span><br><span class="line">        q = p;</span><br><span class="line">        <span class="keyword">while</span> (q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[q].flag) &#123;<span class="comment">//q节点独立成词</span></span><br><span class="line">                (*tree[q].cnt) += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q = tree[q].fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//第一行输入一个整数 n（10001≤n≤1000），表示蒜头君学习的 n 个单词。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//接下来 n 行，每行输入一个字符串，仅由小写字母组成，长度不超过 20。</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        ans[i] = insert(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);<span class="comment">//文本串，输入一个字符串 S，仅由小写字母组成，长度不超过 10^5，表示蒜头君看的文章。</span></span><br><span class="line">    build();</span><br><span class="line">    match(str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, i, *ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




















<h1 id="0-END"><a href="#0-END" class="headerlink" title="0.END"></a>0.END</h1>]]></content>
      <categories>
        <category>面试笔试算法下</category>
      </categories>
      <tags>
        <tag>面试笔试算法下</tag>
      </tags>
  </entry>
  <entry>
    <title>高级数据结构</title>
    <url>/2020/12/22/04.%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="0、2020-12-22"><a href="#0、2020-12-22" class="headerlink" title="0、2020.12.22"></a>0、2020.12.22</h1><hr>
<h1 id="1-BS二叉排序树"><a href="#1-BS二叉排序树" class="headerlink" title="1.BS二叉排序树"></a>1.BS二叉排序树</h1><p>二叉排序树、二叉搜索树、二叉查找树 、Binary Search Tree</p>
<p>数据结构定义一种性质,并且维护这种性质</p>
<h2 id="1-性质"><a href="#1-性质" class="headerlink" title="1.性质"></a>1.性质</h2><blockquote>
<p>1.左子树 &lt; 根节点</p>
<p>2.根节点 &lt; 右子树</p>
<p>3.中序遍历的结果，是一个有序序列</p>
</blockquote>
<blockquote>
<p>用途：解决与排名相关的检索需求</p>
</blockquote>
<blockquote>
<p>树型结构：边代表关系，点代表集合</p>
</blockquote>
<h2 id="2-BS插入操作"><a href="#2-BS插入操作" class="headerlink" title="2.BS插入操作"></a>2.BS插入操作</h2><blockquote>
<p>1.插入新节点，一定会作为叶子节点</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%886.39.38.png" alt="截屏2020-12-19 下午6.39.38"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;data) root-&gt;lchild = insert(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, val);</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-BS删除操作"><a href="#3-BS删除操作" class="headerlink" title="3.BS删除操作"></a>3.BS删除操作</h2><blockquote>
<p>1.删除叶子节点:直接删除，</p>
<p>2.删除度为1的节点：把孤儿树挂到父节点上面</p>
<p>（更新孩子节点的和父亲节点）</p>
<p>3.删除度为2的结点：找到前驱或者后继替换后转换为度为 0或1的结点问题</p>
</blockquote>
<p>对于度为2 的节点：</p>
<blockquote>
<p>1.前驱：左子树中的最大值</p>
<p>2.后继：右子树中的最小值</p>
</blockquote>
<p>前驱没有右子树，后驱没有左子树，前驱和者后继度为0或1</p>
<p>节点查找次数的期望值：</p>
<blockquote>
<p>平均查找效率：总查找次数(1 + 2 * 节点数 + 3 * 节点数… )/总节点数(n) </p>
<p>$\frac{总查找次数}{节点数}$</p>
<p>假设每个结点等概率被查找</p>
</blockquote>
<a id="more"></a>



<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%8811.15.08.png" alt="截屏2020-12-19 下午11.15.08"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%8811.19.16.png" alt="截屏2020-12-19 下午11.19.16"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%884.46.47.png" alt="截屏2020-12-21 下午4.46.47"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;rchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//找到结点</span></span><br><span class="line">       <span class="comment">/* if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) &#123;</span></span><br><span class="line"><span class="comment">            free(root);</span></span><br><span class="line"><span class="comment">            return NULL;</span></span><br><span class="line"><span class="comment">        &#125; else */</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;<span class="comment">//返回删除节点的孩子节点，将孩子结点挂载到被删除节点的父亲节点上</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//将两个结点的情况转换为一个结点</span></span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-BS代码演示"><a href="#4-BS代码演示" class="headerlink" title="4.BS代码演示"></a>4.BS代码演示</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;data : 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = _data;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) <span class="keyword">return</span> search(root-&gt;lchild, value);</span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;data) root-&gt;lchild = insert(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//前驱</span></span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span>(temp &amp;&amp; temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;rchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//找到结点</span></span><br><span class="line">       <span class="comment">/* if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) &#123;</span></span><br><span class="line"><span class="comment">            free(root);</span></span><br><span class="line"><span class="comment">            return NULL;</span></span><br><span class="line"><span class="comment">        &#125; else */</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;<span class="comment">//返回删除节点的孩子节点，将孩子结点挂载到被删除节点的父亲节点上</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//将两个结点的情况转换为一个结点</span></span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, root-&gt;data);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output1</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output1(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d,%d)\n&quot;</span>, KEY(root), KEY(root-&gt;lchild), KEY(root-&gt;rchild));</span><br><span class="line">    output1(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;<span class="comment">//!!!!!!!!!!!!!!!</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="comment">//0：查找 1：插入 2： 删除</span></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d \n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;insert: %d \n&quot;</span>, val);</span><br><span class="line">                   root = insert(root, val);</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">               &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;erase: %d \n&quot;</span>, val);</span><br><span class="line">                   root = erase(root, val);</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\ntree ==&gt; [&quot;</span>);</span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op) output1(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="5-BS解决排名相关的需求"><a href="#5-BS解决排名相关的需求" class="headerlink" title="5.BS解决排名相关的需求"></a>5.BS解决排名相关的需求</h2><p>输出第k大的元素</p>
<ol>
<li>修改二叉排序树的结构定义，增加 size 字段，记录每棵树的节点数量</li>
<li>$k - 1= LS$，根节点就是排名第 k 位的元素</li>
<li>$k \le LS$，排名第 k 位的元素在左子树中</li>
<li>$k \gt LS，search_k(root-&gt;rchild, k - LS - 1)$</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;data : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(n) (n ? n-&gt;size : 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = _data;</span><br><span class="line">    p-&gt;size = <span class="number">1</span>;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) <span class="keyword">return</span> search(root-&gt;lchild, value);</span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (SIZE(root-&gt;lchild) == k - <span class="number">1</span>) <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(root-&gt;lchild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> search_k(root-&gt;lchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search_k(root-&gt;rchild, k - SIZE(root-&gt;lchild) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_size</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;size = SIZE(root-&gt;lchild)  + SIZE(root-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;data) root-&gt;lchild = insert(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, val);</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//前驱</span></span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span>(temp &amp;&amp; temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;rchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//找到结点</span></span><br><span class="line">       <span class="comment">/* if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) &#123;</span></span><br><span class="line"><span class="comment">            free(root);</span></span><br><span class="line"><span class="comment">            return NULL;</span></span><br><span class="line"><span class="comment">        &#125; else */</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;<span class="comment">//返回删除节点的孩子节点，将孩子结点挂载到被删除节点的父亲节点上</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//将两个结点的情况转换为一个结点</span></span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d[%d] &quot;</span>, root-&gt;data, SIZE(root));</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output1</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output1(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d],%d,%d)\n&quot;</span>, KEY(root), SIZE(root), KEY(root-&gt;lchild), KEY(root-&gt;rchild));</span><br><span class="line">    output1(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="comment">//0：查找 1：插入 2： 删除</span></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d \n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;insert: %d \n&quot;</span>, val);</span><br><span class="line">                   root = insert(root, val);</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">               &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;erase: %d \n&quot;</span>, val);</span><br><span class="line">                   root = erase(root, val);</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;search k = %d, result : %d\n&quot;</span>,</span><br><span class="line">                    val, search_k(root, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\ntree ==&gt; [&quot;</span>);</span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op) output1(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">insert: <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">insert: <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">2</span>] <span class="number">2</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"> <span class="number">1</span> <span class="number">3</span></span><br><span class="line">insert: <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">3</span>] <span class="number">2</span>[<span class="number">2</span>] <span class="number">3</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">3</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line">insert: <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">4</span>] <span class="number">2</span>[<span class="number">3</span>] <span class="number">3</span>[<span class="number">2</span>] <span class="number">4</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">4</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">3</span>],<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line">insert: <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">5</span>] <span class="number">2</span>[<span class="number">4</span>] <span class="number">3</span>[<span class="number">3</span>] <span class="number">4</span>[<span class="number">2</span>] <span class="number">5</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">5</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">4</span>],<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>[<span class="number">3</span>],<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="number">5</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line">search k = <span class="number">1</span>, result : <span class="number">1</span></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">5</span>] <span class="number">2</span>[<span class="number">4</span>] <span class="number">3</span>[<span class="number">3</span>] <span class="number">4</span>[<span class="number">2</span>] <span class="number">5</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">5</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">4</span>],<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>[<span class="number">3</span>],<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="number">5</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line">search k = <span class="number">2</span>, result : <span class="number">2</span></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">5</span>] <span class="number">2</span>[<span class="number">4</span>] <span class="number">3</span>[<span class="number">3</span>] <span class="number">4</span>[<span class="number">2</span>] <span class="number">5</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">5</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">4</span>],<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>[<span class="number">3</span>],<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="number">5</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line">search k = <span class="number">4</span>, result : <span class="number">4</span></span><br><span class="line"></span><br><span class="line">tree ==&gt; [<span class="number">1</span>[<span class="number">5</span>] <span class="number">2</span>[<span class="number">4</span>] <span class="number">3</span>[<span class="number">3</span>] <span class="number">4</span>[<span class="number">2</span>] <span class="number">5</span>[<span class="number">1</span>] ]</span><br><span class="line">(<span class="number">1</span>[<span class="number">5</span>],<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>[<span class="number">4</span>],<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>[<span class="number">3</span>],<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>[<span class="number">2</span>],<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="number">5</span>[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">------------------</span><br></pre></td></tr></table></figure>




<h2 id="6-BS解决Top-K-问题"><a href="#6-BS解决Top-K-问题" class="headerlink" title="6.BS解决Top-K 问题"></a>6.BS解决Top-K 问题</h2><p>（找到小于第 k 位的所有元素）</p>
<ol>
<li>根节点就是第 k 位元素的话，就把左子树中的值全部输出出来</li>
<li>第 k 位在左子树中，前 k 位元素全都在左子树中</li>
<li>第 k 位在右子树中，说明根节点和左子树中的元素，都是前 k 位元素里面的值</li>
</ol>
<p>所谓算法设计及分析能力：分类讨论及归纳总结的能力</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;data : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(n) (n ? n-&gt;size : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(n) (n ? n-&gt;lchild : NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = _data;</span><br><span class="line">    p-&gt;size = <span class="number">1</span>;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) <span class="keyword">return</span> search(root-&gt;lchild, value);</span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (SIZE(root-&gt;lchild) == k - <span class="number">1</span>) <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(root-&gt;lchild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> search_k(root-&gt;lchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search_k(root-&gt;rchild, k - SIZE(root-&gt;lchild) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_size</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;size = SIZE(root-&gt;lchild)  + SIZE(root-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;data) root-&gt;lchild = insert(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, val);</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//前驱</span></span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild =  erase(root-&gt;lchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;rchild =  erase(root-&gt;rchild, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//找到结点</span></span><br><span class="line">       <span class="comment">/* if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) &#123;</span></span><br><span class="line"><span class="comment">            free(root);</span></span><br><span class="line"><span class="comment">            return NULL;</span></span><br><span class="line"><span class="comment">        &#125; else */</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;<span class="comment">//返回删除节点的孩子节点，将孩子结点挂载到被删除节点的父亲节点上</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//将两个结点的情况转换为一个结点</span></span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d[%d] &quot;</span>, root-&gt;data, SIZE(root));</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d], %d, %d)\n&quot;</span>,</span><br><span class="line">           KEY(root), SIZE(root),</span><br><span class="line">           KEY(root-&gt;lchild), KEY(root-&gt;rchild)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output1</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output1(root-&gt;lchild);</span><br><span class="line">    print(root);</span><br><span class="line">    output1(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span> || root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(root-&gt;lchild)) output_k(root-&gt;lchild, k);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        output1(root-&gt;lchild);</span><br><span class="line">        print(root);</span><br><span class="line">        output_k(root-&gt;rchild, k - SIZE(root-&gt;lchild) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="comment">//0：查找 1：插入 2： 删除</span></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d \n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;insert: %d \n&quot;</span>, val);</span><br><span class="line">                   root = insert(root, val);</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">               &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;erase: %d \n&quot;</span>, val);</span><br><span class="line">                   root = erase(root, val);</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;search k = %d, result : %d\n&quot;</span>,</span><br><span class="line">                    val, search_k(root, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;output top-%d elements\n&quot;</span>, val);</span><br><span class="line">                output_k(root, val);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;------------\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\ntree ==&gt; [&quot;</span>);</span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op) output1(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="7-二叉排序树和快排的关系"><a href="#7-二叉排序树和快排的关系" class="headerlink" title="7.二叉排序树和快排的关系"></a>7.二叉排序树和快排的关系</h2><ol>
<li><p>二叉排序树是快速排序在思维逻辑结构层面用的数据结构</p>
</li>
<li><p>思考1：快速排序的时间复杂度和二叉排序树建树时间复杂度之间的关系</p>
</li>
</ol>
<ol start="3">
<li>思考2：快速选择算法和二叉排序树之间的关系</li>
</ol>
<ol start="4">
<li>程序=算法+数据结构</li>
</ol>
<h1 id="2-AVL平衡二叉查找树"><a href="#2-AVL平衡二叉查找树" class="headerlink" title="2.AVL平衡二叉查找树"></a>2.AVL平衡二叉查找树</h1><p>1962年（58）</p>
<p>==<strong>AVL树</strong>==</p>
<h2 id="0-AVL树原理"><a href="#0-AVL树原理" class="headerlink" title="0.AVL树原理"></a>0.AVL树原理</h2><blockquote>
<p>AVL树原理</p>
<p>自平衡条件、旋转操作、旋转的触发</p>
</blockquote>
<p>数据机构：定义一种性质并且维护一种性质</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1.左右子树高度差 小于等于 1</p>
<p>2.平衡二叉排序树，本质上也是二叉排序树，所以拥有二叉排序树的所有性质</p>
<p>3.平衡二叉排序树的学习重点：平衡条件以及平衡调整</p>
<blockquote>
<p>高度为H的BS树所包含的结点数量在什么范围内： $H \le SIZE \le 2^H-1$</p>
<p>高度为H的AVL树所包含的结点数量在什么范围内:  $1.5^H \le SIZE \le 2^H-1$</p>
<p>$low(H) \le SIZE \le 2^H-1$</p>
<p>$low(H-1) + low(H - 2) + 1\le SIZE \le 2^H-1$（斐波那契数列）</p>
<p>$1.5^H \le SIZE \le 2^H-1$</p>
</blockquote>
<p>二叉树性质：二叉树第i层最多有2^i-1^个结点，深度为k最多有2^k^-1个结点</p>
<p>==&gt;AVL节点数n和树高h的关系:h = logn</p>
<p>思考：</p>
<ol>
<li>AVL 树改进的是节点数量的下限</li>
<li>树高 = 生命长度，节点数量 = 生命财富，不同的算法，达到的结果是不同的</li>
<li>教育提升的是底限，而不是上限，上限取决于能力和运气</li>
</ol>
<h2 id="1-自平衡条件"><a href="#1-自平衡条件" class="headerlink" title="1.自平衡条件"></a>1.自平衡条件</h2><h3 id="1-平衡因子"><a href="#1-平衡因子" class="headerlink" title="1.平衡因子"></a>1.平衡因子</h3><p>每个平衡因子的是指左子树最大高度和右子树最大高度差，平衡因子为-1，0，1被认为是平衡的</p>
<h3 id="2-失衡类型"><a href="#2-失衡类型" class="headerlink" title="2.失衡类型"></a>2.失衡类型</h3><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.08.06.png" alt="截屏2020-12-23 下午6.08.06" style="zoom:67%;" />

<h2 id="2-旋转操作：单旋和多旋"><a href="#2-旋转操作：单旋和多旋" class="headerlink" title="2.旋转操作：单旋和多旋"></a>2.旋转操作：单旋和多旋</h2><h3 id="1-单旋"><a href="#1-单旋" class="headerlink" title="1.单旋"></a>1.单旋</h3><p>分为左旋和右旋。AVL树通过一系列的左旋和右旋操作，将不平衡的树调整为二叉查找树</p>
<h4 id="左旋："><a href="#左旋：" class="headerlink" title="左旋："></a>左旋：</h4><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.03.51.png" alt="截屏2020-12-23 下午6.03.51" style="zoom:50%;" />

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.32.31.png" alt="截屏2020-12-21 下午6.32.31" style="zoom: 67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.32.25.png" alt="截屏2020-12-21 下午6.32.25" style="zoom:67%;" />



<h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.03.57.png" alt="截屏2020-12-23 下午6.03.57" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.37.45.png" alt="截屏2020-12-21 下午6.37.45" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.37.41.png" alt="截屏2020-12-21 下午6.37.41" style="zoom:67%;" />



<h3 id="2-多旋："><a href="#2-多旋：" class="headerlink" title="2.多旋："></a>2.多旋：</h3><p>由两次单旋操作组合而成</p>
<h4 id="1-左旋加右旋LR"><a href="#1-左旋加右旋LR" class="headerlink" title="1.左旋加右旋LR"></a>1.左旋加右旋LR</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8812.38.14.png" alt="截屏2020-12-24 下午12.38.14" style="zoom:75%;" /></h4><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.10.27.png" alt="截屏2020-12-23 下午6.10.27" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/26252FD93F9BE46395BB71A8E8888D4A.jpg" alt="26252FD93F9BE46395BB71A8E8888D4A" style="zoom:67%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.45.05.png" alt="截屏2020-12-21 下午6.45.05" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.45.01.png" alt="截屏2020-12-21 下午6.45.01" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.45.10.png" alt="截屏2020-12-21 下午6.45.10" style="zoom:67%;" />



<h4 id="2-右旋加左旋RL"><a href="#2-右旋加左旋RL" class="headerlink" title="2.右旋加左旋RL"></a>2.右旋加左旋RL</h4><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.47.47.png" alt="截屏2020-12-21 下午6.47.47" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.47.42.png" alt="截屏2020-12-21 下午6.47.42" style="zoom:67%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.47.52.png" alt="截屏2020-12-21 下午6.47.52" style="zoom:67%;" />



<h4 id="3-LL"><a href="#3-LL" class="headerlink" title="3. LL"></a>3. LL</h4><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.10.21.png" alt="截屏2020-12-23 下午6.10.21" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/209777F2C379C9542061B8B56572755E.jpg" alt="209777F2C379C9542061B8B56572755E" style="zoom:67%;" />









<h4 id="4-RR与LL对称"><a href="#4-RR与LL对称" class="headerlink" title="4.RR与LL对称"></a>4.RR与LL对称</h4><h2 id="3-旋转的触发"><a href="#3-旋转的触发" class="headerlink" title="3.旋转的触发"></a>3.旋转的触发</h2><p>插入操作：</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.58.33.png" alt="截屏2020-12-21 下午6.58.33"></p>
<p>删除操作：</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.58.42.png" alt="截屏2020-12-21 下午6.58.42"></p>
<blockquote>
<p>平衡调整策略/方法</p>
<ol>
<li>发生在回溯阶段的，第一个失衡节点处</li>
<li>理解平衡调整策略的关键在于：分析清楚四种情况下，ABCD 四棵子树树高的关系</li>
<li>LL，大右旋</li>
<li>LR，先小左旋，再大右旋</li>
<li>RL，先小右旋，再大左旋</li>
<li>RR，大左旋</li>
</ol>
</blockquote>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.22.17.png" alt="截屏2020-12-23 下午6.22.17" style="zoom:67%;" />







<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;<span class="comment">//假的空节点</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL-&gt;data = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;height = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;</span><br><span class="line">    Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = _data;</span><br><span class="line">    node-&gt;lchild = node-&gt;rchild = NIL;</span><br><span class="line">    node-&gt;height = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_height</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;height = (root-&gt;lchild-&gt;height &gt; root-&gt;rchild-&gt;height ? root-&gt;lchild-&gt;height : root-&gt;rchild-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    update_height(root);</span><br><span class="line">    update_height(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//对称</span></span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    update_height(root);</span><br><span class="line">    update_height(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(root-&gt;lchild-&gt;height - root-&gt;rchild-&gt;height) &lt;= <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;height &gt; root-&gt;rchild-&gt;height) &#123;<span class="comment">//L大左旋</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;lchild-&gt;height &lt; root-&gt;lchild-&gt;rchild-&gt;height)<span class="comment">//LR小右旋</span></span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;rchild-&gt;height &lt; root-&gt;lchild-&gt;rchild-&gt;height)<span class="comment">//RL小左旋</span></span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;lchild);<span class="comment">//小右旋</span></span><br><span class="line">        root = left_rotate(root);<span class="comment">//大左旋</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == val) <span class="keyword">return</span> root;<span class="comment">//不需要插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = insert(root-&gt;lchild, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;rchild = insert(root-&gt;rchild, val);</span><br><span class="line">    &#125;</span><br><span class="line">    update_height(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp &amp;&amp; temp-&gt;lchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> NIL;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;rchild = erase(root-&gt;rchild, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild != NIL ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_height(root);</span><br><span class="line">    <span class="keyword">return</span> maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d],%d,%d)\n&quot;</span>,</span><br><span class="line">           root-&gt;data, root-&gt;height,</span><br><span class="line">           root-&gt;lchild-&gt;data,</span><br><span class="line">           root-&gt;rchild-&gt;data);</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: root = erase(root, val);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: root = insert(root, val);</span><br><span class="line">        &#125;</span><br><span class="line">        output(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


















<h1 id="3-SBTree"><a href="#3-SBTree" class="headerlink" title="3*.SBTree"></a>3*.SBTree</h1><p>Size Balanced Tree</p>
<h2 id="1-平衡原理"><a href="#1-平衡原理" class="headerlink" title="1.平衡原理"></a>1.平衡原理</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.20.58.png" alt="截屏2020-12-22 上午10.20.58"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.21.30.png" alt="截屏2020-12-22 上午10.21.30"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.25.01.png" alt="截屏2020-12-22 上午10.25.01"></p>
<h2 id="2-旋转操作"><a href="#2-旋转操作" class="headerlink" title="2.旋转操作"></a>2.旋转操作</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.26.35.png" alt="截屏2020-12-22 上午10.26.35"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.26.45.png" alt="截屏2020-12-22 上午10.26.45"></p>
<h2 id="3-旋转的触发-1"><a href="#3-旋转的触发-1" class="headerlink" title="3.旋转的触发"></a>3.旋转的触发</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.28.20.png" alt="截屏2020-12-22 上午10.28.20"></p>
<h2 id="4-代码实现-1"><a href="#4-代码实现-1" class="headerlink" title="4.代码实现"></a>4.代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SBTNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Type data;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    SBTNode&lt;Type&gt; *lchild, *rchild, *father;</span><br><span class="line">    SBTNode(Type init_data, <span class="keyword">int</span> init_size = <span class="number">0</span>, SBTNode&lt;Type&gt; *init_father = <span class="literal">NULL</span>);</span><br><span class="line">    ~SBTNode();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Type value)</span></span>;</span><br><span class="line">    <span class="function">SBTNode&lt;Type&gt;* <span class="title">search</span><span class="params">(Type value)</span></span>;</span><br><span class="line">    <span class="function">SBTNode&lt;Type&gt;* <span class="title">predecessor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">SBTNode&lt;Type&gt;* <span class="title">successor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_node</span><span class="params">(SBTNode&lt;Type&gt; *delete_node)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(Type value)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SBTNode&lt;Type&gt;* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinaryTree();</span><br><span class="line">    ~BinaryTree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Type value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(Type value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(Type value)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SBTNode&lt;<span class="keyword">int</span>&gt; <span class="title">ZERO</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">SBTNode&lt;<span class="keyword">int</span>&gt;* NIL = &amp;ZERO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">SBTNode&lt;Type&gt;::SBTNode(Type init_data, <span class="keyword">int</span> init_size, SBTNode&lt;Type&gt;* init_father) &#123;</span><br><span class="line">    data = init_data;</span><br><span class="line">    size = init_size;</span><br><span class="line">    lchild = NIL;</span><br><span class="line">    rchild = NIL;</span><br><span class="line">    father = init_father;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">SBTNode&lt;Type&gt;::~SBTNode() &#123;</span><br><span class="line">    <span class="keyword">if</span> (lchild != NIL) &#123;</span><br><span class="line">        <span class="keyword">delete</span> lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rchild != NIL) &#123;</span><br><span class="line">        <span class="keyword">delete</span> rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">SBTNode&lt;Type&gt;* <span class="title">left_rotate</span><span class="params">(SBTNode&lt;Type&gt;* node)</span> </span>&#123;</span><br><span class="line">	SBTNode&lt;Type&gt; *temp =  node-&gt;rchild;</span><br><span class="line">    node-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild-&gt;father = node;</span><br><span class="line">    temp-&gt;lchild = node;</span><br><span class="line">    temp-&gt;father = node-&gt;father;</span><br><span class="line">    node-&gt;father = temp;</span><br><span class="line">    temp-&gt;size = node-&gt;size;</span><br><span class="line">    node-&gt;size = node-&gt;lchild-&gt;size + node-&gt;rchild-&gt;size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">SBTNode&lt;Type&gt;* <span class="title">right_rotate</span><span class="params">(SBTNode&lt;Type&gt;* node)</span> </span>&#123;</span><br><span class="line">  	SBTNode&lt;Type&gt; *temp = node-&gt;lchild;</span><br><span class="line">    node-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild-&gt;father = node;</span><br><span class="line">    temp-&gt;rchild = node;</span><br><span class="line">    temp-&gt;father = node-&gt;father;</span><br><span class="line">    node-&gt;father = temp;</span><br><span class="line">    temp-&gt;size = node-&gt;size;</span><br><span class="line">    node-&gt;size = node-&gt;lchild-&gt;size + node-&gt;rchild-&gt;size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">SBTNode&lt;Type&gt;* <span class="title">maintain</span><span class="params">(SBTNode&lt;Type&gt;* node, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">SBTNode&lt;Type&gt;* <span class="title">insert</span><span class="params">(SBTNode&lt;Type&gt;* node, Type value)</span> </span>&#123;</span><br><span class="line">    node-&gt;size++;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; node-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;rchild == NIL) &#123;</span><br><span class="line">            node-&gt;rchild = <span class="keyword">new</span> SBTNode&lt;Type&gt;(value, <span class="number">1</span>, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;rchild = insert(node-&gt;rchild, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;lchild == NIL) &#123;</span><br><span class="line">            node-&gt;lchild = <span class="keyword">new</span> SBTNode&lt;Type&gt;(value, <span class="number">1</span>, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;lchild = insert(node-&gt;lchild, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maintain(node, value &gt; node-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">SBTNode&lt;Type&gt;* SBTNode&lt;Type&gt;::search(Type value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rchild == NIL) &#123;</span><br><span class="line">            <span class="keyword">return</span> NIL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rchild-&gt;search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lchild == NIL) &#123;</span><br><span class="line">            <span class="keyword">return</span> NIL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lchild-&gt;search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">SBTNode&lt;Type&gt;* SBTNode&lt;Type&gt;::predecessor() &#123;</span><br><span class="line">    SBTNode&lt;Type&gt;* temp = lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp != NIL &amp;&amp; temp-&gt;rchild != NIL) &#123;</span><br><span class="line">        temp = temp-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">SBTNode&lt;Type&gt;* SBTNode&lt;Type&gt;::successor() &#123;</span><br><span class="line">    SBTNode&lt;Type&gt;* temp = rchild;</span><br><span class="line">    <span class="keyword">while</span> (temp != NIL &amp;&amp; temp-&gt;lchild != NIL) &#123;</span><br><span class="line">        temp = temp-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">void</span> SBTNode&lt;Type&gt;::remove_node(SBTNode&lt;Type&gt;* delete_node) &#123;</span><br><span class="line">    SBTNode&lt;Type&gt;* temp = NIL;</span><br><span class="line">    <span class="keyword">if</span> (delete_node-&gt;lchild != NIL) &#123;</span><br><span class="line">        temp = delete_node-&gt;lchild;</span><br><span class="line">        temp-&gt;father = delete_node-&gt;father;</span><br><span class="line">        delete_node-&gt;lchild = NIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delete_node-&gt;rchild != NIL) &#123;</span><br><span class="line">        temp = delete_node-&gt;rchild;</span><br><span class="line">        temp-&gt;father = delete_node-&gt;father;</span><br><span class="line">        delete_node-&gt;rchild = NIL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (delete_node-&gt;father-&gt;lchild == delete_node) &#123;</span><br><span class="line">        delete_node-&gt;father-&gt;lchild = temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delete_node-&gt;father-&gt;rchild = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = delete_node;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp-&gt;size--;</span><br><span class="line">        temp = temp-&gt;father;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> delete_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">bool</span> SBTNode&lt;Type&gt;::remove(Type value) &#123;</span><br><span class="line">    SBTNode&lt;Type&gt; *delete_node, *current_node;</span><br><span class="line">    current_node = search(value);</span><br><span class="line">    <span class="keyword">if</span> (current_node == NIL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current_node-&gt;lchild != NIL) &#123;</span><br><span class="line">        delete_node = current_node-&gt;predecessor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_node-&gt;rchild != NIL) &#123;</span><br><span class="line">        delete_node = current_node-&gt;successor();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delete_node = current_node;</span><br><span class="line">    &#125;</span><br><span class="line">    current_node-&gt;data = delete_node-&gt;data;</span><br><span class="line">    remove_node(delete_node);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">BinaryTree&lt;Type&gt;::BinaryTree() &#123;</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">BinaryTree&lt;Type&gt;::~BinaryTree() &#123;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;Type&gt;::insert(Type value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> SBTNode&lt;Type&gt;(value, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;search(value) == NIL) &#123;</span><br><span class="line">        root = ::insert(root, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">bool</span> BinaryTree&lt;Type&gt;::find(Type value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;search(value) == NIL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">bool</span> BinaryTree&lt;Type&gt;::remove(Type value) &#123;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;remove(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












<h1 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4.红黑树"></a>4.红黑树</h1><h2 id="1-平衡条件"><a href="#1-平衡条件" class="headerlink" title="1.平衡条件"></a>1.平衡条件</h2><ol>
<li>节点非黑既红</li>
<li>根节点是黑色</li>
<li>叶子（NIL）结点是黑色</li>
<li>如果一个节点是红色，则它的两个子节点都是黑色</li>
<li>从根节点到叶子结点路径上，黑色节点数量相同</li>
</ol>
<p>==&gt;最长边和最短边之间的关系：最长边是最短边的二倍</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%889.44.56.png" alt="截屏2020-12-23 下午9.44.56" style="zoom: 33%;" />





<blockquote>
<p>第4条和第5条条件，注定了，红黑树中最长路径是最短路径的长度的 2 倍。</p>
<p>本质上，红黑树也是通过树高来控制平衡的。</p>
<p>红黑树比 AVL 树树高控制条件要更松散，红黑树在发生节点插入和删除以后，发生调整的概率，比 AVL 树要更小。</p>
</blockquote>
<h2 id="2-平衡调整策略"><a href="#2-平衡调整策略" class="headerlink" title="2.平衡调整策略"></a>2.平衡调整策略</h2><p>1.插入调整站在祖父节点看</p>
<p>2.删除调整站在父亲节点看</p>
<p>3.插入和删除的情况处理，一共五种</p>
<blockquote>
<p>理解</p>
<ol>
<li>理解红黑树的插入调整，要站在==祖父节点==向下进行调整</li>
<li>理解红黑树的删除调整，要站在==父节点==向下进行调整</li>
<li>插入调整，主要就是为了解决双红情况</li>
<li>新插入的节点一定是红色，插入黑色节点一定会产生冲突，违反条件5，插入红色节点，不一定产生冲突</li>
<li>把每一种情况，想象成一棵大的红黑树中的局部子树</li>
<li>局部调整的时候，为了不影响全局，调整前后的路径上黑色节点数量相同</li>
</ol>
</blockquote>
<h2 id="3-插入方法"><a href="#3-插入方法" class="headerlink" title="3.插入方法"></a>3.插入方法</h2><p>​                                                                                                                             </p>
<p>1.叔叔节点为红色的时候，修改三元组小帽子，改成红黑黑(4种情况)</p>
<p>x有4个位置，4种情况，但是处理方法一样</p>
<p>根节点必定为黑色，否则插入前已经冲突</p>
<p>eg:1,20修改成黑色，15修改成红色(红色上顶)</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8A%E5%8D%8811.16.48.png" alt="截屏2020-12-24 上午11.16.48"></p>
<p>2.叔叔节点为黑色的时候，有四种情况LL,LR，RL,RR</p>
<p>参考 AVL 树的失衡情况，分成 $LL,LR,RL,RR$, 先参考 AVL 树的旋转调整策略，然后再修改三元组的颜色，有两种调整策略：红色上浮，红色下沉。</p>
<p>eg:LL型进行大右旋，<strong>20</strong>调整成红色，<strong>15</strong>调整成⿊色，即可搞定问题(红色上浮)，</p>
<p>或者调整10为黑色，红色上浮</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8A%E5%8D%8811.17.02.png" alt="截屏2020-12-24 上午11.17.02" style="zoom: 70%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8A%E5%8D%8811.29.58.png" alt="截屏2020-12-24 上午11.29.58" style="zoom:67%;" />

<p>3.两大类情况，包含 8 种小情况</p>
<h2 id="4-插入代码演示"><a href="#4-插入代码演示" class="headerlink" title="4.插入代码演示"></a>4.插入代码演示</h2><ol>
<li>插入调整，发正在递归的回溯阶段</li>
<li>插入调整代码中，使用 goto 语句，8行代码，变成了4行</li>
<li>处理根节点一定是黑色，通过代码封装，$insert-&gt;__insert$</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> color;<span class="comment">//0 red, 1 black 2double black</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL-&gt;data = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;color = <span class="number">1</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;</span><br><span class="line">    Node *root = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    root-&gt;data = _data;</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;</span><br><span class="line">    root-&gt;lchild = root-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">has_red_child</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//判断根节点是否有红色的子孩子</span></span><br><span class="line">    <span class="keyword">return</span> root-&gt;lchild-&gt;color == <span class="number">0</span> || root-&gt;rchild-&gt;color == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!has_red_child(root)) <span class="keyword">return</span> root;<span class="comment">//没有红色的孩子，不需要调整</span></span><br><span class="line">    <span class="comment">//没有判断是否发生双红冲突</span></span><br><span class="line">    <span class="comment">//不冲突的话，更改颜色不影响结果，如果发生冲突，更改颜色，解决冲突，root必定为黑色，因为孩子为红色</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; root-&gt;rchild-&gt;color == <span class="number">0</span>) <span class="keyword">goto</span> insert_end;</span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">       <span class="comment">// root-&gt;color = 0;</span></span><br><span class="line">       <span class="comment">// root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = 1;</span></span><br><span class="line">        <span class="comment">//return root;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;lchild)) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;rchild)) flag = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;rchild-&gt;color == <span class="number">0</span>)<span class="comment">//LR,需要小左旋，大右旋</span></span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">        <span class="comment">//root-&gt;color = 0;//红色上浮，红色下沉也可</span></span><br><span class="line">       <span class="comment">// root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = 1;</span></span><br><span class="line">       <span class="comment">// return root;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);</span><br><span class="line">        <span class="comment">//root-&gt;color = 0;</span></span><br><span class="line">       <span class="comment">// root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">insert_end:</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;<span class="comment">//红色上浮，红色下沉也可</span></span><br><span class="line">    root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *__insert(Node *root, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(value);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) root-&gt;lchild = __insert(root-&gt;lchild, value);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = __insert(root-&gt;rchild, value);</span><br><span class="line">    <span class="keyword">return</span> insert_maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    root = __insert(root, data);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d| %d, %d, %d)\n&quot;</span>,</span><br><span class="line">        root-&gt;color, root-&gt;data,</span><br><span class="line">        root-&gt;lchild-&gt;data,</span><br><span class="line">        root-&gt;rchild-&gt;data</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">0</span>| <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">1</span>| <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">1</span>| <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">0</span>| <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 -60</span><br><span class="line">2 -95</span><br><span class="line">1 47</span><br><span class="line">1 -65</span><br><span class="line">1 18</span><br><span class="line">3 -53</span><br></pre></td></tr></table></figure>




<h2 id="5-删除调整的触发"><a href="#5-删除调整的触发" class="headerlink" title="5.删除调整的触发"></a>5.删除调整的触发</h2><ol>
<li>删除红色节点，不会对红黑树的平衡产生影响</li>
<li>度为1的黑色节点，唯一子孩子一定是红色，因为到叶子结点的黑色节点相同，如果为黑色则会违背平衡条件</li>
<li>所以删除度为1的黑色节点，不会产生删除调整，</li>
<li>删除度为0的黑色节点，会产生一个双重黑的 NIL 节点(color=2)</li>
<li>所以删除调整的关键，就是为了干掉双重黑</li>
</ol>
<p>==&gt;双重黑结点触发删除调整</p>
<h2 id="7-删除调整分类"><a href="#7-删除调整分类" class="headerlink" title="7.删除调整分类"></a>7.删除调整分类</h2><blockquote>
<p>1.双重黑节点的兄弟节点是黑色，兄弟节点下面的两个子节点也是黑色，</p>
</blockquote>
<p>调整方法:父节点增加一重黑色，双重黑与兄弟节点，分别减少一重黑色。</p>
<p>情况一</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%884.25.58.png" alt="图一" style="zoom: 85%;" />

<blockquote>
<p>2.双黑结点的兄弟节点是黑色，并且，兄弟节点中有==红色子节点==,有四种情况</p>
</blockquote>
<p> 1).R（兄弟）==R==（右子节点），==左==旋，新根结点改成原根结点的颜色，将新根的两个子节点，改成黑色,双重黑改成一重黑</p>
<p>情况三（双黑左旋之后被干掉）兄弟的右子树结点为红色，左子树结点不一定</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%884.29.06.png" alt="截屏2020-12-24 下午4.29.06" style="zoom:90%;" />

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%885.04.12.png" alt="截屏2020-12-24 下午5.04.12" style="zoom:50%;" />





<p>2).R（兄弟）==L==（左子节点）(红色)，先小==右==旋，对调新根与原根的颜色，转成上一种情况(RL→RR)</p>
<p>(情况二)RL，兄弟右子树一定为黑色，左子树为红色</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8811.02.27.png" alt="截屏2020-12-24 下午11.02.27" style="zoom:80%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8810.06.55.png" alt="截屏2020-12-24 下午10.06.55" style="zoom:50%;" />

<p>3).LL 同理 RR</p>
<p>4).LR 同理 RL</p>
<blockquote>
<p>4.兄弟节点是红色，通过旋转，转变成兄弟节点是黑色的情况</p>
</blockquote>
<p>  左旋，原根节点改红，新根节点改黑，双黑-1</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8810.22.04.png" alt="截屏2020-12-24 下午10.22.04" style="zoom:50%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8810.25.28.png" alt="截屏2020-12-24 下午10.25.28" style="zoom:50%;" />







<h2 id="6-删除代码实现"><a href="#6-删除代码实现" class="headerlink" title="6.删除代码实现"></a>6.删除代码实现</h2><p>进行 LR/RL 类型判断的时候，不能判断 LL 子树是否为黑色，LL 子树有可能是 NIL 节点，在某些特殊情况下，读到的颜色可能是双重黑，取而代之的判断方法就是【LL 子树不是红色】。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> color;<span class="comment">//0 red, 1 black 2double black</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL-&gt;data = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;color = <span class="number">1</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;</span><br><span class="line">    Node *root = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    root-&gt;data = _data;</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;</span><br><span class="line">    root-&gt;lchild = root-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">has_red_child</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//判断根节点是否有红色的孩子结点</span></span><br><span class="line">    <span class="keyword">return</span> root-&gt;lchild-&gt;color == <span class="number">0</span> || root-&gt;rchild-&gt;color == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!has_red_child(root)) <span class="keyword">return</span> root;<span class="comment">//没有红色的孩子，不需要调整</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; root-&gt;rchild-&gt;color == <span class="number">0</span>) <span class="keyword">goto</span> insert_end;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;lchild)) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;rchild)) flag = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;rchild-&gt;color == <span class="number">0</span>)<span class="comment">//LR,需要小左旋，大右旋</span></span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">insert_end:</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;<span class="comment">//红色上浮，红色下沉也可，这里选择红色上浮</span></span><br><span class="line">    root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *__insert(Node *root, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(value);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) root-&gt;lchild = __insert(root-&gt;lchild, value);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = __insert(root-&gt;rchild, value);</span><br><span class="line">    <span class="keyword">return</span> insert_maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    root = __insert(root, data);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild != NIL) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color != <span class="number">2</span> &amp;&amp; root-&gt;rchild-&gt;color != <span class="number">2</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (has_red_child(root)) &#123;<span class="comment">//兄弟节点是红色，通过旋转，转变成兄弟节点是黑色的情况</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//1：右旋，2：左旋</span></span><br><span class="line">        root-&gt;color = <span class="number">0</span>;<span class="comment">//原根节点改红</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;<span class="comment">//左孩子为红色，右孩子为双黑结点，减掉一重黑色，右旋</span></span><br><span class="line">            root-&gt;rchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">            root = right_rotate(root);</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//右孩子为红色,左孩子为双黑结点，双黑结点减掉一重黑色，左旋</span></span><br><span class="line">            root-&gt;lchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">            root = left_rotate(root);</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;color = <span class="number">1</span>;<span class="comment">//新根节点改黑</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) root-&gt;rchild = erase_maintain(root-&gt;rchild);<span class="comment">//若发生右旋，已经转变成兄弟结点为黑色的情况，递归检查右边是否平衡,</span></span><br><span class="line">        <span class="keyword">else</span> root-&gt;lchild = erase_maintain(root-&gt;lchild);<span class="comment">//检查左边是否平衡</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((root-&gt;lchild-&gt;color == <span class="number">2</span> &amp;&amp; !has_red_child(root-&gt;rchild)) ||</span><br><span class="line">        (root-&gt;rchild-&gt;color == <span class="number">2</span> &amp;&amp; !has_red_child(root-&gt;lchild)) ) &#123;</span><br><span class="line">        <span class="comment">//双重黑节点的兄弟节点是黑色，兄弟节点下面的两个子节点也是黑色(即无红色)</span></span><br><span class="line">            root-&gt;lchild-&gt;color -= <span class="number">1</span>;<span class="comment">//父节点增加一重黑色，双重黑与兄弟节点，分别减少一重黑色</span></span><br><span class="line">            root-&gt;rchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">            root-&gt;color += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双黑结点的兄弟节点是黑色，并且，兄弟节点中有红色子节点</span></span><br><span class="line">    <span class="comment">//R（兄弟）R（右子节点），左旋，新根结点改成原根结点的颜色，将新根的两个子节点，改成黑色，双重黑减1</span></span><br><span class="line">    <span class="comment">//R（兄弟）L（左子节点）(红色)，先小右旋，对调新根与原根的颜色，转成RR(RL→RR)</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">2</span>) &#123;<span class="comment">//左兄弟为双黑结点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;rchild-&gt;color != <span class="number">0</span>) &#123;<span class="comment">//---- != root-&gt;rchild-&gt;rchild-&gt;color == 1(NIL)</span></span><br><span class="line">            <span class="comment">//------------不是红色</span></span><br><span class="line">            root-&gt;rchild-&gt;color = <span class="number">0</span>;</span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">            root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);<span class="comment">//大左旋</span></span><br><span class="line">        root-&gt;color = root-&gt;lchild-&gt;color;<span class="comment">//新根结点改成原根结点的颜色</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//右兄弟结点为双黑结点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;lchild-&gt;color != <span class="number">0</span>) &#123;</span><br><span class="line">            root-&gt;lchild-&gt;color = <span class="number">0</span>;</span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">            root-&gt;lchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">            root-&gt;lchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        root = right_rotate(root);<span class="comment">//大右旋</span></span><br><span class="line">        root-&gt;color = root-&gt;rchild-&gt;color;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *__erase(Node *root, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> NIL;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) root-&gt;lchild = __erase(root-&gt;lchild, value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) root-&gt;rchild = __erase(root-&gt;rchild, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild != NIL ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            temp-&gt;color += root-&gt;color;</span><br><span class="line">            <span class="comment">//若根节点为红色，值不变，若为黑色，子孩子一定为红色，</span></span><br><span class="line">            <span class="comment">//temp == NIL，root度为0，则，color=2,产生双黑结点</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = __erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> erase_maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    root = __erase(root, value);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d| %d, %d, %d)\n&quot;</span>,</span><br><span class="line">        root-&gt;color, root-&gt;data,</span><br><span class="line">        root-&gt;lchild-&gt;data,</span><br><span class="line">        root-&gt;rchild-&gt;data</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: output(root);</span><br><span class="line">        &#125;</span><br><span class="line">        output(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">0</span>| <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">1</span>| <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>| <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">0</span>| <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">------------</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">(1| 1, 0, 0)</span><br><span class="line">------------</span><br><span class="line">1 2</span><br><span class="line">(1| 1, 0, 2)</span><br><span class="line">(0| 2, 0, 0)</span><br><span class="line">------------</span><br><span class="line">1 3</span><br><span class="line">(1| 2, 1, 3)</span><br><span class="line">(1| 1, 0, 0)</span><br><span class="line">(1| 3, 0, 0)</span><br><span class="line">------------</span><br><span class="line">1 -5</span><br><span class="line">(1| 2, 1, 3)</span><br><span class="line">(1| 1, -5, 0)</span><br><span class="line">(0| -5, 0, 0)</span><br><span class="line">(1| 3, 0, 0)</span><br><span class="line">------------</span><br><span class="line">2 3</span><br><span class="line">(1| 1, -5, 2)</span><br><span class="line">(1| -5, 0, 0)</span><br><span class="line">(1| 2, 0, 0)</span><br><span class="line">------------</span><br></pre></td></tr></table></figure>


<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-25%20%E4%B8%8A%E5%8D%881.47.12.png" alt="截屏2020-12-25 上午1.47.12" style="zoom:50%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-25%20%E4%B8%8A%E5%8D%881.49.37.png" alt="截屏2020-12-25 上午1.49.37" style="zoom:50%;" />





<h2 id="7-红黑树代码实现"><a href="#7-红黑树代码实现" class="headerlink" title="7.红黑树代码实现"></a>7.红黑树代码实现</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%884.53.06.png" alt="截屏2021-01-05 下午4.53.06"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> color;<span class="comment">//0 red, 1 black 2double black</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;<span class="comment">//空节点</span></span><br><span class="line">    NIL-&gt;data = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;color = <span class="number">1</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;<span class="comment">//初始化一个新节点</span></span><br><span class="line">    Node *root = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    root-&gt;data = data;</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;</span><br><span class="line">    root-&gt;lchild = root-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">has_red_child</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//判断根节点的孩子结点是否有红色</span></span><br><span class="line">    <span class="keyword">return</span> root-&gt;lchild-&gt;color == <span class="number">0</span> || root-&gt;rchild-&gt;color == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左旋，旧根节点的右孩子变成根节点，旧根节点的右孩子变成新根节点的左孩子，新根节点左孩子变成旧根节点</span></span><br><span class="line">    Node *temp = root-&gt;rchild;<span class="comment">//新根节点</span></span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;<span class="comment">//旧根节点的右孩子变成新根节点的左孩子</span></span><br><span class="line">    temp-&gt;lchild = root;<span class="comment">//新根节点左孩子是旧根节点</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//右旋，旧根节点左孩子变成新根节点，旧根节点的左孩子变成新根节点的右孩子，新根节点的右孩子变成旧根节点</span></span><br><span class="line">    Node *temp = root-&gt;lchild;<span class="comment">//新根节点为旧根节点的左孩子</span></span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;<span class="comment">//旧根节点的左孩子变成新根节点的右孩子</span></span><br><span class="line">    temp-&gt;rchild = root;<span class="comment">//新根节点的右孩子变成旧根节点</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert_maintain</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> (!has_red_child(root)) <span class="keyword">return</span> root;<span class="comment">//没有红色的孩子，不需要调整</span></span><br><span class="line">    <span class="comment">//没有判断是否发生双红冲突</span></span><br><span class="line">    <span class="comment">//不冲突的话，更改颜色不影响结果，如果发生冲突，更改颜色，解决冲突，root必定为黑色，因为孩子为红色</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//分为两种情况 1.根节点的孩子中都是红色结点，2.根节点的孩子中有一个是红色</span></span><br><span class="line">    <span class="comment">// 1.根节点的孩子中都是红色结点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; root-&gt;rchild-&gt;color == <span class="number">0</span> &amp;&amp; </span><br><span class="line">    (has_red_child(root-&gt;lchild) || has_red_child(root-&gt;rchild))) <span class="keyword">goto</span> insert_end;</span><br><span class="line">    <span class="comment">// 2.根节点的孩子中有一个是红色,使用flag标记两种情况</span></span><br><span class="line">    <span class="comment">// 2.1 根节点的左孩子是红色，且左孩子的子树中有红色结点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;lchild)) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 2.2 根结点的右孩子是红色，且右孩子的子树中有红色结点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;rchild)) flag = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="comment">// 2.1 根节点的左孩子是红色，且左孩子的子树中有红色结点</span></span><br><span class="line">        <span class="comment">// 2.1.1 根节点的左孩子的右孩子为红色，为LR型，需要小左旋大右旋，</span></span><br><span class="line">        <span class="comment">// 2.1.2 根节点的左孩子的左孩子为红色，为LL型，需要大右旋，</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;rchild-&gt;color == <span class="number">0</span>)<span class="comment">//LR,需要小左旋，大右旋</span></span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.2 根结点的右孩子是红色，且右孩子的子树中有红色结点</span></span><br><span class="line">        <span class="comment">// 2.2.1 根节点的右孩子的左孩子为红色，为RL型，需要小右旋大左旋，</span></span><br><span class="line">        <span class="comment">// 2.2.2 根节点的左孩子的左孩子为红色，为RR型，需要大右旋，</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;<span class="comment">//RL,需要小右旋，大左旋</span></span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">insert_end:</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;<span class="comment">//这里选择红色上浮，其实红色上浮，红色下沉均可，</span></span><br><span class="line">    root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node *__insert(Node *root, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(value);<span class="comment">//根节点为空或者找到插入位置，插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value) <span class="keyword">return</span> root;<span class="comment">//新插入的结点已经存在，不需要操作</span></span><br><span class="line">    <span class="comment">//在左子树中插入</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) root-&gt;lchild = __insert(root-&gt;lchild, value);</span><br><span class="line">    <span class="comment">//在右子树中插入</span></span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = __insert(root-&gt;rchild, value);</span><br><span class="line">    <span class="comment">//插入完之后进行平衡调整，然后 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> insert_maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//插入</span></span><br><span class="line">    root = __insert(root, value);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild != NIL) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root-&gt;rchild-&gt;color != <span class="number">2</span> &amp;&amp; root-&gt;lchild-&gt;color !=  <span class="number">2</span>) <span class="keyword">return</span> root;</span><br><span class="line">     <span class="keyword">if</span> (!has_red_child(root)) &#123;<span class="comment">//1.双黑兄弟无红色</span></span><br><span class="line">         <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">2</span>) &#123;<span class="comment">//1.2左双黑结点</span></span><br><span class="line">             <span class="keyword">if</span> (!has_red_child(root-&gt;rchild)) &#123;<span class="comment">//1.2.1双黑结点在左，且右兄弟子结点无红色</span></span><br><span class="line">                 <span class="comment">//父结点增加1重黑，双重黑结点与兄弟结点减少1重黑</span></span><br><span class="line">                 root-&gt;color += <span class="number">1</span>;</span><br><span class="line">                 root-&gt;lchild-&gt;color -=<span class="number">1</span>;</span><br><span class="line">                 root-&gt;rchild-&gt;color -=<span class="number">1</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;<span class="comment">//1.2.2双黑结点在左，且右兄弟有红色子结点，分为RL,RR</span></span><br><span class="line">                 root-&gt;lchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">if</span> (root-&gt;rchild-&gt;rchild-&gt;color != <span class="number">0</span>) &#123;<span class="comment">// 1.2.2.3右兄弟结点，其右孩子不为红色,左孩子为红色，RL</span></span><br><span class="line">                     <span class="comment">//小右旋，原兄弟结点改成红色，新兄弟结点改成黑色，转变成RR型</span></span><br><span class="line">                     <span class="comment">//root-&gt;rchild-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color;//=1改黑**</span></span><br><span class="line">                     root-&gt;rchild-&gt;color = <span class="number">0</span>;<span class="comment">//改红</span></span><br><span class="line">                     root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">                     root-&gt;rchild-&gt;color = <span class="number">1</span>;<span class="comment">//改黑**</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//大左旋，新根结点等于原根结点 [双黑结点的父结点] 的颜色，两个新的子结点改为黑色，双黑结点减少1重黑</span></span><br><span class="line">                 root-&gt;rchild-&gt;color = root-&gt;color;</span><br><span class="line">                 root = left_rotate(root);</span><br><span class="line">                 root-&gt;rchild-&gt;color = root-&gt;lchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;rchild-&gt;color == <span class="number">2</span>)&#123;<span class="comment">//1.3右双黑结点</span></span><br><span class="line">             <span class="keyword">if</span> (!has_red_child(root-&gt;lchild)) &#123;<span class="comment">//1.3.1双黑结点在右，且左兄弟子结点无红色,</span></span><br><span class="line">                 <span class="comment">//父结点增加1重黑，双重黑结点与兄弟结点减少1重黑</span></span><br><span class="line">                 root-&gt;color += <span class="number">1</span>;</span><br><span class="line">                 root-&gt;lchild-&gt;color -=<span class="number">1</span>;</span><br><span class="line">                 root-&gt;rchild-&gt;color -=<span class="number">1</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;<span class="comment">//1.3.2双黑结点在右，且左兄弟有红色子结点，分为LR,LL</span></span><br><span class="line">                 root-&gt;rchild-&gt;color = <span class="number">1</span>;<span class="comment">//双重黑减一重黑</span></span><br><span class="line">                 <span class="keyword">if</span> (root-&gt;lchild-&gt;lchild-&gt;color != <span class="number">0</span>) &#123;<span class="comment">// 1.3.2.3左兄弟结点，其右孩子不为红色,即左孩子为红色,LL</span></span><br><span class="line">                     <span class="comment">//小左旋，原兄弟结点改成红色，新兄弟结点改成黑色，转变成LL型</span></span><br><span class="line">                     <span class="comment">//root-&gt;lchild-&gt;rchild-&gt;color = root-&gt;lchild-&gt;color;//=1</span></span><br><span class="line">                     root-&gt;lchild-&gt;color = <span class="number">0</span>;<span class="comment">//改红</span></span><br><span class="line">                     root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">                     root-&gt;lchild-&gt;color = <span class="number">1</span>;<span class="comment">//改黑</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//大右旋，新根结点等于原根结点 [双黑结点的父结点] 的颜色，两个新的子结点改为黑色，双黑结点减少1重黑</span></span><br><span class="line">                 root-&gt;lchild-&gt;color = root-&gt;color;</span><br><span class="line">                 root = right_rotate(root);</span><br><span class="line">                 root-&gt;rchild-&gt;color = root-&gt;lchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//2.双黑兄弟结点有红色,抓着双黑结点的父结点，向双黑结点旋转，原根结点改为红色，新根结点改为黑色</span></span><br><span class="line">         <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;<span class="comment">//2.2右双黑,左为红,向右旋转,原根结点改为红色，新根结点改为黑色</span></span><br><span class="line">            <span class="comment">//root-&gt;lchild-&gt;color = root-&gt;color;</span></span><br><span class="line">            root-&gt;color = <span class="number">0</span>;</span><br><span class="line">            root = right_rotate(root);</span><br><span class="line">            root-&gt;color = <span class="number">1</span>;</span><br><span class="line">            root-&gt;rchild = erase_maintain(root-&gt;rchild);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;<span class="comment">//2.3左双黑,右为红,向左旋转,原根结点改为红色，新根结点改为黑色</span></span><br><span class="line">            <span class="comment">//root-&gt;rchild-&gt;color = root-&gt;color;</span></span><br><span class="line">            root-&gt;color = <span class="number">0</span>;</span><br><span class="line">            root = left_rotate(root);</span><br><span class="line">            root-&gt;color = <span class="number">1</span>;</span><br><span class="line">            root-&gt;lchild = erase_maintain(root-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *__erase(Node *root, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="comment">//删除有两种情况，删除度为2，和删除度为0和1</span></span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> NIL;<span class="comment">//没有要删除的值</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) root-&gt;lchild = __erase(root-&gt;lchild, value);<span class="comment">// 要删除的值在左子树中</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) root-&gt;rchild = __erase(root-&gt;rchild, value);<span class="comment">// 要删除的值在右子树中</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 找到要删除的值，有4种情况</span></span><br><span class="line">        <span class="comment">// 1.要删除的结点的孩子结点有空节点，即删除度为1或者度为0的结点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild != NIL ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            temp-&gt;color += root-&gt;color;</span><br><span class="line">            <span class="comment">// 1.1删除度为1的结点，分两种情况</span></span><br><span class="line">            <span class="comment">// 1.1.1若删除的根节点为红色，不会对红黑树的平衡产生影响，</span></span><br><span class="line">            <span class="comment">// 1.1.2若删除的根节点为黑色，他的子孩子一定为红色，如果为黑色，树不会平衡；删除根节点为黑色，temp-&gt;color = 2;产生双重黑结点</span></span><br><span class="line">            <span class="comment">// 1.2删除度为0的结点，分两种情况</span></span><br><span class="line">            <span class="comment">// 1.2.1删除度为0的红色结点，不会产生影响</span></span><br><span class="line">            <span class="comment">// 1.2.2删除度为0的黑色结点，temp = NIL,color=2,产生双黑结点</span></span><br><span class="line">            <span class="built_in">free</span>(root);<span class="comment">//释放要删除的结点</span></span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        <span class="comment">// 2.删除度为2的结点，转换成度为1或0的结点，转换的方法是和他的前驱结点交换 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;lchild = __erase(root-&gt;lchild, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root = erase_maintain(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//删除结点</span></span><br><span class="line">    root = __erase(root, value);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;<span class="comment">//根节点为黑色</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,</span><br><span class="line">        root-&gt;data, </span><br><span class="line">        root-&gt;color,</span><br><span class="line">        root-&gt;lchild-&gt;data,</span><br><span class="line">        root-&gt;rchild-&gt;data</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: output(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//output(root);</span></span><br><span class="line">        <span class="comment">//printf(&quot;------------\n&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


















<h1 id="5-哈夫曼树"><a href="#5-哈夫曼树" class="headerlink" title="5.哈夫曼树"></a>5.哈夫曼树</h1><h2 id="1-编码"><a href="#1-编码" class="headerlink" title="1.编码"></a>1.编码</h2><h3 id="什么是编码"><a href="#什么是编码" class="headerlink" title="什么是编码"></a>什么是编码</h3><p>‘a’ = 97 = $(0110\ 0001)_2$</p>
<p>‘0’ = 48 = $(0011\ 0000)_2$</p>
<p>注意：任何信息，在计算机中，都是二进制存储的</p>
<p>信息：”aa00” = $01100001、01100001、00110000、00110000$</p>
<p>一台计算机   传输到  另外一台计算机，传输 32 个比特位</p>
<p>假设：计算机的网络是 32bit/s。所以用时：1 s</p>
<p>特定场静：只有 a,b,0,1 四种字符需要传输</p>
<p>海贼班编码：a:00, b: 01, 0: 10, 1: 11</p>
<p>“aa00” = 00001010</p>
<p>在带宽不变的情况下，当前只需要传输 0.25s</p>
<h3 id="定长与变长编码"><a href="#定长与变长编码" class="headerlink" title="定长与变长编码"></a>定长与变长编码</h3><ol start="2">
<li>Ascii编码和特定场景下的编码，都属于定长编码</li>
<li>对于每一个字符，编码长度相同，这就是定长编码</li>
<li>UTF-8编码是变长编码，UTF-16是定长编码</li>
<li>对于每一个字符，编码长度不同，这就是变长编码</li>
<li>将定长编码，看成是变长编码的特例</li>
<li>变长编码，一定不差于定长编码</li>
</ol>
<h3 id="变长编码应用场景"><a href="#变长编码应用场景" class="headerlink" title="变长编码应用场景"></a>变长编码应用场景</h3><p>特定场静：</p>
<ol>
<li>只有四种字符 : ab01</li>
<li>a: 0.8, b: 0.05, 0: 0.1, 1: 0.05</li>
</ol>
<p>平均编码长度：</p>
<p>$l_i$：第 i 种字符，编码长度</p>
<p>$p_i$：第 i 种字符，出现概率</p>
<p>$avg(l) = \sum{l_i}\times{p_i}$</p>
<p>假设，平均编码长度：1.16，估算传输100个字符，需要传输116个比特位</p>
<p>海贼班编码的平均编码长度：$avg(l) = 2\times\sum{p_i}=2$</p>
<p>平均编码长度就是编码的定长</p>
<p>新·海贼班编码：</p>
<p>a: 1</p>
<p>b: 01</p>
<p>0: 000</p>
<p>1: 001</p>
<p>平均编码长度：$1<em>0.8+2</em>0.05+3<em>0.1+3</em>0.05=1.35$</p>
<p>100个字符，传输135个比特位</p>
<p>==&gt;将定长编码看成变长编码的特例，变长编码不差于定长编码</p>
<h2 id="2-哈夫曼编码"><a href="#2-哈夫曼编码" class="headerlink" title="2.哈夫曼编码"></a>2.哈夫曼编码</h2><ol>
<li>首先，统计得到每一种字符的概率</li>
<li>将 n 个字符，建立成一棵哈弗曼树</li>
<li>每一个字符，都落在叶子结点上</li>
<li>按照左0，右1的形式，将编码读取出来</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8A%E5%8D%8810.14.23.png" alt="截屏2020-12-29 上午10.14.23"></p>
<p>得到新编码：</p>
<p>a: 0 | b: 110 | 0: 10 | 1: 111</p>
<p>平均编码长度：$1<em>0.8+3</em>0.05+2<em>0.1+3</em>0.05=1.3$</p>
<p>结论：哈弗曼编码，是最优的变长编码</p>
<h2 id="4-公式证明"><a href="#4-公式证明" class="headerlink" title="4.公式证明"></a>4.公式证明</h2><ol>
<li>首先表示平均编码长度，求解公式最优解</li>
<li>最终，和熵与交叉熵之间的关系</li>
</ol>
<p> 证明$\sum{l_i}\times{p_i}$最小，令$l = -l’$，即证明$-\sum{l_i}\times{p_i}$最小</p>
<p>约束$\sum{l_i}\times{p_i} &lt;=  1$</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%8812.28.35.png" alt="截屏2020-12-29 下午12.28.35" style="zoom: 33%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%8812.45.54.png" alt="截屏2020-12-29 下午12.45.54" style="zoom: 33%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%881.02.11.png" alt="截屏2020-12-29 下午1.02.11" style="zoom:33%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-30%20%E4%B8%8A%E5%8D%889.35.56.png" alt="截屏2020-12-30 上午9.35.56" style="zoom:33%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-30%20%E4%B8%8A%E5%8D%889.51.45.png" alt="截屏2020-12-30 上午9.51.45" style="zoom:33%;" />





<h2 id="5-代码演示"><a href="#5-代码演示" class="headerlink" title="5.代码演示"></a>5.代码演示</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123; \</span></span><br><span class="line">    __typeof(a) __c = a; \</span><br><span class="line">    a = b, b = __c; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> p;<span class="comment">//概率值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">char</span> _ch, <span class="keyword">double</span> _per)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;ch = _ch;</span><br><span class="line">    p-&gt;p = _per;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">CombinNode</span><span class="params">(Node *a, Node *b)</span> </span>&#123;<span class="comment">//合并成新结点</span></span><br><span class="line">    Node *p = getNewNode(<span class="number">0</span>, a-&gt;p + b-&gt;p);</span><br><span class="line">    p-&gt;lchild = a;</span><br><span class="line">    p-&gt;rchild = b;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pick_min</span><span class="params">(Node **arr, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//找到概率最小的结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[n]-&gt;p &gt; arr[j]-&gt;p) &#123;</span><br><span class="line">            swap(arr[n], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getHaffmanTree</span><span class="params">(Node **arr, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//生成n个结点的哈夫曼树，n个结点循环n-1次形成树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pick_min(arr, n - i);<span class="comment">//最小的放在最后面，次之放倒数第二</span></span><br><span class="line">        pick_min(arr, n - i - <span class="number">1</span>);</span><br><span class="line">        arr[n - i - <span class="number">1</span>] = CombinNode(arr[n - i], arr[n - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __output_encode(Node *root, <span class="keyword">char</span> *str, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    str[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) &#123;<span class="comment">//根节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %s\n&quot;</span>, root-&gt;ch, str);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    str[k] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    __output_encode(root-&gt;lchild, str, k + <span class="number">1</span>);<span class="comment">//左0右1</span></span><br><span class="line">    str[k] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    __output_encode(root-&gt;rchild, str, k + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_encode</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    __output_encode(root, str, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Node **arr;<span class="comment">//数组</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//要输节点数量</span></span><br><span class="line">    arr = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">double</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%lf&quot;</span>, ch, &amp;p);<span class="comment">//输入节点</span></span><br><span class="line">        arr[i] = getNewNode(ch[<span class="number">0</span>], p);</span><br><span class="line">    &#125;</span><br><span class="line">    Node *root = getHaffmanTree(arr, n);<span class="comment">//获取哈夫曼树</span></span><br><span class="line">    output_encode(root);<span class="comment">//输出哈夫曼树</span></span><br><span class="line">    clear(root);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h1 id="6-单调栈和单调队列"><a href="#6-单调栈和单调队列" class="headerlink" title="6.单调栈和单调队列"></a>6.单调栈和单调队列</h1><h2 id="6-1课前热身"><a href="#6-1课前热身" class="headerlink" title="6.1课前热身"></a>6.1课前热身</h2><h3 id="6-1HZOJ-261-数据结构"><a href="#6-1HZOJ-261-数据结构" class="headerlink" title="6.1HZOJ-261-数据结构"></a>6.1HZOJ-261-数据结构</h3><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8B%E5%8D%889.40.35.png" alt="截屏2021-01-14 下午9.40.35"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8B%E5%8D%889.40.47.png" alt="截屏2021-01-14 下午9.40.47"></p>
<ol>
<li><p>关键就是新造一个数据结构，结构定义 + 结构操作</p>
</li>
<li><p>模拟光标的功能，左移动、右移动、插入、删除，用对顶栈模拟</p>
</li>
<li><p>实现对顶栈，用数组模拟、用链表模拟</p>
</li>
<li><p>题目中的 BUG：Query K 中，K 可能大于当前位置</p>
<hr>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewStruct</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NewStruct() &#123;</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//sum[0] = 0;</span></span><br><span class="line">        ans[<span class="number">0</span>] = INT64_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//插入元素</span></span><br><span class="line">        s1.push(x);<span class="comment">//在s1中插入</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> val = s1.top() + sum[s1.size() - <span class="number">1</span>];</span><br><span class="line">        sum[s1.size()] = val;<span class="comment">//前i项和</span></span><br><span class="line">        ans[s1.size()] = max(ans[s1.size() - <span class="number">1</span>], val);<span class="comment">//前i项和的最大值，在前i项和sum和前i-1项和中的最大值做比较</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.empty()) <span class="keyword">return</span> ;</span><br><span class="line">        s1.pop();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move_left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.empty()) <span class="keyword">return</span> ;</span><br><span class="line">        s2.push(s1.top());</span><br><span class="line">        del();</span><br><span class="line">        <span class="comment">//s1.pop();</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move_right</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.empty()) <span class="keyword">return</span> ;</span><br><span class="line">        insert(s2.top());</span><br><span class="line">        <span class="comment">//s1.push(s2.top());</span></span><br><span class="line">        s2.pop();</span><br><span class="line">        <span class="comment">//sum.pop_back(s2.top());</span></span><br><span class="line">        <span class="comment">//ans.push_back(s1.top() + sum[sum.size() - 1]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans[k];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s1, s2;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum[<span class="number">1005</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">1005</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;<span class="comment">//输入第一行为操作数 𝑁。</span></span><br><span class="line">    <span class="built_in">string</span> op;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    NewStruct s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">switch</span>(op[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="built_in">cin</span> &gt;&gt; val; s.insert(val); <span class="keyword">break</span>;<span class="comment">//在当前位置插入 𝑥 元素；</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: s.del(); <span class="keyword">break</span>;<span class="comment">// 删除当前位置的元素；</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: s.move_left(); <span class="keyword">break</span>;<span class="comment">//将当前位置左移一位，除非它已经是第一个元素；</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: s.move_right(); <span class="keyword">break</span>;<span class="comment">//将当前位置右移一位，除非它已经是最后一个元素</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="built_in">cin</span> &gt;&gt; val; <span class="built_in">cout</span> &lt;&lt; s.query(val) &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;<span class="comment">//𝑘  在当前位置之前，找到一个最大的 𝑆𝑖(1≤𝑖≤𝑘,𝑆𝑖=𝑎1+𝑎2+...+𝑎𝑖)</span></span><br><span class="line">        <span class="keyword">default</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-2HZOJ-263-火车进栈"><a href="#6-2HZOJ-263-火车进栈" class="headerlink" title="6.2HZOJ-263-火车进栈"></a>6.2HZOJ-263-火车进栈</h3><hr>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8A%E5%8D%8810.56.08.png" alt="截屏2021-01-15 上午10.55.49"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8A%E5%8D%8810.56.08.png" alt="截屏2021-01-15 上午10.56.08"></p>
<hr>
<ol>
<li><p>当前要进栈的最大数字是 x，序列中当前待出栈的数字是 y</p>
</li>
<li><p>$y &lt;= x$，说明 y 一定是栈顶元素</p>
</li>
<li><p>$y &gt; x$，将 $[x + 1, y]$ 入栈，此时栈顶元素一定是 y</p>
<p>a[i]=3421</p>
<p>要进栈的1，待出3</p>
<p>3&gt;1,123进栈，stack=123</p>
<p>4进栈：stack=123，待出栈3(y)，待进栈4(x)，4&gt;3==&gt;3是栈顶，3出栈，4进栈</p>
<p>stack=124,a[i]=3421</p>
<p>依次出栈</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">30</span>], <span class="built_in">stack</span>[<span class="number">30</span>], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_valid</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//要进栈元素</span></span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; a[i]) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span> || <span class="built_in">stack</span>[top] - a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        --top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">20</span>;;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_valid(a, n)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        --ans;</span><br><span class="line">    &#125; <span class="keyword">while</span>(ans &amp;&amp; next_permutation(a, a + n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-2-单调队列"><a href="#6-2-单调队列" class="headerlink" title="6.2.单调队列"></a>6.2.单调队列</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.11.28.png" alt="截屏2021-01-15 下午2.11.28"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.14.28.png" alt="截屏2021-01-15 下午2.14.28"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.16.34.png" alt="截屏2021-01-15 下午2.16.34"></p>
<ol>
<li>本质问题是：固定查询结尾的 RMQ 问题，例如 $RMQ(x, 7)$</li>
<li>问题性质：维护滑动窗口最值问题</li>
<li>入队：将队尾违反单调性的元素淘汰出局，再将当前元素入队</li>
<li>出队：如果队首元素超出了滑动窗口的范围，队首出队</li>
<li>队首元素：滑动窗口内的最值</li>
<li>均摊时间复杂度：$O(1)$</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.18.02.png" alt="截屏2021-01-15 下午2.18.02"></p>
<p>注：单调队列维护的区间最小值一定在队首</p>
<p>入队操作：</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.28.58.png" alt="截屏2021-01-15 下午2.28.58"></p>
<h2 id="6-3单调队列例题HZOJ-271-滑动窗口"><a href="#6-3单调队列例题HZOJ-271-滑动窗口" class="headerlink" title="6.3单调队列例题HZOJ-271-滑动窗口"></a>6.3单调队列例题HZOJ-271-滑动窗口</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.43.25.png" alt="截屏2021-01-15 下午2.43.25"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.43.34.png" alt="截屏2021-01-15 下午2.43.34"></p>
<p>单调队列的裸题,主要要学习代码实现</p>
<p><strong>思考：</strong>单调队列中是记录值还是记录下标的问题</p>
<p><strong>结论：</strong>==记录下标，因为有了下标可以索引到值，记录值则反向不可查==</p>
<h2 id="6-4单调队列及HZOJ271代码实现"><a href="#6-4单调队列及HZOJ271代码实现" class="headerlink" title="6.4单调队列及HZOJ271代码实现"></a>6.4单调队列及HZOJ271代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 300000</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">queue</span>[MAX_N + <span class="number">5</span>];<span class="comment">//维护数组的单调队列，存储数组下标</span></span><br><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;<span class="comment">//头指针，尾指针</span></span><br><span class="line"><span class="keyword">int</span> val[MAX_N + <span class="number">5</span>];<span class="comment">//数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;<span class="comment">//给出一个长度为 𝑁 的数组,一个长为 𝐾 的滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//滑动窗口最小值，用单调递增队列</span></span><br><span class="line">        <span class="keyword">while</span> ((tail - head) &amp;&amp; val[<span class="built_in">queue</span>[tail - <span class="number">1</span>]] &gt; val[i]) --tail;</span><br><span class="line">        <span class="comment">//队列中有元素，并且当前队尾元素的值&gt;要入队的元素，大于要入队的元素全部出队</span></span><br><span class="line">      <span class="comment">//维护单调队列的单调性</span></span><br><span class="line">        <span class="built_in">queue</span>[tail++] = i;<span class="comment">//存储下标</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[head] &lt;= i - k) head++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">            i &gt; k &amp;&amp; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; val[<span class="built_in">queue</span>[head]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    head = tail = <span class="number">0</span>;<span class="comment">//队列清空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//滑动窗口最大值，用单调递减队列</span></span><br><span class="line">        <span class="keyword">while</span> ((tail - head) &amp;&amp; val[<span class="built_in">queue</span>[tail - <span class="number">1</span>]] &lt; val[i]) --tail;</span><br><span class="line">        <span class="comment">//队列中有元素，并且当前队尾元素的值 &lt; 要入队的元素，小于要入队的元素全部出队</span></span><br><span class="line">        <span class="built_in">queue</span>[tail++] = i;<span class="comment">//存储下标</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[head] &lt;= i - k) head++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">            i &gt; k &amp;&amp; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; val[<span class="built_in">queue</span>[head]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="6-5单调栈"><a href="#6-5单调栈" class="headerlink" title="6.5单调栈"></a>6.5单调栈</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-151%20%E4%B8%8B%E5%8D%884.34.26.png" alt="截屏2021-01-151 下午4.34.26"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.34.59.png" alt="截屏2021-01-15 下午4.34.59"></p>
<ol>
<li>单调栈保留了单调队列的『入队』操作</li>
<li>单调栈依然是维护了一种单调性</li>
<li>问题性质：最近（大于/小于）关系</li>
<li>入栈之前，符合单调性的栈顶元素，就是我们要找的最近（大于/小于）关系</li>
<li>均摊时间复杂度：$O(1)$</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.30.37.png" alt="截屏2021-01-15 下午4.30.37"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.30.50.png" alt="截屏2021-01-15 下午4.30.50"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.31.08.png" alt="截屏2021-01-15 下午4.31.08"></p>
<h2 id="6-6单调栈例题HZOJ-264-最大矩形面积"><a href="#6-6单调栈例题HZOJ-264-最大矩形面积" class="headerlink" title="6.6单调栈例题HZOJ-264-最大矩形面积"></a>6.6单调栈例题HZOJ-264-最大矩形面积</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.56.33.png" alt="截屏2021-01-15 下午4.56.22"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.56.33.png" alt="截屏2021-01-15 下午4.56.33"></p>
<ol>
<li>分析最优解的性质，是解决问题的第一步</li>
<li>最大矩形的性质：一定是以其所在区域中最矮的木板为高度的</li>
<li>以每一块木板做为矩形高度，求能得到的最大矩形面积，最后在所有面积中，取一个最大值</li>
<li>需要求解：每一块木板最近的高度小于当前木板的位置，所以需要用单调栈</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.57.45.png" alt="截屏2021-01-15 下午4.57.18"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.57.45.png" alt="截屏2021-01-15 下午4.57.45"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">stack</span>[MAX_N + <span class="number">5</span>];<span class="comment">//单调栈，记录下标</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> h[MAX_N + <span class="number">5</span>];<span class="comment">//记录每一块木板的长度</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l[MAX_N + <span class="number">5</span>],r[MAX_N + <span class="number">5</span>];<span class="comment">//l</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; n;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="comment">//输入共一行，第一个数表示矩形的个数 𝑁。接下来 𝑁 个数表示矩形的大小。（1≤𝑁≤100000）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, h + i);</span><br><span class="line">        <span class="comment">//cin &gt;&gt; h[i];</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    h[<span class="number">0</span>] = h[n + <span class="number">1</span>] = <span class="number">-1</span>;<span class="comment">//最边上的两块木板,即边界木板</span></span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//求最近小于关系，单调递增栈</span></span><br><span class="line">    <span class="comment">//左边木板</span></span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="number">0</span>;<span class="comment">//0坐标先压栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; h[<span class="built_in">stack</span>[top]] &gt;= h[i]) --top;<span class="comment">//出栈</span></span><br><span class="line">        l[i] = <span class="built_in">stack</span>[top];</span><br><span class="line">      <span class="comment">//第i块木板左边离他最近的且高度小于他的木板编号</span></span><br><span class="line">        <span class="built_in">stack</span>[++top] = i;<span class="comment">//入栈</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右边木板</span></span><br><span class="line">    top = <span class="number">-1</span>;<span class="comment">//清空栈</span></span><br><span class="line">    <span class="comment">//求最近小于关系，单调递增栈</span></span><br><span class="line">    <span class="built_in">stack</span>[++top] = n + <span class="number">1</span>;<span class="comment">//最右边坐标先压栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; h[<span class="built_in">stack</span>[top]] &gt;= h[i]) --top;<span class="comment">//出栈</span></span><br><span class="line">        r[i] = <span class="built_in">stack</span>[top];</span><br><span class="line">      <span class="comment">//第i块木板右边离他最近的且高度小于他的木板编号</span></span><br><span class="line">        <span class="built_in">stack</span>[++top] = i;<span class="comment">//入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = max(ans, h[i] * (r[i] - l[i] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="7-单调队列和单调栈习题"><a href="#7-单调队列和单调栈习题" class="headerlink" title="7.单调队列和单调栈习题"></a>7.单调队列和单调栈习题</h1><h2 id="7-1HAIZEIOJ51矩形"><a href="#7-1HAIZEIOJ51矩形" class="headerlink" title="7.1HAIZEIOJ51矩形"></a>7.1HAIZEIOJ51矩形</h2><p> <img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8A%E5%8D%8810.43.49.png" alt="截屏2021-02-05 上午10.43.49"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%888.29.51.png" alt="截屏2021-01-15 下午8.29.51"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%889.46.36.png" alt="截屏2021-01-17 上午9.46.36"></p>
<ol>
<li>左上角坐标和右下角坐标可以唯一确定一个子矩形</li>
<li>确定一行，将问题转换成子问题，右下角坐标落在固定的一行上，求每个点能构成的合法子矩形数量</li>
<li>通过观察，将问题变成两部分子问题</li>
<li>$f(x)$ 代表以 X 做为右下角坐标所能构成的合法子矩形数量</li>
<li>首先找到左侧离 X 点最近的，小于 X 点的位置 i</li>
<li>$f(x) = h_x\times (x-i) + f(i)$</li>
<li>因为需要求解离 X 最近的小于 X 的位置，所以要用到单调栈</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD_NUM 100007</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAX_N + <span class="number">5</span>], top;</span><br><span class="line"><span class="keyword">int</span> c[MAX_N + <span class="number">5</span>][MAX_N + <span class="number">5</span>];<span class="comment">//c[i][j]从[i,j]向上数，有多少个连续的白色格子，即矩形高</span></span><br><span class="line"><span class="keyword">int</span> f[MAX_N + <span class="number">5</span>];<span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;<span class="comment">//第一行输入两个数字 𝑛,𝑚（2≤𝑛,𝑚≤1000），代表矩形的长和宽。</span></span><br><span class="line">    <span class="comment">//接下来 𝑛 行，每行 𝑚 个数字，0 代表黑色格子，1 代表白色格子。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c[i][j];</span><br><span class="line">            <span class="keyword">if</span> (c[i][j] == <span class="number">1</span>) c[i][j] += c[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//n行</span></span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">stack</span>[++top] = <span class="number">0</span>;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;<span class="comment">//每行m个数字</span></span><br><span class="line">            <span class="keyword">while</span>(top != <span class="number">-1</span> &amp;&amp; c[i][<span class="built_in">stack</span>[top]] &gt; c[i][j]) --top;<span class="comment">//出栈，找到第一个比c[i][j]矮的</span></span><br><span class="line">            f[j] = c[i][j] * (j - <span class="built_in">stack</span>[top]) + f[<span class="built_in">stack</span>[top]];<span class="comment">//子矩形个数=矩形高x宽(即f(i)右边的子矩形个数) + f(i)左边的子矩形个数</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;f[j]&quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; f[j] &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">stack</span>[++top] = j;</span><br><span class="line">            f[j] %= MOD_NUM;</span><br><span class="line">            ans += f[j];</span><br><span class="line">            ans %= MOD_NUM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="7-2HZOJ-52-古老的打字机"><a href="#7-2HZOJ-52-古老的打字机" class="headerlink" title="7.2HZOJ-52-古老的打字机"></a>7.2HZOJ-52-古老的打字机</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.00.47.png" alt="截屏2021-01-17 上午11.00.47"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.00.58.png" alt="截屏2021-01-17 上午11.00.58"></p>
<h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><p>$dp[i]$ 代表打印前 i 个字符的最小消耗值</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>定义： $s_i = \sum_{k=1}^{i}c_k$</p>
<p>$dp[i] = min(dp[j] + (s_i - s_j)^2 + M)$</p>
<p><strong>时间复杂度：</strong>$O(n^2)$</p>
<h3 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h3><p>假设从 j 转移要优于从 k 转移</p>
<p>$dp[j] + (s_i-s_j)^2+M &lt; dp[k] + (s_i-s_k)^2+M$</p>
<p>$dp[j] + s_j^2-2s_is_j &lt; dp[k] + s_k^2-2s_is_k$</p>
<p>$(dp[j] + s_j^2) -(dp[k] + s_k^2)&lt; 2s_i(s_j-s_k)$</p>
<p>$\frac{(dp[j] + s_j^2) -(dp[k] + s_k^2)}{s_j-s_k}&lt; 2s_i$</p>
<p>设：$f(i) = dp[i] + s_i^2$</p>
<p>$\frac{f(j) - f(k)}{s_j-s_k}&lt; 2s_i$ ，这东西就是一个斜率</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.08.58.png" alt="截屏2021-01-17 上午11.08.30"></p>
<p><img src="Desktop/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.09.10.png" alt="截屏2021-01-17 上午11.09.10"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.09.25.png" alt="截屏2021-01-17 上午11.09.25"></p>
<p>==&gt;$\frac{f(j) - f(k)}{s_j-s_k}&lt; 2s_i$ 意味着从j点转移比从k点转移更优秀</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.09.34.png" alt="截屏2021-01-17 上午11.09.34"></p>
<p>1.从k转移优于从j转移，从l转移优于从k转移，所以选择从l转移</p>
<p>2.。</p>
<p>3..</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.09.39.png" alt="截屏2021-01-17 上午11.09.39"></p>
<p>经过斜率优化以后，时间复杂度优化成了：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(a) ((a) * (a))</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  dp[MAX_N + <span class="number">5</span>], c[MAX_N + <span class="number">5</span>], s[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, M;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> q[MAX_N + <span class="number">5</span>], head, tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//求斜率</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (f[i] - f[j])/(s[i] - s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; M;</span><br><span class="line">    <span class="comment">//第一行输入两个数字，𝑛,𝑀(1≤𝑛≤106,1≤𝑀≤104) 代表文章中字符数量和打字机单次启动的固定磨损值。</span></span><br><span class="line">    <span class="comment">//第二行输入 𝑛 个数字，第 𝑖 个数字代表文章中第 𝑖 个字符的磨损值 𝐶𝑖(1≤𝐶𝑖≤100)。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c[i];<span class="comment">//cin &gt;&gt; s[i];</span></span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + c[i];<span class="comment">//s[i] = s[i - 1] + s[i];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//从i点转移到j点</span></span><br><span class="line">    dp[i] = dp[j] + S(s[i] - s[j]) + M;</span><br><span class="line">    f[i] = dp[i] + S(s[i]);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    q[tail++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tail - head &gt;= <span class="number">2</span> &amp;&amp; slope(q[head + <span class="number">1</span>], q[head]) &lt; <span class="number">2</span> * s[i]) ++head;<span class="comment">//</span></span><br><span class="line">        set_dp(i, q[head]);</span><br><span class="line">        <span class="keyword">while</span> (tail - head &gt;= <span class="number">2</span> &amp;&amp; slope(i, q[tail - <span class="number">1</span>]) &lt; slope(q[tail - <span class="number">2</span>], q[tail - <span class="number">1</span>])) --tail;</span><br><span class="line">        q[tail++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="三、HZOJ-372-双生序列1"><a href="#三、HZOJ-372-双生序列1" class="headerlink" title="三、HZOJ-372-双生序列1"></a>三、HZOJ-372-双生序列<strong>1</strong></h2><ol>
<li>因为两个序列的每个区间的 RMQ 值都相等，等价于两个序列的单调队列长得一样</li>
<li>将两个序列，依次插入到单调队列中，过程中判断单调队列是否一样，如果不一样，就退出</li>
<li>所以，需要使用单调队列</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX_N 500000</span><br><span class="line"></span><br><span class="line">class Queue &#123;</span><br><span class="line">public :</span><br><span class="line">    Queue(int *arr) : arr(arr) &#123;&#125;</span><br><span class="line">    void push(int i) &#123;</span><br><span class="line">        while (tail - head &amp;&amp; arr[q[tail - 1]] &gt; arr[i]) --tail;</span><br><span class="line">        q[tail++] &#x3D; i;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123; ++head; &#125;</span><br><span class="line">    int size() &#123; return tail - head; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int *arr;</span><br><span class="line">    int q[MAX_N + 5], head, tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int a[MAX_N + 5], b[MAX_N + 5];</span><br><span class="line">int n;</span><br><span class="line">Queue q1(a), q2(b);</span><br><span class="line"></span><br><span class="line">void read() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; b[i];</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    read();</span><br><span class="line">    int p;</span><br><span class="line">    for (p &#x3D; 0; p &lt; n; p++) &#123;</span><br><span class="line">        q1.push(p);</span><br><span class="line">        q2.push(p);</span><br><span class="line">        if (q1.size() !&#x3D; q2.size()) break;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="四、HZOJ-270-最大子序和1"><a href="#四、HZOJ-270-最大子序和1" class="headerlink" title="四、HZOJ-270-最大子序和1"></a>四、HZOJ-270-最大子序和1</h2><ol>
<li>有个限制条件：子序列的长度不超过 M</li>
<li>转换成前缀和数组上的问题，就是 $S_i - S_j$，其中$i-j &lt;= M$</li>
<li>在前缀和数组上，维护一个大小为 M 的滑动窗口中的最小值</li>
<li>所以，采用单调队列维护区间最小值</li>
</ol>
<p><img src="../guanghu/Library/Application%20Support/typora-user-images/image-20210110214945169.png" alt="image-20210110214945169"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX_N 300000</span><br><span class="line">int s[MAX_N + 5], n, m;</span><br><span class="line">int q[MAX_N + 5], head, tail;</span><br><span class="line"></span><br><span class="line">void read() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        s[i] +&#x3D; s[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int solve() &#123;</span><br><span class="line">    int ans &#x3D; INT_MIN;</span><br><span class="line">    head &#x3D; tail &#x3D; 0;</span><br><span class="line">    q[tail++] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        if (i - q[head] &gt; m) head++;</span><br><span class="line">        ans &#x3D; max(ans, s[i] - s[q[head]]);</span><br><span class="line">        while (tail - head &amp;&amp; s[q[tail - 1]] &gt; s[i]) --tail;</span><br><span class="line">        q[tail++] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    read();</span><br><span class="line">    cout &lt;&lt; solve() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="8-双数组字典树"><a href="#8-双数组字典树" class="headerlink" title="8.双数组字典树"></a>8.双数组字典树</h1><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%889.54.32.png" alt="截屏2021-01-27 上午9.54.32"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8810.16.09.png" alt="截屏2021-01-27 上午10.16.09"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8810.21.23.png" alt="截屏2021-01-27 上午10.21.23"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8810.25.11.png" alt="截屏2021-01-27 上午10.25.11"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8810.31.37.png" alt="截屏2021-01-27 上午10.31.37"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8810.53.14.png" alt="截屏2021-01-27 上午10.53.14"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8811.03.38.png" alt="截屏2021-01-27 上午11.03.38"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8811.07.01.png" alt="截屏2021-01-27 上午11.07.01"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8811.07.20.png" alt="截屏2021-01-27 上午11.07.20"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8811.12.14.png" alt="截屏2021-01-27 上午11.12.14"></p>
<h2 id="8-1传统字典树的缺点"><a href="#8-1传统字典树的缺点" class="headerlink" title="8.1传统字典树的缺点"></a>8.1传统字典树的缺点</h2><ol>
<li>完全二叉树，实际存储结构是连续数组空间，思维逻辑结构是树型的</li>
<li>完全二叉树，节省了大量的存储边的空间</li>
<li>优化思想：节省空间的方法叫做 记录式 改 计算式</li>
<li>$n$ 个节点的字典树，有效使用 $n-1$ 条边，浪费了 $(k-1)*n+1$ 条边的存储空间</li>
<li>参考完全二叉树的优点，提出了双数组字典树</li>
</ol>
<h2 id="8-2双数组字典树"><a href="#8-2双数组字典树" class="headerlink" title="8.2双数组字典树"></a>8.2双数组字典树</h2><ol>
<li><p>顾名思义，两个数组代表一棵字典树结构</p>
</li>
<li><p>base 数组信息与子节点编号相关，base + i 就是第 i 个子节点编号，base数组确定父亲的子孩子</p>
</li>
<li><p>check 数组信息负责做【亲子鉴定】，check 数组中用正负表示是否独立成词</p>
</li>
<li><p>不擅长进行动态插入操作，不适合插入操作</p>
</li>
<li><p>一次建立，终身使用</p>
</li>
<li><p>为了方便，基于普通字典树实现的双数组字典树</p>
</li>
<li><p>增加了 fail 数组，可以完成基于双数组字典树的 AC 自动机</p>
</li>
<li><p>超小规模实验结果：双数组字典树压缩效率是 25 倍</p>
</li>
<li><p>非常方便的输出到文件中，进行机器之间的共享</p>
</li>
<li><p>课后作业：利用真实数据集，测试双数组字典树的压缩效率</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="comment">//字典树</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>[<span class="title">BASE</span>];</span><span class="comment">//存储26个英文字符的字典树</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DANode</span> &#123;</span><span class="comment">//双数组字典树结构</span></span><br><span class="line">    <span class="keyword">int</span> base, check;<span class="comment">//</span></span><br><span class="line">&#125; DANode;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;next, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;next));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">code</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Node *root, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;<span class="comment">//在字典树中插入</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    Node *p = root;<span class="comment">//指向当前插入字符串的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = code(str[i]);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[ind] == <span class="literal">NULL</span>) &#123;<span class="comment">//相关子节点为空</span></span><br><span class="line">            cnt++;</span><br><span class="line">            p-&gt;next[ind] = getNewNode();</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;<span class="comment">//返回本次插入str时一共生成几个新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_base_value</span><span class="params">(Node *root, DANode *tree, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1</span>, flag;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        base += <span class="number">1</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE &amp;&amp; flag; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[base + i].check) flag = <span class="number">0</span>;<span class="comment">//如果存在check值，说明base值已经被占用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (flag == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transform_double_array_trie</span><span class="params">(Node *root, DANode *tree, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字典树转换成双数组字典树，双数组字典树存储在tree中，ind：根节点在双数组字典树中的下标</span></span><br><span class="line">    <span class="comment">//返回最大的下标值</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;flag) tree[ind].check = -tree[ind].check;<span class="comment">//当前节点独立成词</span></span><br><span class="line">    <span class="keyword">int</span> base = get_base_value(root, tree, ind);<span class="comment">//获得当前节点的base值</span></span><br><span class="line">    tree[ind].base = base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        tree[base + i].check = ind;<span class="comment">//子节点check存储父节点下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_ind = ind;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;<span class="comment">//依次确认每一个子节点是base值</span></span><br><span class="line">        <span class="keyword">int</span> temp = transform_double_array_trie(root-&gt;next[i], tree, base + i);</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; max_ind) max_ind = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_ind;<span class="comment">//返回最大下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_trie</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)  <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        clear_trie(root-&gt;next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, cnt =  <span class="number">1</span>;<span class="comment">//字典树中一共有cnt个节点</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//读入n个单词</span></span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);<span class="comment">//每次读入一个单词插入字典树中</span></span><br><span class="line">        cnt += insert(root, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将字典树转换成双数组字典树</span></span><br><span class="line">    <span class="keyword">size_t</span> tree_size = <span class="keyword">sizeof</span>(DANode) * (cnt * BASE);</span><br><span class="line">    DANode *tree = (DANode *)<span class="built_in">malloc</span>(tree_size);</span><br><span class="line">    <span class="built_in">memset</span>(tree, <span class="number">0</span>, tree_size);</span><br><span class="line">    <span class="keyword">int</span> max_ind = transform_double_array_trie(root, tree, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> s1 = cnt * <span class="keyword">sizeof</span>(Node);</span><br><span class="line">    <span class="keyword">size_t</span> s2 = max_ind * <span class="keyword">sizeof</span>(DANode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;trie(%lu Byte), double array trie(%lu, Byte)\n&quot;</span>, s1, s2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max_ind; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d | %d, %d)\t&quot;</span>, i, tree[i].base, tree[i].check);</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span> ) % <span class="number">5</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    clear_trie(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a.out &lt; 18.input17</span><br><span class="line">(0 | 0, 0)	(1 | 2, 0)	(2 | 2, 9)	(3 | 5, 19)	(4 | 6, 12)</span><br><span class="line">(5 | 17, 7)	(6 | 3, 28)	(7 | 4, 16)	(8 | 2, -22)	(9 | 2, 1)</span><br><span class="line">(10 | 3, 2)	(11 | 2, -6)	(12 | 4, 1)	(13 | 2, 3)	(14 | 6, 4)</span><br><span class="line">(15 | 2, -13)	(16 | 3, 14)	(17 | 2, -5)	(18 | 20, 27)	(19 | 2, 2)</span><br><span class="line">(20 | 4, 18)	(21 | 13, 20)	(22 | 2, 9)	(23 | 2, -21)	(24 | 0, 0)</span><br><span class="line">(25 | 0, 0)	(26 | 0, 0)	(27 | 3, 1)	(28 | 2, 10)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//18.input17</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">haizei</span><br><span class="line">kaikeba</span><br><span class="line">harbin</span><br><span class="line">hug</span><br><span class="line">zpark</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_LEVEL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_LEVEL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFO_LEVEL 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(level, frm, args...) &#123;\</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt;= MSG_LEVEL) &#123;\</span><br><span class="line">        <span class="built_in">printf</span>(frm, #<span class="meta">#args);\</span></span><br><span class="line">    &#125;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG(args...) LOG(DEBUG_LEVEL, args);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO(args...) LOG(INFO_LEVEL, args);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struct Node &#123;<span class="comment">//字典树</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    struct Node *next[BASE];<span class="comment">//存储26个英文字符的字典树</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struct DANode &#123;<span class="comment">//双数组字典树结构</span></span><br><span class="line">    <span class="keyword">int</span> base, check, fail;<span class="comment">//</span></span><br><span class="line">&#125; DANode;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">Node *getNewNode() &#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;next, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;next));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> code(<span class="keyword">char</span> c) &#123; <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> insert(Node *root, <span class="keyword">const</span> <span class="keyword">char</span> *str) &#123;<span class="comment">//在字典树中插入</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    Node *p = root;<span class="comment">//指向当前插入字符串的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = code(str[i]);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[ind] == <span class="literal">NULL</span>) &#123;<span class="comment">//相关子节点为空</span></span><br><span class="line">            cnt++;</span><br><span class="line">            p-&gt;next[ind] = getNewNode();</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;<span class="comment">//返回本次插入str时一共生成几个新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> get_base_value(Node *root, DANode *tree, <span class="keyword">int</span> ind) &#123;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1</span>, flag;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        base += <span class="number">1</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE &amp;&amp; flag; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[base + i].check) flag = <span class="number">0</span>;<span class="comment">//如果存在check值，说明base值已经被占用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (flag == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> transform_double_array_trie(Node *root, DANode *tree, <span class="keyword">int</span> ind) &#123;</span><br><span class="line">    <span class="comment">//字典树转换成双数组字典树，双数组字典树存储在tree中，ind：根节点在双数组字典树中的下标</span></span><br><span class="line">    <span class="comment">//返回最大的下标值</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;flag) tree[ind].check = -tree[ind].check;<span class="comment">//当前节点独立成词</span></span><br><span class="line">    <span class="keyword">int</span> base = get_base_value(root, tree, ind);<span class="comment">//获得当前节点的base值</span></span><br><span class="line">    tree[ind].base = base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        tree[base + i].check = ind;<span class="comment">//子节点check存储父节点下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_ind = ind;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;<span class="comment">//依次确认每一个子节点是base值</span></span><br><span class="line">        <span class="keyword">int</span> temp = transform_double_array_trie(root-&gt;next[i], tree, base + i);</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; max_ind) max_ind = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_ind;<span class="comment">//返回最大下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dump_double_array_tree(DANode *tree, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    LOG_INFO(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        LOG_INFO(<span class="string">&quot;%d %d \n&quot;</span>, tree[i].base, tree[i].check);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> clear_trie(Node *root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)  <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        clear_trie(root-&gt;next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">int</span> n, cnt =  <span class="number">1</span>;<span class="comment">//字典树中一共有cnt个节点</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//读入n个单词</span></span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);<span class="comment">//每次读入一个单词插入字典树中</span></span><br><span class="line">        cnt += insert(root, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将字典树转换成双数组字典树</span></span><br><span class="line">    <span class="keyword">size_t</span> tree_size = <span class="keyword">sizeof</span>(DANode) * (cnt * BASE);</span><br><span class="line">    DANode *tree = (DANode *)<span class="built_in">malloc</span>(tree_size);</span><br><span class="line">    <span class="built_in">memset</span>(tree, <span class="number">0</span>, tree_size);</span><br><span class="line">    <span class="keyword">int</span> max_ind = transform_double_array_trie(root, tree, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> s1 = cnt * <span class="keyword">sizeof</span>(Node);</span><br><span class="line">    <span class="keyword">size_t</span> s2 = max_ind * <span class="keyword">sizeof</span>(DANode);</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;trie(%lu Byte), double array trie(%lu, Byte)\n&quot;</span>, s1, s2);</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;rate : %.2lf\n&quot;</span>, <span class="number">1.0</span> * s2 / s1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max_ind; i++) &#123;</span><br><span class="line">        LOG_DEBUG(<span class="string">&quot;(%d | %d, %d)\t&quot;</span>, i, tree[i].base, tree[i].check);</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span> ) % <span class="number">5</span> == <span class="number">0</span>) LOG_DEBUG(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">//将字典树双数组输入到文件中去</span></span><br><span class="line">    dump_double_array_tree(tree, max_ind);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    clear_trie(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trie(5400 Byte), double array trie(336, Byte)</span><br><span class="line">rate : 0.06</span><br><span class="line">(0 | 0, 0)	(1 | 2, 0)	(2 | 2, 9)	(3 | 5, 19)	(4 | 6, 12)</span><br><span class="line">(5 | 17, 7)	(6 | 3, 28)	(7 | 4, 16)	(8 | 2, -22)	(9 | 2, 1)</span><br><span class="line">(10 | 3, 2)	(11 | 2, -6)	(12 | 4, 1)	(13 | 2, 3)	(14 | 6, 4)</span><br><span class="line">(15 | 2, -13)	(16 | 3, 14)	(17 | 2, -5)	(18 | 20, 27)	(19 | 2, 2)</span><br><span class="line">(20 | 4, 18)	(21 | 13, 20)	(22 | 2, 9)	(23 | 2, -21)	(24 | 0, 0)</span><br><span class="line">(25 | 0, 0)	(26 | 0, 0)	(27 | 3, 1)	(28 | 2, 10)</span><br><span class="line">28</span><br><span class="line">0 0</span><br><span class="line">2 0</span><br><span class="line">2 9</span><br><span class="line">5 19</span><br><span class="line">6 12</span><br><span class="line">17 7</span><br><span class="line">3 28</span><br><span class="line">4 16</span><br><span class="line">2 -22</span><br><span class="line">2 1</span><br><span class="line">3 2</span><br><span class="line">2 -6</span><br><span class="line">4 1</span><br><span class="line">2 3</span><br><span class="line">6 4</span><br><span class="line">2 -13</span><br><span class="line">3 14</span><br><span class="line">2 -5</span><br><span class="line">20 27</span><br><span class="line">2 2</span><br><span class="line">4 18</span><br><span class="line">13 20</span><br><span class="line">2 9</span><br><span class="line">2 -21</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br><span class="line">3 1</span><br><span class="line">2 10</span><br></pre></td></tr></table></figure>


<h2 id="8-3在双数组字典树中建立AC自动机"><a href="#8-3在双数组字典树中建立AC自动机" class="headerlink" title="8.3在双数组字典树中建立AC自动机"></a>8.3在双数组字典树中建立AC自动机</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_LEVEL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_LEVEL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFO_LEVEL 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(level, frm, args...) &#123;\</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt;= MSG_LEVEL) &#123;\</span><br><span class="line">        <span class="built_in">printf</span>(frm, #<span class="meta">#args);\</span></span><br><span class="line">    &#125;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG(args...) LOG(DEBUG_LEVEL, args);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO(args...) LOG(INFO_LEVEL, args);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struct Node &#123;<span class="comment">//字典树</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    struct Node *next[BASE];<span class="comment">//存储26个英文字符的字典树</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struct DANode &#123;<span class="comment">//双数组字典树结构</span></span><br><span class="line">    <span class="keyword">int</span> base, check, fail;<span class="comment">//fail用于在双数组字典树中建立AC自动机</span></span><br><span class="line">&#125; DANode;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">Node *getNewNode() &#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;next, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;next));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> code(<span class="keyword">char</span> c) &#123; <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> insert(Node *root, <span class="keyword">const</span> <span class="keyword">char</span> *str) &#123;<span class="comment">//在字典树中插入</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    Node *p = root;<span class="comment">//指向当前插入字符串的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = code(str[i]);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[ind] == <span class="literal">NULL</span>) &#123;<span class="comment">//相关子节点为空</span></span><br><span class="line">            cnt++;</span><br><span class="line">            p-&gt;next[ind] = getNewNode();</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;<span class="comment">//返回本次插入str时一共生成几个新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> get_base_value(Node *root, DANode *tree, <span class="keyword">int</span> ind) &#123;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1</span>, flag;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        base += <span class="number">1</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE &amp;&amp; flag; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[base + i].check) flag = <span class="number">0</span>;<span class="comment">//如果存在check值，说明base值已经被占用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (flag == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> transform_double_array_trie(Node *root, DANode *tree, <span class="keyword">int</span> ind) &#123;</span><br><span class="line">    <span class="comment">//字典树转换成双数组字典树，双数组字典树存储在tree中，ind：根节点在双数组字典树中的下标</span></span><br><span class="line">    <span class="comment">//返回最大的下标值</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;flag) tree[ind].check = -tree[ind].check;<span class="comment">//当前节点独立成词</span></span><br><span class="line">    <span class="keyword">int</span> base = get_base_value(root, tree, ind);<span class="comment">//获得当前节点的base值</span></span><br><span class="line">    tree[ind].base = base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        tree[base + i].check = ind;<span class="comment">//子节点check存储父节点下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_ind = ind;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;<span class="comment">//依次确认每一个子节点是base值</span></span><br><span class="line">        <span class="keyword">int</span> temp = transform_double_array_trie(root-&gt;next[i], tree, base + i);</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; max_ind) max_ind = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_ind;<span class="comment">//返回最大下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dump_double_array_tree(DANode *tree, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    LOG_INFO(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        LOG_INFO(<span class="string">&quot;%d %d %d\n&quot;</span>, tree[i].base, tree[i].check, tree[i]. fail);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> clear_trie(Node *root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)  <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        clear_trie(root-&gt;next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> build_ac_base_double_array_trie(DANode *tree, <span class="keyword">int</span> max_ind) &#123;</span><br><span class="line">    <span class="keyword">int</span> *que = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (max_ind + <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">int</span> head, tail;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    tree[<span class="number">1</span>].fail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> child_ind = tree[<span class="number">1</span>].base + i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(tree[child_ind].check) != <span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//第i个节点有子孩子</span></span><br><span class="line">        tree[child_ind].fail = <span class="number">1</span>;<span class="comment">//fail节点指向子孩子</span></span><br><span class="line">        que[tail++] = child_ind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = que[head++];<span class="comment">//当前节点不为空，取出当前节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = tree[p].base + i, k = tree[p].fail;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(tree[c].check) != p) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &amp;&amp; tree[tree[k].base + i].check != k) k = tree[k].fail;<span class="comment">//k节点下面没有第k个子孩子</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(tree[tree[k].base + i].check) == k) k = tree[k].base + i;</span><br><span class="line">            tree[c].fail = k;<span class="comment">//初始化c节点的fail值</span></span><br><span class="line">            que[tail++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(que);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">int</span> n, cnt =  <span class="number">1</span>;<span class="comment">//字典树中一共有cnt个节点</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//读入n个单词</span></span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);<span class="comment">//每次读入一个单词插入字典树中</span></span><br><span class="line">        cnt += insert(root, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将字典树转换成双数组字典树</span></span><br><span class="line">    <span class="keyword">size_t</span> tree_size = <span class="keyword">sizeof</span>(DANode) * (cnt * BASE);</span><br><span class="line">    DANode *tree = (DANode *)<span class="built_in">malloc</span>(tree_size);</span><br><span class="line">    <span class="built_in">memset</span>(tree, <span class="number">0</span>, tree_size);</span><br><span class="line">    <span class="keyword">int</span> max_ind = transform_double_array_trie(root, tree, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> s1 = cnt * <span class="keyword">sizeof</span>(Node);</span><br><span class="line">    <span class="keyword">size_t</span> s2 = max_ind * <span class="keyword">sizeof</span>(DANode);</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;trie(%lu Byte), double array trie(%lu, Byte)\n&quot;</span>, s1, s2);</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;rate : %.2lf\n&quot;</span>, <span class="number">1.0</span> * s2 / s1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max_ind; i++) &#123;</span><br><span class="line">        LOG_DEBUG(<span class="string">&quot;(%d | %d, %d)\t&quot;</span>, i, tree[i].base, tree[i].check);</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span> ) % <span class="number">5</span> == <span class="number">0</span>) LOG_DEBUG(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">//将字典树双数组输入到文件中去</span></span><br><span class="line">    build_ac_base_double_array_trie(tree, max_ind);</span><br><span class="line">    dump_double_array_tree(tree, max_ind);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    clear_trie(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trie(5400 Byte), double array trie(336, Byte)</span><br><span class="line">rate : 0.06</span><br><span class="line">(0 | 0, 0)	(1 | 2, 0)	(2 | 2, 9)	(3 | 5, 19)	(4 | 6, 12)</span><br><span class="line">(5 | 17, 7)	(6 | 3, 28)	(7 | 4, 16)	(8 | 2, -22)	(9 | 2, 1)</span><br><span class="line">(10 | 3, 2)	(11 | 2, -6)	(12 | 4, 1)	(13 | 2, 3)	(14 | 6, 4)</span><br><span class="line">(15 | 2, -13)	(16 | 3, 14)	(17 | 2, -5)	(18 | 20, 27)	(19 | 2, 2)</span><br><span class="line">(20 | 4, 18)	(21 | 13, 20)	(22 | 2, 9)	(23 | 2, -21)	(24 | 0, 0)</span><br><span class="line">(25 | 0, 0)	(26 | 0, 0)	(27 | 3, 1)	(28 | 2, 10)</span><br><span class="line">28</span><br><span class="line">0 0 0</span><br><span class="line">2 0 0</span><br><span class="line">2 9 1</span><br><span class="line">5 19 1</span><br><span class="line">6 12 1</span><br><span class="line">17 7 1</span><br><span class="line">3 28 1</span><br><span class="line">4 16 1</span><br><span class="line">2 -22 1</span><br><span class="line">2 1 1</span><br><span class="line">3 2 1</span><br><span class="line">2 -6 1</span><br><span class="line">4 1 1</span><br><span class="line">2 3 1</span><br><span class="line">6 4 1</span><br><span class="line">2 -13 1</span><br><span class="line">3 14 12</span><br><span class="line">2 -5 1</span><br><span class="line">20 27 1</span><br><span class="line">2 2 1</span><br><span class="line">4 18 1</span><br><span class="line">13 20 1</span><br><span class="line">2 9 1</span><br><span class="line">2 -21 12</span><br><span class="line">0 0 0</span><br><span class="line">0 0 0</span><br><span class="line">0 0 0</span><br><span class="line">3 1 1</span><br><span class="line">2 10 27</span><br></pre></td></tr></table></figure>




<h2 id="8-4-二叉字典树"><a href="#8-4-二叉字典树" class="headerlink" title="8.4 二叉字典树"></a>8.4 二叉字典树</h2><ol>
<li>计算机中所有信息都是二进制存储的</li>
<li>任何信息都可以看成一个二进制串</li>
<li>插入二进制串的字典树，就是二叉字典树</li>
<li>二叉字典树可以存储任意信息</li>
<li>节省空间，浪费时间，本质：时间换空间的算法思维</li>
<li>哈弗曼编码 + 二叉字典树 可能更配哦，既节省了空间，又在最大限度上节省了查找时间</li>
</ol>
<p><strong>建议：</strong>多看几本基本的算法书、【数论基础】、多接触离散型数学思维</p>
<p>end 2021.1.30</p>
<p>不积跬步，无以至千里。不积小流，无以成江海。 </p>
]]></content>
      <categories>
        <category>高级数据结构</category>
      </categories>
      <tags>
        <tag>高级数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2020/12/29/06.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>2020.12.29</p>
<p>说明:本文档的部分图片来至于开课吧宿船长PPT</p>
</blockquote>
<h1 id="一、系统编程"><a href="#一、系统编程" class="headerlink" title="一、系统编程"></a>一、系统编程</h1><h1 id="1-Linux下命令行解析"><a href="#1-Linux下命令行解析" class="headerlink" title="1.Linux下命令行解析"></a>1.Linux下命令行解析</h1><h2 id="1-getopt函数"><a href="#1-getopt函数" class="headerlink" title="1.getopt函数"></a>1.getopt函数</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.48.49.png" alt="截屏2021-01-05 上午9.48.49" style="zoom:80%;" />



<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.58.40.png" alt="截屏2021-01-05 上午9.58.40"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.58.59.png" alt="截屏2021-01-05 上午9.58.59"></p>
<h2 id="2-getopt函数代码演示"><a href="#2-getopt函数代码演示" class="headerlink" title="2.getopt函数代码演示"></a>2.getopt函数代码演示</h2><h3 id="演示1"><a href="#演示1" class="headerlink" title="演示1"></a>演示1</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;al&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">//循环把参数读入opt中，直到函数返回值为-1</span></span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a found!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;l found!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -al\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>




<p>编译后运行结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./a.out ls -al -d                                                                                        </span><br><span class="line">a found!</span><br><span class="line">l found!</span><br><span class="line">./a.out: invalid option -- <span class="string">&#x27;d&#x27;</span></span><br><span class="line">Usage : ./a.out -al</span><br></pre></td></tr></table></figure>


<h3 id="演示2：可选和不可选参数"><a href="#演示2：可选和不可选参数" class="headerlink" title="演示2：可选和不可选参数"></a>演示2：可选和不可选参数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;alm:o::&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a found!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;l found!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg = %s \n&quot;</span>, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;opt = %s\n&quot;</span>, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -al\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">运行结果</span></span><br><span class="line">./a.out -m &quot;lsm1&quot; -m&quot;lsm2&quot; -o&quot;lso1&quot; -o &quot;lso2&quot;               </span><br><span class="line">msg = lsm1</span><br><span class="line">msg = lsm2</span><br><span class="line">opt = lso1</span><br><span class="line">opt = (null)</span><br><span class="line"><span class="meta">#</span><span class="bash">加入m后面没有参数</span></span><br><span class="line">./a.out   -m              </span><br><span class="line">./a.out: option requires an argument -- &#x27;m&#x27;</span><br><span class="line">Usage : ./a.out -al</span><br></pre></td></tr></table></figure>




<h2 id="3-extern"><a href="#3-extern" class="headerlink" title="3.extern"></a>3.extern</h2><h2 id="4-optind-optopt"><a href="#4-optind-optopt" class="headerlink" title="4.optind,optopt"></a>4.optind,optopt</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;optind = %d \noptopt = %d\n&quot;</span>, optind, optopt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行结果</span></span><br><span class="line">optind = 1</span><br><span class="line">optopt = 0</span><br></pre></td></tr></table></figure>






<h1 id="2-文件与IO"><a href="#2-文件与IO" class="headerlink" title="2.文件与IO"></a>2.文件与IO</h1><h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h2><blockquote>
<p>所有执行 I/O 操作的系统调用都以文件描述符，一个非负整数（通常是小整数），来指代 打开的文件。文件描述符用以表示所有类型的已打开文件，包括管道（pipe）、FIFO、socket、终端、 设备和普通文件。针对每个进程，文件描述符都自成一套。</p>
</blockquote>
<blockquote>
<p>按照惯例，大多数程序都期望能够使用 3 种标准的文件描述符，见表 4-1。在程序开始运 行之前，shell 代表程序打开这 3 个文件描述符。更确切地说，程序继承了 shell 文件描述符的 副本—在 shell 的日常操作中，这 3 个文件描述符始终是打开的。（在交互式 shell 中，这 3 个文件描述符通常指向 shell 运行所在的终端。）如果命令行指定对输入/输出进行重定向操作， 那么 shell 会对文件描述符做适当修改，然后再启动程序。</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%883.51.09.png" alt="截屏2021-01-07 下午3.51.09"></p>
<p>下面介绍执行文件 I/O 操作的 4 个主要系统调用（编程语言和软件包通常会利用 I/O 函数 库对它们进行间接调用）。 </p>
<ol>
<li> fd = open(pathname, flags, mode) 函数打开 pathname 所标识的文件，并返回文件描 述符，用以在后续函数调用中指代打开的文件。如果文件不存在，open()函数可以 创建之，这取决于对位掩码参数 flags 的设置。flags 参数还可指定文件的打开方式：只 读、只写亦或是读写方式。mode 参数则指定了由 open()调用创建文件的访问权限， 如果 open()函数并未创建文件，那么可以忽略或省略 mode 参数。 </li>
</ol>
<ol start="2">
<li>numread = read(fd, buffer, count) 调用从 fd 所指代的打开文件中读取至多 count 字节的 数据，并存储到 buffer 中。read()调用的返回值为实际读取到的字节数。如果再无字节 可读（例如：读到文件结尾符 EOF 时），则返回值为 0。 </li>
</ol>
<ol start="3">
<li>numwritten = write(fd, buffer, count) 调用从 buffer 中读取多达 count 字节的数据写入由 fd 所指代的已打开文件中。write()调用的返回值为实际写入文件中的字节数，且有可 能小于 count。 </li>
</ol>
<ol start="4">
<li>status = close(fd)在所有输入/输出操作完成后，调用 close()，释放文件描述符 fd 以及 与之相关的内核资源。</li>
</ol>
<h2 id="1-打开一个文件-open函数"><a href="#1-打开一个文件-open函数" class="headerlink" title="1.打开一个文件:open函数"></a>1.打开一个文件:open函数</h2><h3 id="1-open简介"><a href="#1-open简介" class="headerlink" title="1.open简介"></a>1.open简介</h3><p><code>int open(const char *pathname, int flags)</code></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%883.55.29.png" alt="截屏2021-01-07 下午3.55.29"></p>
<p>​        </p>
<p>​        要打开的文件由参数 pathname 来标识。如果 pathname 是一符号链接，会对其进行解引用。 如果调用成功，open()将返回一文件描述符，用于在后续函数调用中指代该文件。若发生错误， 则返回−1，并将 errno 置为相应的错误标志。</p>
<p>​        </p>
<p>​        参数 flags 为位掩码，用于指定文件的访问模式，</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%883.57.06.png" alt="截屏2021-01-07 下午3.57.06"></p>
<p>​        </p>
<p>​        当调用 open()创建新文件时，位掩码参数 mode 指定了文件的访问权限。（SUSv3 规定，mode 的数据类型 mode_t 属于整数类型。）如果 open()并未指定 O_CREAT 标志，则可以省略 mode 参数。</p>
<p>​        SUSv3 规定，如果调用 open()成功，必须保证其返回值为进程未用文件描述符中数值最 小者。可以利用该特性以特定文件描述符打开某一文件。</p>
<h3 id="2-open-调用中的-flags-参数"><a href="#2-open-调用中的-flags-参数" class="headerlink" title="2.open()调用中的 flags 参数"></a>2.open()调用中的 flags 参数</h3><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.07.42.png" alt="截屏2021-01-07 下午4.07.42"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.13.14.png" alt="截屏2021-01-07 下午4.13.14"></p>
<h3 id="3-open-函数的错误"><a href="#3-open-函数的错误" class="headerlink" title="3.open()函数的错误"></a>3.open()函数的错误</h3><p>若打开文件时发生错误，open()将返回−1，错误号 errno 标识错误原因。以下是一些可能 发生的错误（除了在上节参数描述中已经提及的错误之外）。 </p>
<p>EACCES </p>
<p>​        文件权限不允许调用进程以 flags 参数指定的方式打开文件。无法访问文件，其可能的原 因有目录权限的限制、文件不存在并且也无法创建该文件。 </p>
<p>EISDIR </p>
<p>​        所指定的文件属于目录，而调用者企图打开该文件进行写操作。不允许这种用法。</p>
<p> EMFILE </p>
<p>​        进程已打开的文件描述符数量达到了进程资源限制所设定的上限</p>
<p> ENFILE </p>
<p>​        文件打开数量已经达到系统允许的上限。 </p>
<p>ENOENT </p>
<p>​        要么文件不存在且未指定 O_CREAT 标志，要么指定了 O_CREAT 标志，但 pathname 参数所指定路径的目录之一不存在，或者 pathname 参数为符号链接，而该链接指向的文件不存 在（空链接）。</p>
<p>EROFS </p>
<p>​        所指定的文件隶属于只读文件系统，而调用者企图以写方式打开文件。 </p>
<p>ETXTBSY </p>
<p>​        所指定的文件为可执行文件（程序），且正在运行。系统不允许修改正在运行的程序（比如 以写方式打开文件）。（必须首先终止程序运行，然后方可修改可执行文件。）</p>
<h3 id="4-open代码演示"><a href="#4-open代码演示" class="headerlink" title="4.open代码演示"></a>4.open代码演示</h3><blockquote>
<p><code>open, read, write, close</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;./a.txt&quot;</span>, O_CREAT | O_RDONLY)) &lt; <span class="number">0</span>) &#123;<span class="comment">//打开文件</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//return 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((nread = read(fd, buff, <span class="keyword">sizeof</span>(buff))) &gt; <span class="number">0</span>) &#123;<span class="comment">//从fd读入到buff，每次的大小为buff的大小</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %ld\n buffer =  %s&quot;</span>, nread, buff);</span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>perror : perror - print a system error message</code></p>
<p>打印系统错误信息</p>
<h2 id="2-读取文件内容-read"><a href="#2-读取文件内容-read" class="headerlink" title="2.读取文件内容:read()"></a>2.读取文件内容:read()</h2><blockquote>
<p>read()系统调用从文件描述符 fd 所指代的打开文件中读取数据。</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.15.35.png" alt="截屏2021-01-07 下午4.15.35"></p>
<p>​        count 参数指定最多能读取的字节数。（size_t 数据类型属于无符号整数类型。）buffer 参数提供用来存放输入数据的内存缓冲区地址。缓冲区至少应有 count 个字节。</p>
<p>​        如果 read()调用成功，将==返回实际读取的字节数==，如果遇到文件结束（EOF）则返回 0， 如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数 或-1（表示错误）。</p>
<p>​        一次 read()调用所读取的字节数可以小于请求的字节数。对于普通文件而言，这有可能是 因为当前读取位置靠近文件尾部。 </p>
<p>​        当 read()应用于其他文件类型时，比如管道、FIFO、socket 或者终端，在不同环境下也会 出现 read()调用读取的字节数小于请求字节数的情况。</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.22.37.png" alt="截屏2021-01-07 下午4.22.37"></p>
<h2 id="3-数据写入文件-write"><a href="#3-数据写入文件-write" class="headerlink" title="3.数据写入文件:write()"></a>3.数据写入文件:write()</h2><blockquote>
<p>write()系统调用将数据写入一个已打开的文件中。</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.24.18.png" alt="截屏2021-01-07 下午4.24.18"></p>
<p>​        write()调用的参数含义与 read()调用相类似。buffer 参数为要写入文件中数据的内存地址，count 参数为欲从 buffer 写入文件的数据字节数，fd 参数为一文件描述符，指代数据要写入的文件。 </p>
<p>​        如果 write()调用成功，将返回实际写入文件的字节数，该返回值可能小于 count 参数值。 这被称为“部分写”。对磁盘文件来说，造成“部分写”的原因可能是由于磁盘已满，或是因 为进程资源对文件大小的限制。 </p>
<p>​        对磁盘文件执行 I/O 操作时，write()调用成功并不能保证数据已经写入磁盘。因为为了减 少磁盘活动量和加快 write()系统调用，内核会缓存磁盘的 I/O 操作。</p>
<h2 id="4-关闭文件：close"><a href="#4-关闭文件：close" class="headerlink" title="4.关闭文件：close()"></a>4.关闭文件：close()</h2><blockquote>
<p>​        close()系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。 当一进程终止时，将自动关闭其已打开的所有文件描述符。</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.26.46.png" alt="截屏2021-01-07 下午4.26.46"></p>
<p>​        显式关闭不再需要的文件描述符往往是良好的编程习惯，会使代码在后续修改时更具可 读性，也更可靠。进而言之，文件描述符属于有限资源，因此文件描述符关闭失败可能会导 致一个进程将文件描述符资源消耗殆尽。在编写需要长期运行并处理大量文件的程序时，比 如 shell 或者网络服务器软件，需要特别加以关注。</p>
<p>小结：为了对普通文件执行 I/O 操作，首先必须调用 open()以获得一个文件描述符。随之使用 read()和 write()执行文件的 I/O 操作，然后应使用 close()释放文件描述符及相关资源。这些系 统调用可对所有类型的文件执行 I/O 操作。 所有类型的文件和设备驱动都实现了相同的 I/O 接口，这保证了 I/O 操作的通用性，同时 也意味着在无需针对特定文件类型编写代码的情况下，程序通常就能操作所有类型的文件。</p>
<h2 id="5-fopen函数"><a href="#5-fopen函数" class="headerlink" title="5.fopen函数"></a>5.fopen函数</h2><blockquote>
<p><code>fopen, fwrite, fread, fclose</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;./b.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);<span class="comment">//fopen: No such file or directory</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//循环读入，直到文件结尾</span></span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">size_t</span> nread = fread(buff, <span class="number">1</span>, <span class="keyword">sizeof</span>(buff), fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line">        <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>标准IO都是缓冲IO</p>
<p>标准错误输出都会无缓冲输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep()库函数可将当前执行的进程挂起指定的秒数。</p>
<h1 id="3-阻塞IO与非阻塞IO"><a href="#3-阻塞IO与非阻塞IO" class="headerlink" title="3.阻塞IO与非阻塞IO"></a>3.阻塞IO与非阻塞IO</h1><h2 id="1-阻塞和非阻塞的概念"><a href="#1-阻塞和非阻塞的概念" class="headerlink" title="1.阻塞和非阻塞的概念"></a>1.阻塞和非阻塞的概念</h2><blockquote>
<p>什么是阻塞、什么是非阻塞</p>
</blockquote>
<p>阻塞操作是指在执行设备操作时若不能获得资源则挂起进程，直到满足可操作的条件后再进行操作。被挂起的进程进入休眠状态，被从调度器的运行队列移走，直到等待的条件被满足。非阻塞操作的进程在不能进行设备操作时并不挂起，它或者放弃，或者不停地查询，直至可以进行操作为止。</p>
<p>阻塞就是数据给了内核，内核没有返回结果之前，你必须等待。非阻塞就是数据给了内核，不论结果如何。</p>
<p>阻塞的代价：必须等待，等待会占用系统资源</p>
<p>非阻塞的优点：不会占用系统资源</p>
<p>非阻塞的代价</p>
<h2 id="2-对阻塞非阻塞的理解"><a href="#2-对阻塞非阻塞的理解" class="headerlink" title="2.对阻塞非阻塞的理解"></a>2.对阻塞非阻塞的理解</h2><blockquote>
<p>废话不说，老张爱喝茶，煮开水，有两个水壶，普通水壶，响水壶（水开会提示）</p>
</blockquote>
<p><strong>同步</strong>就是普通水壶烧开水，要没事儿自己过来来看开没开；<br><strong>异步</strong>就是响水壶烧开水，水开了水壶响了通知你。<br><strong>阻塞</strong>是烧开水的过程中，你不能干其他事情（即你被阻塞住了），只能站那等水开；<br><strong>非阻塞</strong>是烧开水的过程里可以干其他事情。比如去客厅看看电视；</p>
<blockquote>
<p>同步与异步说的是你获得水开了的方式不同。<br>阻塞与非阻塞说的是你得到结果之前能不能干其他事情。<br>两组概念描述的是不同的内容。</p>
</blockquote>
<p>这里你看明白了，就会发现：</p>
<blockquote>
<p>效率最高的办法是 <strong>响水壶烧水（异步）</strong><br><strong>水烧开提示你之前可以去干别的事儿（非阻塞）</strong><br>等到水开了提示你你再去拿水<br>所以异步和非阻塞常常在一起大大提高每个线程的效率</p>
</blockquote>
<p>摘自<a href="https://blog.csdn.net/evanxuhe/article/details/79627709">阻塞</a></p>
<h2 id="3-非阻塞IO有什么用"><a href="#3-非阻塞IO有什么用" class="headerlink" title="3.非阻塞IO有什么用"></a>3.非阻塞IO有什么用</h2><p>当我们告诉内核，如果数据没有到来，你立马给我返回，不用等待数据了。设置成非阻塞的方法如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);   <span class="comment">//设置成非阻塞模式；</span></span><br></pre></td></tr></table></figure>
<p>其实非阻塞模式的使用并不普遍，因为非阻塞模式会浪费大量的CPU资源。、</p>
<p>用户态下沉到内核态</p>
<p>内核是一个快缓冲</p>
<p>fcntl</p>
<h2 id="4-fcntl"><a href="#4-fcntl" class="headerlink" title="4.fcntl()"></a>4.fcntl()</h2><p>fcntl()系统调用对一个打开的文件描述符执行一系列控制操作。</p>
<p>函数原型</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%8810.55.21.png" alt="截屏2021-01-08 上午10.55.21"></p>
<p>函数描述</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%8810.55.49.png" alt="截屏2021-01-08 上午10.55.49"></p>
<p>​        cmd 参数所支持的操作范围很广。</p>
<p>​        fcntl()的第三个参数以省略号来表示，这意味着可以将其设置为不同的类型，或者加以省 略。内核会依据 cmd 参数（如果有的话）的值来确定该参数的数据类型。</p>
<p>​        fcntl()的用途之一是针对一个打开的文件，获取或修改其访问模式和状态标志（这些值是 通过指定 open()调用的 flag 参数来设置的）。要获取这些设置，应将 fcntl()的 cmd 参数设置为 F_GETFL。</p>
<p>fcntl函数有5种功能：</p>
<p>　 1.复制一个现有的描述符（cmd=F_DUPFD）.</p>
<p>　 2.获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD).</p>
<p>​      3.获得／设置文件状态标记(cmd=F_GETFL或F_SETFL).</p>
<p>​      4.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN).</p>
<p>​      5.获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW).</p>
<h2 id="5-fcntl-代码演示"><a href="#5-fcntl-代码演示" class="headerlink" title="5.fcntl()代码演示"></a>5.fcntl()代码演示</h2><h3 id="1-00-head-h"><a href="#1-00-head-h" class="headerlink" title="1.00.head.h"></a>1.00.head.h</h3><p>头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;05.common.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-04-common-c"><a href="#2-04-common-c" class="headerlink" title="2.04.common.c"></a>2.04.common.c</h3><p>阻塞与非阻塞的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_nonblock</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;<span class="comment">//设置非阻塞</span></span><br><span class="line">    <span class="comment">//fcntl(fd, F_SETFL, O_NONBLOCK);</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">if</span> ((flag = fcntl(fd, F_GETFL)) &lt; <span class="number">0</span>) &#123;<span class="comment">//获得文件状态标记</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag |= O_NONBLOCK;<span class="comment">//flag = O_NONBLOCK,以非阻塞方式打开，在原先flag的基础加上非阻塞方式</span></span><br><span class="line">    <span class="keyword">return</span> fcntl(fd, F_SETFL, flag);<span class="comment">//设置文件状态标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_block</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;<span class="comment">//设置阻塞方式</span></span><br><span class="line">    <span class="comment">//fcntl(fd, F_SETFL, O_NONBLOCK);</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">if</span> ((flag = fcntl(fd, F_GETFL)) &lt; <span class="number">0</span>) &#123;<span class="comment">//获得文件状态标记flag</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag &amp;= ~O_NONBLOCK;<span class="comment">//flag = O_NONBLOCK,以非阻塞方式打开，设置非阻塞方式</span></span><br><span class="line">    <span class="keyword">return</span> fcntl(fd, F_SETFL, flag);<span class="comment">//设置文件状态标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-05-common-h"><a href="#3-05-common-h" class="headerlink" title="3.05.common.h"></a>3.05.common.h</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#ifdef _COMMON_H</span><br><span class="line">#define _COMMON_H</span><br><span class="line">int make_nonblock(int fd);</span><br><span class="line">int make_block(int fd);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="4-07-testblock-c"><a href="#4-07-testblock-c" class="headerlink" title="4.07.testblock.c"></a>4.07.testblock.c</h3><p>//测试阻塞和非阻塞</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="comment">//test1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_nonblock</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    make_nonblock(<span class="number">0</span>);<span class="comment">//设置当前文件打开方式为非阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;guziqiu is %d years old!, ret = %d \n&quot;</span>, age, ret);</span><br><span class="line">    perror(<span class="string">&quot;scanf&quot;</span>);<span class="comment">//打印scanf错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">guziqiu is <span class="number">-151492080</span> years old!, ret = <span class="number">-1</span></span><br><span class="line"><span class="built_in">scanf</span>: Resource temporarily unavailable</span><br><span class="line">  <span class="comment">//sacnf返回值是成功读入变量的个数，-1为报错</span></span><br><span class="line">  <span class="comment">//文件资源占时不可访问</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">//test 2 </span></span><br><span class="line"><span class="keyword">int</span> make_nonblock(<span class="keyword">int</span> fd);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    make_nonblock(<span class="number">0</span>);<span class="comment">//设置当前文件打开方式为非阻塞</span></span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;guziqiu is %d years old!, ret = %d \n&quot;</span>, age, ret);</span><br><span class="line">    perror(<span class="string">&quot;scanf&quot;</span>);<span class="comment">//打印scanf错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line">guziqiu is <span class="number">18</span> years old!, ret = <span class="number">1</span></span><br><span class="line"><span class="built_in">scanf</span>: Success</span><br></pre></td></tr></table></figure>


<h2 id="6-select"><a href="#6-select" class="headerlink" title="6.select()"></a>6.select()</h2><p>部分内容来至于<a href="https://zhuanlan.zhihu.com/p/57518857">linux select函数解析以及事例</a></p>
<h3 id="6-1select详解"><a href="#6-1select详解" class="headerlink" title="6.1select详解"></a>6.1select详解</h3><p>IO感知</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8B%E5%8D%884.25.54.png" alt="截屏2021-01-08 下午4.25.54"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfd, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">nfds：被监听的文件描述符的总数，它比所有文件描述符集合中的文件描述符的最大值大1，因为文件描述符是从0开始计数的；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">readfds、writefds、exceptset：分别指向可读、可写和异常等事件对应的描述符集合。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">timeout:用于设置select函数的超时时间，即告诉内核select等待多长时间之后就放弃等待。timeout == NULL 表示等待无限长的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<p>参数说明</p>
<ul>
<li>nfds：是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错。在linux系统中，select的默认最大值为1024。设置这个值的目的是为了不用每次都去轮询这1024个fd，假设我们只需要几个套接字，我们就可以用最大的那个套接字的值加上1作为这个参数的值，当我们在等待是否有套接字准备就绪时，只需要监测maxfd+1个套接字就可以了，这样可以减少轮询时间以及系统的开销。</li>
<li>readfds：首先需要明白，fd_set是什么数据类型，有一点像int，又有点像struct，其实，fd_set声明的是一个集合，也就是说，readfs是一个容器，里面可以容纳多个文件描述符，把==需要监视的描述符==放入这个集合中，==当有文件描述符可读时，select就会返回一个大于0的值，表示有文件可读==；</li>
<li>writefds：和readfs类似，表示有一个==可写的文件描述符==集合，当有文件可写时，select就会返回一个大于0的值，表示有文件可写；</li>
<li>fd_set*errorfds同上面两个参数的意图，用来==监视文件错误异常文件==。</li>
<li>timeout：这个参数一出来就可以知道，可以选择阻塞，可以选择非阻塞，还可以选择定时返回。当将timeout置为NULL时，表明此时select是阻塞的；当将tineout设置为timeout-&gt;tv_sec = 0，timeout-&gt;tv_usec = 0时，表明这个函数为非阻塞；当将timeout设置为非0的时间，表明select有超时时间，当这个时间走完，select函数就会返回。从这个角度看，个人觉得可以用select来做超时处理，因为你如果使用recv函数的话，你还需要去设置recv的模式，麻烦的很。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span>      </span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> tv_sec;   <span class="comment">/*秒 */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> tv_usec;  <span class="comment">/*微秒 */</span>   </span><br><span class="line"></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>返回值：超时返回0;失败返回-1；成功返回大于0的整数，这个整数表示就绪描述符的数目</p>
<p>fd_set的几个宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//一个 fd_set类型变量的所有位都设为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//清除某个位时可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">//设置变量的某个位置位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//测试某个位是否被置位</span></span><br></pre></td></tr></table></figure>


<p>对fd_set的理解：fd_set可以理解为一个集合，那么集合就会有一个数量，在&lt;sys/select.h&gt;总定义了一个常量FD_SETSIZE，默认为1024，也就是说在这个集合内默认最多有1024个文件描述符，但是通常你用不了这么多，你通常只是关心nfds个描述符。也就是说你现在有nfds个文件描述符在这个集合里，那么我怎么知道集合里的哪个文件描述符有消息来了呢？你可以将fd_set中的集合看成是二进制bit位，一位代表着一个文件描述符。==0代表文件描述符处于睡眠状态，没有数据到来；1代表文件描述符处于准备状态，可以被应用层处理。==我觉得select函数可以分下面几步进行理解</p>
<ol>
<li>在你开始监测这些描述符时，你先将这些文件描述符全部置为0</li>
<li>当你需要监测的描述符置为1</li>
<li>使用select函数监听置为1的文件描述符是否有数据到来</li>
<li>==当状态为1的文件描述符有数据到来时，此时你的状态仍然为1，但是其他状态为1的文件描述如果没有数据到来，那么此时会将这些文件描述符置为0==</li>
<li>当select函数返回后，可能有一个或者多个文件描述符为1，那么你怎么知道是哪个文件描述符准备好了呢？其实select并不会告诉你说，我哪个文件描述符准备好了，他只会告诉你他的那些bit为位哪些是0，哪些是1。也就是说你需要自己用逻辑去判断你要的那个文件描是否准备好了</li>
</ol>
<p>理解了上面几步的话，下面这些宏就比较好理解了。</p>
<ul>
<li>FD_ZERO：将指定集合里面所有的描述符全部置为0，==在对文件描述符集合进行设置前，必须对其进行初始化==，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的</li>
<li>FD_SET：用于在文件描述符集合中增加一个新的文件描述符，将相应的位置置为1</li>
<li>FD_CLR：用来清除集合里面的某个文件描述符</li>
<li>FD_ISSET：用来检测指定的某个描述符是否有数据到来。- 那么假如在我们的程序中有5个客户端已经连接上了服务器，这个时候突然有一条数据过来了。select返回了，但是此时你并不知道是哪个客户发过来的消息，因为你每个客户发过来的消息都是一样重要的。所以你没法去只针对一个套接字使用FD_ISSET，你需要做的是用一个循环去检测（FD_ISSET）到底是哪一个客户发过来的消息，因为如果此时你监测一个套接字的话，其他客户的信息你会丢失。这个也是select的一个缺点，你需要去检测所有的套接字，看看这个套接字到底是谁来的数据。</li>
</ul>
<h3 id="6-2对fd-set的理解"><a href="#6-2对fd-set的理解" class="headerlink" title="6.2对fd_set的理解"></a>6.2对fd_set的理解</h3><p>理解select模型的关键在于理解fd_set,为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。</p>
<p>（1）执行fd_set set; FD_ZERO(&amp;set); 则set用位表示是0000,0000。</p>
<p>（2）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1)</p>
<p>（3）若再加入fd＝2，fd=1,则set变为0001,0011</p>
<p>（4）执行select(6,&amp;set,0,0,0)阻塞等待</p>
<p>（5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。</p>
<p>内容来自<a href="https://www.cnblogs.com/skyfsm/p/7079458.html">Linux编程之select</a></p>
<h3 id="6-3select代码演示"><a href="#6-3select代码演示" class="headerlink" title="6.3select代码演示"></a>6.3select代码演示</h3><p><strong>select的使用流程</strong></p>
<p>1.先调用宏FD_ZERO将指定的fd_set清零，</p>
<p>2.然后调用宏FD_SET将需要测试的fd加入fd_set，</p>
<p>3.接着调用函数select监测fd_set中的所有fd，</p>
<p>4.最后用宏FD_ISSET检查某个fd在函数select调用后，相应位是否仍然为1，然后做相应的逻辑处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    fd_set rfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Watch stdin (fd 0) to see when it has input. */</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;rfds);<span class="comment">//将rdfs的fd_set清零，</span></span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;rfds);<span class="comment">//fd = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait up to five seconds. */</span></span><br><span class="line"></span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;<span class="comment">//等待5秒</span></span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;<span class="comment">//设置等待微秒</span></span><br><span class="line"></span><br><span class="line">    retval = select(<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);<span class="comment">//fd + 1</span></span><br><span class="line">    <span class="comment">/* Don&#x27;t rely on the value of tv now! */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">&quot;select()&quot;</span>);<span class="comment">//失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data is available now.\n&quot;</span>);<span class="comment">//成功</span></span><br><span class="line">        <span class="comment">/* FD_ISSET(0, &amp;rfds) will be true. */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No data within five seconds.\n&quot;</span>);<span class="comment">//超时</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a.out                                                  </span><br><span class="line">ls</span><br><span class="line">Data is available now.</span><br><span class="line"><span class="meta">apricity@Apricity%</span><span class="bash"> ls</span></span><br><span class="line">00.head.h  01.open.c  02.fopen.c  03.fflush.c  04.common.c  05.common.h  06.fork.c  07.testblock.c  08.select.c  a.out  b.txt</span><br></pre></td></tr></table></figure>


<p>==&gt;为什么会出现 ls命令</p>
<p>输入ls,select感知IO成功,程序执行完毕，ls被zsh执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">   <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Data is available now.\n&quot;</span>);<span class="comment">//成功</span></span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buff);<span class="comment">//吃掉输入的数据</span></span><br><span class="line">&#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>


<h2 id="6-补充-用户态和内核态"><a href="#6-补充-用户态和内核态" class="headerlink" title="6.补充:用户态和内核态"></a>6.补充:用户态和内核态</h2><h1 id="4-多进程"><a href="#4-多进程" class="headerlink" title="4.多进程"></a>4.多进程</h1><h2 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1.什么是进程"></a>1.什么是进程</h2><blockquote>
<p>什么是程序</p>
</blockquote>
<p>程序是编译好的可执行的二进制文件。应用是程序的集合。</p>
<blockquote>
<p>什么是进程</p>
</blockquote>
<p>一种说法是进程是程序在内存中的镜像，另一种常见的说法是进程是运行中的程序。</p>
<p>进程（process）是一个可执行程序（program）的实例。</p>
<p><strong>进程号和父进程号</strong></p>
<p>​        每个进程都有一个进程号（PID），进程号是一个正数，用以唯一标识系统中的某个进程。对 各种系统调用而言，进程号有时可以作为传入参数，有时可以作为返回值。</p>
<p>​        系统调用 getpid()返回调用进程的进程号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span>  <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span>  <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​        getpid()返回值的数据类型为 pid_t，该类型是由 SUSv3 所规定的整数类型，专用于存储进 程号。 </p>
<p>​        除了少数系统进程外，比如 init 进程（进程号为 1），程序与运行该程序进程的进程号之 间没有固定关系。</p>
<p>​        每个进程都有一个创建自己的父进程。使用系统调用 getppid()可以检索到父进程的进程号。</p>
<p>​        实际上，每个进程的父进程号属性反映了系统上所有进程间的树状关系。每个进程的父 进程又有自己的父进程，以此类推，回溯到 1 号进程—init 进程，即所有进程的始祖。</p>
<p>​        如果子进程的父进程终止，则子进程就会变成“孤儿”，init 进程随即将收养该进程，子 进程后续对 getppid()的调用将返回进程号 1。</p>
<p><strong>孤儿进程与僵尸进程</strong></p>
<p>父进程与子进程的生命周期一般都不相同，父、子进程间互有长短。这就引出了下面两个问题。 </p>
<ul>
<li><p>谁会是孤儿（orphan）子进程的父进程？进程 ID 为 1 的众进程之祖—init 会接管孤儿 进程。换言之，某一子进程的父进程终止后，对 getppid()的调用将返回 1。这是判定 某一子进程之“生父”是否“在世”的方法之一（前提是假设该子进程由 init 之外的 进程创建）。</p>
</li>
<li><p>在父进程执行 wait()之前，其子进程就已经终止，这将会发生什么？此处的要点在于，即使 子进程已经结束，系统仍然允许其父进程在之后的某一时刻去执行 wait()，以确定该子进程 是如何终止的。内核通过将子进程转为僵尸进程（zombie）来处理这种情况。这也意味着将 释放子进程所把持的大部分资源，以便供其他进程重新使用。该进程所唯一保留的是内核进 程表中的一条记录，其中包含了子进程ID、终止状态、资源使用数据等信息。</p>
<p>​        至于僵尸进程名称的由来，则源于 UNIX 系统对电影情节的效仿—无法通过信号来杀死 僵尸进程，即便(银弹）SIGKILL。这就确保了父进程总是可以执行 wait()方法。 </p>
<p>​        当父进程执行 wait()后，由于不再需要子进程所剩余的最后信息，故而内核将删除僵尸进 程。另一方面，如果父进程未执行 wait()随即退出，那么 init 进程将接管子进程并自动调用 wait()，从而从系统中移除僵尸进程.</p>
<p>​        如果父进程创建了某一子进程，但并未执行 wait()，那么在内核的进程表中将为该子进程永 久保留一条记录。如果存在大量此类僵尸进程，它们势必将填满内核进程表，从而阻碍新进程的 创建。既然无法用信号杀死僵尸进程，那么从系统中将其移除的唯一方法就是杀掉它们的父进程 （或等待其父进程终止），此时 init 进程将接管和等待这些僵尸进程，从而从系统中将它们清理掉。</p>
</li>
</ul>
<h2 id="2-fork-详解"><a href="#2-fork-详解" class="headerlink" title="2.fork()详解"></a>2.fork()详解</h2><blockquote>
<p>fork()创建一个子进程</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%886.18.51.png" alt="截屏2021-01-07 下午6.18.51"></p>
<p>​        系统调用 <code>fork()</code>允许一进程（父进程）创建一新进程（子进程）。具体做法是，新 的子进程几近于对父进程的翻版：子进程获得父进程的栈、数据段、堆和执行文 本段的拷贝。可将此视为把父进程一分为二，术语 fork 也由此得名。</p>
<p>​        理解 fork()的诀窍是，要意识到，完成对其调用后将存在两个进程，且每个进程都会从 fork() 的返回处继续执行。 </p>
<p>​        这两个进程将执行相同的程序文本段，但却各自拥有不同的栈段、数据段以及堆段拷贝。子进程的栈、数据以及栈段开始时是对父进程内存相应各部分的完全复制。执行 fork() 之后，每个进程均可修改各自的栈数据、以及堆段中的变量，而并不影响另一进程。 </p>
<p>​        程序代码则可通过 fork()的返回值来区分父、子进程。在父进程中，fork()将返回新创建 子进程的进程 ID。鉴于父进程可能需要创建，进而追踪多个子进程（通过 wait()或类似方法）， 这种安排还是很实用的。而 fork()在子进程中则返回 0。如有必要，子进程可调用 getpid()以获 取自身的进程 ID，调用 getppid()以获取父进程 ID。 </p>
<p>​        当无法创建子进程时，fork()将返回-1。失败的原因可能在于，进程数量要么超出了系统 针对此真实用户（real user ID）在进程数量上所施加的限制，要么是触及允许该系统创建的最大进程数这一系统级上限。</p>
<p><strong>重点</strong></p>
<p>1.pid_t进程id</p>
<p>2.创建一个新的进程，复制了一份自己,新的进程被叫作子进程,父亲和孩子分别运行在一个完全独立隔离的内存空间，fork时，共用一样的内存空间，只有内存才发生变化时，拷贝才会真实发生(称为写拷贝)</p>
<p>子进程是一个严格的</p>
<p>3.==fork()的子进程返回值为0，父进程返回子进程pid==</p>
<p>4.子进程和父进程的区别：</p>
<p>子进程和父进程的进程ID不一样，且唯一</p>
<p>子进程的父亲ID和父亲pid一样</p>
<p>孩子不会继承父亲的内存锁</p>
<p>进程资源使用和CPU使用都会被清空</p>
<ul>
<li><p>子进程不继承信号量</p>
</li>
<li><p>不会继承计时器</p>
</li>
<li><p>不会继承异步IO操作</p>
<p>进程的属性</p>
</li>
</ul>
<p>返回值：</p>
<p>父进程中返回子进程的pid,子进程返回0,</p>
<p>getpid获得自己的id</p>
<p>getppid获得父进程id</p>
<h2 id="3-fork-代码演示"><a href="#3-fork-代码演示" class="headerlink" title="3.fork()代码演示"></a>3.fork()代码演示</h2><h3 id="3-1fork-理解"><a href="#3-1fork-理解" class="headerlink" title="3.1fork()理解"></a>3.1fork()理解</h3><p>#include “00.head.h”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">guziqiu</span><br><span class="line">guziqiuguziqiu%</span><br></pre></td></tr></table></figure>
<p>==&gt;输出2个<code>name变量</code></p>
<p>原因:fork之后的代码会有两份，之前的代码只执行了一次,标准IO是缓冲IO(没有遇到换行或者缓冲区内容过多或者程序结束，printf的内容会留在输出缓冲区,缓冲区内容被fork,return  0 ;后输出缓冲区内容被释放，输出一个name变量)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==&gt;输出1个<code>name</code></p>
<p>标准IO是缓冲IO,缓冲区被换行符刷新</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==&gt;输出2个<code>name</code></p>
<p>fork后的内容被复制</p>
<h3 id="3-2-fork-进阶"><a href="#3-2-fork-进阶" class="headerlink" title="3.2.fork()进阶"></a>3.2.fork()进阶</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;<span class="comment">//必须有括号，否则逻辑会不同，子进程一生下来就在11行的位置</span></span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);<span class="comment">//fork出错，fork = -1,大部分是因为内存不够</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//==&gt;思考：一定是父进程先执行吗?</span></span><br><span class="line">        <span class="comment">//父进程和子进程空间相互独立，谁先跑都没有关系，由内核调度决定</span></span><br><span class="line">        <span class="comment">//基于内核算法，极大概率先执行父进程</span></span><br><span class="line">        <span class="comment">//原因:父进程正在执行，此时复制父进程，父进程执行完才会执行子进程，所以一般会先执行父进程</span></span><br><span class="line">        <span class="comment">//如果此时cpu强制停用父进程，先执行别的进程，则可能会出现子进程先执行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Process!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent Process\n&quot;</span>);<span class="comment">//父子进程有同一份代码，孩子从11行开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程管理子进程，</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="4-wait-详解"><a href="#4-wait-详解" class="headerlink" title="4.wait()详解"></a>4.wait()详解</h2><p>​        系统调用 <code>wait()</code>等待调用进程的任一子进程终止，同时在参数 status 所指向的缓冲区中返回 该子进程的终止状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *wstatus)</span></span>;</span><br></pre></td></tr></table></figure>
<p>系统调用 wait()执行如下动作。 </p>
<p>1． 如果调用进程并无之前未被等待的子进程终止 ，调用将一直阻塞，直至某个子进程终止。 如果调用时已有子进程终止，wait()则立即返回。</p>
<p> 2． 如果 status 非空，那么关于子进程如何终止的信息则会通过 status 指向的整型变量返回。 </p>
<p> 3． 内核将会为父进程下所有子进程的运行总量追加进程 CPU 时间以及资源使用 数据。 </p>
<p>4． 将终止子进程的 ID 作为 <code>wait()</code>的结果返回。</p>
<p>​        出错时，wait()返回-1。可能的错误原因之一是调用进程并无之前未被等待的1子进程，此 时会将 errno 置为 ECHILD。换言之，可使用如下代码中的循环来等待调用进程的所有子进程 退出。</p>
<p>子进程退出状态</p>
<p>所有的系统进程都在等待子进程的变化，并且获得状态变化（孩子被终结，杀死，唤醒），对于一个被终结的进程，执行wait，由系统释放孩子所关联的资源</p>
<p>孩子死了父进程没有为孩子收尸，孩子变成了僵尸进程，没有占用cpu但是会占用系统资源和pid，</p>
<p>wait没有被执行会变成僵尸进程</p>
<p>如果进程以及死了，wait会立马返回，孩子没死，父进程会一直等着，或者收到一个中断信号</p>
<p>​        父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。<br>注：</p>
<ol>
<li>当父进程忘了用wait()函数等待已终止的子进程时,子进程就会进入一种无父进程的状态,此时子进程就是僵尸进程.</li>
<li>wait()要与fork()配套出现,如果在使用fork()之前调用wait(),wait()的返回值则为-1,正常情况下wait()的返回值为子进程的PID.</li>
<li>如果先终止父进程,子进程将继续正常进行，只是它将由init进程(PID 1)继承,当子进程终止时,init进程捕获这个状态.</li>
<li>参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就像下面这样：<br><code>pid = wait(NULL);</code><br>如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。<br>　　如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中， 这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的，以及正常结束时的返回值，或被哪一个信号结束的等信息。由于这些信息 被存放在一个整数的不同二进制位中，所以用常规的方法读取会非常麻烦，人们就设计了一套专门的宏（macro）来完成这项工作，下面我们来学习一下其中最常用的两个：<br>1，WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。<br>（请注意，虽然名字一样，这里的参数status并不同于wait唯一的参数–指向整数的指针status，而是那个指针所指向的整数，切记不要搞混了。）<br>2， WEXITSTATUS(status) 当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status) 就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。请注意，如果进程不是正常退出的，也就是说， WIFEXITED返回0，这个值就毫无意义。</li>
</ol>
<h2 id="5-wait-代码演示"><a href="#5-wait-代码演示" class="headerlink" title="5.wait()代码演示"></a>5.wait()代码演示</h2><h3 id="产生僵尸进程"><a href="#产生僵尸进程" class="headerlink" title="产生僵尸进程"></a>产生僵尸进程</h3><p><code>fork.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Process!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent Process\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;--sleep(5)&quot;</span>);</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">apricity@Apricity 00.课程代码 % ./a.out                                                                                                   </span><br><span class="line">Parent Process</span><br><span class="line">Child Process!</span><br><span class="line">^Z</span><br><span class="line">[1]  + 16838 suspended  ./a.out</span><br><span class="line">apricity@Apricity 00.课程代码 % bg                            </span><br><span class="line">[1]  + 16838 continued  ./a.out</span><br><span class="line">apricity@Apricity 00.课程代码 % ps                                                                                                        </span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">16342 pts/0    00:00:03 zsh</span><br><span class="line">16838 pts/0    00:00:00 a.out</span><br><span class="line">16839 pts/0    00:00:00 a.out &lt;defunct&gt;#僵尸进程</span><br><span class="line">16842 pts/0    00:00:00 ps</span><br><span class="line">apricity@Apricity 00.课程代码 %ps -aux | grep 16839                </span><br><span class="line">apricity 16839  0.0  0.0      0     0 pts/0    Z    11:12   0:00 [a.out] &lt;defunct&gt;</span><br><span class="line">apricity 16852  0.0  0.0  14428  1044 pts/0    S+   11:15   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox 16839</span><br><span class="line">apricity@Apricity 00.课程代码 % ps -aux | grep Z             </span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">apricity 16839  0.0  0.0      0     0 pts/0    Z    11:12   0:00 [a.out] &lt;defunct&gt;</span><br><span class="line">apricity 16858  0.0  0.0  14428   996 pts/0    S+   11:16   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox Z</span><br><span class="line"><span class="meta">#</span><span class="bash">Z的意思就是僵尸进程</span></span><br></pre></td></tr></table></figure>


<p><code>fork.wait.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Process!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent Process\n&quot;</span>);</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;--wait status = %d \n&quot;</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a.out                                                            </span><br><span class="line">Parent Process</span><br><span class="line">Child Process!</span><br><span class="line">--wait status = 256</span><br></pre></td></tr></table></figure>


<p>创建10个子进程,每个子进程打印自己是子进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; I am %d Child Process!\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">500</span>);</span><br><span class="line">    &#125; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep  &quot;./a.out&quot; | grep -v &quot;grep&quot; | wc -l</span><br><span class="line">1024</span><br><span class="line"><span class="meta">#</span><span class="bash">一共产生1024个进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2^10 = 1024，会以子数倍增长</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">break</span>;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; I am %d Child Process!\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">500</span>);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a.out                                                            </span><br><span class="line"> I am 1 Child Process!</span><br><span class="line"> I am 3 Child Process!</span><br><span class="line"> I am 2 Child Process!</span><br><span class="line"> I am 4 Child Process!</span><br><span class="line"> I am 9 Child Process!</span><br><span class="line"> I am 10 Child Process!</span><br><span class="line"> I am 5 Child Process!</span><br><span class="line"> I am 6 Child Process!</span><br><span class="line"> I am 7 Child Process!</span><br><span class="line"> I am 8 Child Process!</span><br><span class="line">ps -aux | grep &quot;a.out&quot; | grep -v &quot;grep&quot; | wc -l                                              </span><br><span class="line">10</span><br></pre></td></tr></table></figure>


<h2 id="6-exec-家族详解"><a href="#6-exec-家族详解" class="headerlink" title="6.exec()家族详解"></a>6.exec()家族详解</h2><p>​        系统调用 execve()可以将新程序加载到某一进程的内存空间。在这一操作过程中，将丢弃 旧有程序，而进程的栈、数据以及堆段会被新程序的相应部件所替换。</p>
<p>​        基于系统调用 execve()，还提供了一系列冠以 exec 来命名的上层库函数，虽然接口方式 各异，但功能相同。通常将调用这些函数加载一个新程序的过程称作 exec 操作，或是简单地 以 exec()来表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<p>​        </p>
<p>​        参数 pathname 包含准备载入当前进程空间的新程序的路径名，既可以是绝对路径（冠 之以/），也可以是相对于调用进程当前工作目录（current working directory）的相对路径。</p>
<p>​        参数 argv 则指定了传递给新进程的命令行参数。该数组对应于 C 语言 main()函数的第 2 个参数（argv），且格式也与之相同：是由字符串指针所组成的列表，以 NULL 结束。argv[0]的 值则对应于命令名。通常情况下，该值与 pathname 中的 basename（路径名的最后部分）相同。</p>
<p>​        最后一个参数 envp 指定了新程序的环境列表。参数 envp 对应于新程序的 environ 数组：也是由字符串指针组成的列表，以 NULL 结束，所指向的字符串格式为 name=value。</p>
<p>　exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件<strong>。</strong>这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。</p>
<p>　　与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行</p>
<p>exec族的任一函数都不创建一个新的进程，而是在调用进程里面去执行新的程序。所以进程id不变，还是调用exec函数前的进程id，但是用户空间的代码和数据都更新了，变为新程序的代码和数据了。 </p>
<p>​    extern char **environ;    //全局环境变量，导入到本文件即可直接使用</p>
<ol>
<li>int execl(const char *path, const char *arg, …);    </li>
</ol>
<p>​    功能：通过路径+文件名来加载一个进程；path文件路径；arg文件名称；…可变参数，至少一个NULL</p>
<p>​    附：l即list </p>
<p>​    返回值：成功的情况下是没有返回的，失败时返回-1 。</p>
<p>​    举例说明：</p>
<p>​        execl(“/bin/ls”, “ls”, “-a”, “-l”, NULL);    //path绝对路径，如/bin/ls；文件名称ls；后面三个可变参数，最后必须以NULL结束</p>
<ol start="2">
<li>int execlp(const char *file, const char *arg, …);    </li>
</ol>
<p>​    功能：借助PATH环境变量加载一个进程，file要加载的程序的名称</p>
<p>​    附：l即list；p即path </p>
<p>​    该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数file，则出错返回。</p>
<p>​    该函数通常用来调用系统程序。如：ls、cp、cat等命令。 </p>
<p>​    返回值：成功的情况下是没有返回的，失败时返回-1 。</p>
<p>​    举例说明：</p>
<p>​        execlp(“ls”, “ls”, “-a”, “-l”, NULL);    //第一个ls是指查看PATH环境变量里的ls；第二个ls是名称文件；后面是可变参数，NULL结束</p>
<ol start="3">
<li>int execle(const char *path, const char *arg, …, char * const envp[]);    </li>
</ol>
<p>​    功能：加载指定路径的程序，并为新程序复制最后一个环境变量</p>
<p> 附：l即list；e即environment</p>
<p>​    举例说明：</p>
<p>​        char* envp[] = {NULL};</p>
<p>​        execlp(“ls”, “ls”, “-a”, “-l”, NULL, envp);</p>
<ol start="4">
<li>int execv(const char *path, char *const argv[]);</li>
</ol>
<p>​    功能：加载指定路径的程序 </p>
<p>​    附：v即vector，命令行参数列表</p>
<p>​    举例说明：</p>
<p>​        char* argv[] = {“ls”, “-a”, “-l”, NULL}; </p>
<p>​        execl(“/bin/ls”,argv);</p>
<ol start="5">
<li>int execvp(const char *file, char *const argv[]);</li>
</ol>
<p>​    功能：加载path环境变量里的名称为file的程序 </p>
<p>​    附：v即命令行参数列表，p即path </p>
<p>​    int main(int argc, char *argv[]) {</p>
<p>​        pid_t pid = fork();</p>
<p>​        if (pid == 0) {    //子进程里加载ls程序</p>
<p>​            char* argvv[] = {“ls”, “-a”, “-l”, NULL};</p>
<p>​            execvp(“ls”, argvv);</p>
<p>​            perror(“execlp”);  exit(1);    //只有execl函数执行失败的情况下才有机会执行这两句代码，执行的成功话就有去无回了。</p>
<p>​        } else if (pid &gt; 0) {</p>
<p>​            sleep(1);    printf(“parent\n”);</p>
<p>​        }</p>
<p>​        return 0;</p>
<p>​    }</p>
<ol start="6">
<li>int  execve(const  char  *filename, char *const argv[], char *const envp[]);</li>
</ol>
<p>​    功能：加载指定的程序；filename必须是一个可执行程序或者一个以#! interpreter [optional-arg] 开始的脚本。</p>
<p>​        上面的五个exec函数是库函数，这个是系统函数；上面的五个exec函数最终都是调用这个函数实现的。 </p>
<p>总结：exec族函数的规律</p>
<p>​    exec函数一旦调用成功就有去无回了，去执行新的程序去了。只有失败时才有返回，返回值为-1。所以我们直接在exec函数调用后直接调用perror()和exit()，不需要if判断，因为失败的情况才会执行。</p>
<p>​    函数名的意义的理解： </p>
<p>​        l (list) 命令行参数列表</p>
<p>​        p (path) 环境变量，环境变量搜素文件名称file</p>
<p>​        v (vector) 命令行参数数组</p>
<p>​        e (environment) 环境变量数组，给新加载程序设置指定的环境变量</p>
<p>​    函数的相似性： </p>
<p>​        execlp——&gt;execvp </p>
<p>​                  |         </p>
<p>​        execl  ——&gt;execv</p>
<p>​                  | </p>
<p>​        execle——&gt;execve</p>
<p>​        从左往右，可变参数转为以NULL结尾的指针数组；从左往右， 从上往下，最后归根结底都是调用execve函数实现的。</p>
<p>替换当前进程映像用一个新的进程映像，</p>
<h2 id="7-exec-代码演示"><a href="#7-exec-代码演示" class="headerlink" title="7.exec()代码演示"></a>7.exec()代码演示</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt;  <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;start\n&quot;</span>);</span><br><span class="line">        execlp(<span class="string">&quot;vim&quot;</span>, <span class="string">&quot;vim&quot;</span>, <span class="string">&quot;12.exec.c&quot;</span>, <span class="literal">NULL</span>);<span class="comment">//子进程，在子进程中执行vim,名字是vim,名字是12.exec.c</span></span><br><span class="line">        sleep(<span class="number">10000000</span>);<span class="comment">//子进程中不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;END!\n&quot;</span>);<span class="comment">//子进程中不存在</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After child terminated!\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//12.exec.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt;  <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;start\n&quot;</span>);</span><br><span class="line">        execl(<span class="string">&quot;./a.out&quot;</span>, <span class="string">&quot;haha&quot;</span>, <span class="string">&quot;12.exec.c&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        sleep(<span class="number">10000000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;END!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After child terminated!\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//13.test_exec.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg0 = %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc 13.test_exec.c</span><br><span class="line">./a.out                                   </span><br><span class="line">arg0 = ./a.out</span><br><span class="line">gcc 12.exec.c -o exec</span><br><span class="line"> ./exec                                                        </span><br><span class="line">start</span><br><span class="line">arg0 = haha#习惯上将此处设置为文件名</span><br><span class="line">After child terminated!</span><br></pre></td></tr></table></figure>


<h2 id="8-高级进程管理"><a href="#8-高级进程管理" class="headerlink" title="8.高级进程管理"></a>8.高级进程管理</h2><p>进程调度</p>
<p>进程调度是一个内核子系统</p>
<p>进程调度的主要任务是决定哪一个“就绪”状态的进程来执行</p>
<p>就绪进程就是 非阻塞进程</p>
<p>阻塞进程就是正在睡眠的进程，需要内核唤醒的进程;</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%882.43.53.png" alt="截屏2021-01-21 下午2.43.53"></p>
<h1 id="5-进程间通信上"><a href="#5-进程间通信上" class="headerlink" title="5.进程间通信上"></a>5.进程间通信上</h1><h2 id="5-1进程间通信"><a href="#5-1进程间通信" class="headerlink" title="5.1进程间通信"></a>5.1进程间通信</h2><p>Linux 系统上运行有多个进程，其中许多都是独立运行。然而，有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制。 </p>
<p>​        读写磁盘文件中的信息是进程间通信的方法之一。可是，对许多程序来说，这种方法既 慢又缺乏灵活性。因此，像所有现代 UNIX 实现那样，Linux 也提供了丰富的进程间通信（IPC） 机制，如下所示。 </p>
<ul>
<li> 信号（signal），用来表示事件的发生。 </li>
<li> 管道（亦即 shell 用户所熟悉的“|”操作符）和 FIFO，用于在进程间传递数据。 </li>
<li>套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据。 </li>
<li>文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以 锁定。 </li>
<li>消息队列，用于在进程间交换消息（数据包）。 </li>
<li>信号量（semaphore），用来同步进程动作。 </li>
<li>共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容 时，其他所有进程会立即了解到这一变化。 </li>
</ul>
<p>​        </p>
<h2 id="5-2System-V-共享内存"><a href="#5-2System-V-共享内存" class="headerlink" title="5.2System V 共享内存"></a>5.2System V 共享内存</h2><p>​         共享内存允许两个或多个进程共享物理内存的同一块区 域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间内存的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分 数据会对其他所有共享同一个段的进程可用。与管道或消息队列要求发送进程将数据从用户 空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法 相比，这种 IPC 技术的速度更快。（每个进程也存在通过系统调用来执行复制操作的开销。） </p>
<p>​         另一方面，共享内存这种 IPC 机制不由内核控制意味着通常需要通过某些同步方法使得 进程不会出现同时访问共享内存的情况（如两个进程同时执行更新操作或者一个进程在从共 享内存中获取数据的同时另一个进程正在更新这些数据）。System V 信号量天生就是用来完成 这种同步的一种方法。当然，还可以使用其他方法，如 POSIX 信号量和文件锁.</p>
<h3 id="5-2-1共享内存的使用"><a href="#5-2-1共享内存的使用" class="headerlink" title="5.2.1共享内存的使用"></a>5.2.1共享内存的使用</h3><p>为使用一个共享内存段通常需要执行下面的步骤。 </p>
<ul>
<li>调用 shmget()创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程 创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 </li>
<li>使用 shmat()来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 </li>
<li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内 存，程序需要使用由 shmat()调用返回的 addr 值，它是一个指向进程的虚拟地址空间 中该共享内存段的起点的指针。</li>
<li>调用 shmdt()来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存 了。这一步是可选的，并且在进程终止时会自动完成这一步。 </li>
<li>调用 shmctl()来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后 内存段才会被销毁。只有一个进程需要执行这一步。</li>
</ul>
<h3 id="5-2-2创建或打开一个共享内存段shmget"><a href="#5-2-2创建或打开一个共享内存段shmget" class="headerlink" title="5.2.2创建或打开一个共享内存段shmget()"></a>5.2.2创建或打开一个共享内存段shmget()</h3><p>shmget()系统调用创建一个新共享内存段或获取一个既有段的标识符。新创建的内存段中 的内容会被初始化为 0。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       shmget - allocates a System V shared memory segment</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/ipc.h&gt;</span><br><span class="line">       #include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">       int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>​         当使用 shmget()创建一个新共享内存段时，size 则是一个正整数，它表示需分配的段的字 节数。内核是以系统分页大小的整数倍来分配共享内存的，因此实际上 size 会被提升到最近 的系统分页大小的整数倍。如果使用 shmget()来获取一个既有段的标识符，那么 size 对段不会 产生任何效果，但它必须要小于或等于段的大小。 </p>
<p>​        shmflg 参数执行的任务与其在其他 IPC get 调用中执行的任务一样，即指定施加于新共享 内存段上的权限或需检查的既有内存段的权限。此外，在 shmflg 中还可以对下列标 记中的零个或多个取 OR 来控制 shmget()的操作。 </p>
<p>​        IPC_CREAT </p>
<p>如果不存在与指定的 key 对应的段，那么就创建一个新段。 </p>
<p>​        IPC_EXCL </p>
<p>如果同时指定了IPC_CREAT 并且与指定的key 对应的段已经存在，那么返回EEXIST 错误。  SHM_HUGETLB（自 Linux 2.6 起） </p>
<p>特权（CAP_IPC_LOCK）进程能够使用这个标记创建一个使用巨页（huge page）的共享内存 段。巨页是很多现代硬件架构提供的一项特性用来管理使用超大分页尺寸的内存。（如 x86-32 允 许使用 4MB 的分页大小来替代 4KB 的分页大小。）在那些拥有大量内存的系统上并且应用程序需 要使用大量内存块时，使用巨页可以降低硬件内存管理单元的超前转换缓冲器（translation look-aside buffer，TLB）中的条目数量。这之所以会带来益处是因为 TLB 中的条目通常是一种稀 缺资源。更多信息可参考内核源文件 Documentation/vm/ hugetlbpage.txt。 </p>
<p>SHM_NORESERVE（自 Linux 2.6.15 起）</p>
<p> 这个标记在 shmget()中所起的作用与 MAP_NORESERVE 标记在 mmap()中所起的作用一 样。 shmget()在成功时返回新或既有共享内存段的标识符。</p>
<h3 id="5-2-3-使用共享内存shmat"><a href="#5-2-3-使用共享内存shmat" class="headerlink" title="5.2.3 使用共享内存shmat()"></a>5.2.3 使用共享内存shmat()</h3><p>shmat()系统调用将 shmid 标识的共享内存段附加到调用进程的虚拟地址空间中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       shmat, shmdt - System V shared memory operations</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/types.h&gt;</span><br><span class="line">       #include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">       void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line"></span><br><span class="line">       int shmdt(const void *shmaddr);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, a valid shared memory identifier is returned.  On error, <span class="number">-1</span> is returned, <span class="keyword">and</span> errno is <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>


<p>shmaddr 参数和 shmflg 位掩码参数中 SHM_RND 位的设置控制着段是如何被附加上去的。 </p>
<ul>
<li>如果 shmaddr 是 NULL，那么段会被附加到内核所选择的一个合适的地址处。这是附 加一个段的优选方法。 </li>
<li>如果 shmaddr 不为 NULL 并且没有设置 SHM_RND，那么段会被附加到由 shmaddr 指 定的地址处，它必须是系统分页大小的一个倍数（否则会发生 EINVAL 错误）。 </li>
<li>如果 shmaddr 不为 NULL 并且设置了 SHM_RND，那么段会被映射到的地址为在 shmaddr 中提供的地址被舍入到最近的常量 SHMLBA（shared memory low boundary address）的倍数。这个常量等于系统分页大小的某个倍数。将一个段附加到值为 SHMLBA 的倍数的地址处在一些架构上是有必要的，因为这样才能够提升 CPU 的快 速缓冲性能和防止出现同一个段的不同附加操作在 CPU 快速缓冲中存在不一致的视 图的情况</li>
</ul>
<p>​        shmat()的函数结果是返回附加共享内存段的地址。开发人员可以像对待普通的 C 指针那 样对待这个值，段与进程的虚拟内存的其他部分看起来毫无差异。通常会将 shmat()的返回值 赋给一个指向某个由程序员定义的结构的指针以便在该段上设定该结构。 </p>
<p>​        要附加一个共享内存段以供只读访问，那么就需要在 shmflg 中指定 SHM_RDONLY 标记。 试图更新只读段中的内容会导致段错误（SIGSEGV 信号）的发生。如果没有指定 SHM_ RDONLY，那么就既可以读取内存又可以修改内存。 </p>
<p>​        一个进程要附加一个共享内存段就需要在该段上具备读和写权限，除非指定了 SHM_ RDONLY 标记，那样的话就只需要具备读权限即可。</p>
<p>​        最后一个可以在 shmflg 中指定的值是 SHM_REMAP。在指定了这个标记之后 shmaddr 的值 必须为非 NULL。这个标记要求 shmat()调用替换起点在 shmaddr 处长度为共享内存段的长度的 任何既有共享内存段或内存映射。一般来讲，如果试图将一个共享内存段附加到一个已经在用 的地址范围时将会导致 EINVAL 错误的发生。SHM_REMAP 是一个非标准的 Linux 扩展。</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-22%20%E4%B8%8A%E5%8D%8810.43.15.png" alt="截屏2021-01-22 上午10.43.15"></p>
<p>​        </p>
<p>​        当一个进程不再需要访问一个共享内存段时就可以调用 shmdt()来讲该段分离出其虚拟地 址空间了。shmaddr 参数标识出了待分离的段，它应该是由之前的 shmat()调用返回的一个值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​        分离一个共享内存段与删除它是不同的。删除是通过 shmctl() IPC_ RMID 操作来完成的。</p>
<p>​        通过 fork()创建的子进程会继承其父进程附加的共享内存段。因此，共享内存为父进程和 子进程之间的通信提供了一种简单的 IPC 方法。 </p>
<p>​        在一个 exec()中，所有附加的共享内存段都会被分离。在进程终止之后共享内存段也会自 动被分离</p>
<h3 id="5-2-4ipcs-和-ipcrm-命令"><a href="#5-2-4ipcs-和-ipcrm-命令" class="headerlink" title="5.2.4ipcs 和 ipcrm 命令"></a>5.2.4ipcs 和 ipcrm 命令</h3><p>​        ipcs 和 ipcrm 命令是 System V IPC 领域中类似于 ls 和 rm 文件命令的命令。使用 ipcs 能够 获取系统上 IPC 对象的信息。在默认情况下，ipcs 会显示出所有对象，如下面的例子所示。</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-22%20%E4%B8%8A%E5%8D%8810.52.09.png" alt="截屏2021-01-22 上午10.52.09"></p>
<p>​        在 Linux 上，ipcs(1)只显示出拥有读权限的 IPC 对象的信息，而不管是否拥有这些对象。 在一些 UNIX 实现上，ipcs 的行为与它在 Linux 上的行为一样，但在其他实现上，ipcs 会显示 出所有对象，不管当前用户是否拥有这些对象上的读权限。 </p>
<p>​        在默认情况下，ipcs 会显示出每个对象的 key、标识符、所有者以及权限（用一个八进制 数字表示），后面跟着对象所特有的信息。 </p>
<ul>
<li><p>对于共享内存，ipcs 会显示出共享内存区域的大小、当前将共享内存区域附加到自己 的虚拟地址空间的进程数以及状态标记。状态标记标识出了区域是否被锁进了 RAM 以防止交换以及在所有进程都与该区域分离之后是否已经将其标记为待销毁了。</p>
</li>
<li><p>对于信号量，ipcs 会显示出信号集的大小。 </p>
</li>
<li><p>对于消息队列，ipcs 会显示出队列中数据占据的字节总数以及消息数量。</p>
<p>ipcs(1)手册对各种能够显示 IPC 对象的其他信息的选项进行了说明。 ipcrm 命令删除一个 IPC 对象。这个命令的常规形式为下面两种形式中的一种</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipcrm -X key</span><br><span class="line">ipcrm -x id</span><br></pre></td></tr></table></figure>
<p>​        在上面给出的命令中既可以将一个 IPC 对象的 key 指定为参数 key，也可以将一个 IPC 对象 的标识符指定为参数 id 并且使用小写的 x 替换其大写形式或使用小写的 q（用于消息队列）或 s （用于信号量）或 m（用于共享内存）。因此使用下面的命令可以删除标识符为 65538 的信号量集。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipcrm -s 65538  #删除标识符为 65538 的信号量集</span><br><span class="line">ipcrm -m 65538 #删除标识符为 65538 的共享内存</span><br></pre></td></tr></table></figure>




<h2 id="5-3互斥量-mutexe-和条件变量-condition-variable"><a href="#5-3互斥量-mutexe-和条件变量-condition-variable" class="headerlink" title="5.3互斥量(mutexe)和条件变量(condition variable)"></a>5.3互斥量(mutexe)和条件变量(condition variable)</h2><p>​        互斥量可以帮助线程同步对共享资源的使用，以防如下情况发生：线程某甲试图访 问一共享变量时，线程某乙正在对其进行修改。条件变量则是在此之外的拾遗补缺，允许线 程相互通知共享变量（或其他共享资源）的状态发生了变化。</p>
<p>​        互斥量既可以像静态变量那样分配，也可以在运行时动态创建。</p>
<p>​        互斥量是属于 pthread_mutex_t 类型的变量。在使用之前必须对其初始化。对于静态分配 的互斥量而言，可将 PTHREAD_MUTEX_INITIALIZER 赋给互斥量。</p>
<p>​        初始化之后，互斥量处于未锁定状态。函数 pthread_mutex_lock()可以锁定某一互斥量，而 函数 pthread_mutex_unlock()则可以将一个互斥量解锁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       pthread_mutex_init, pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock, pthread_mutex_destroy - operations on mutexes</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">pthread_mutex_t</span> fastmutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">pthread_mutex_t</span> recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">pthread_mutex_t</span> errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       pthread_mutex_init always returns <span class="number">0.</span> The other mutex functions <span class="keyword">return</span> <span class="number">0</span> on success <span class="keyword">and</span> a non-zero error code on error.</span><br></pre></td></tr></table></figure>


<p>​        要锁定互斥量，在调用 pthread_mutex_lock()时需要指定互斥量。如果互斥量当前处于未锁定 状态，该调用将锁定互斥量并立即返回。如果其他线程已经锁定了这一互斥量，那么 pthread_ mutex_lock()调用会一直堵塞，直至该互斥量被解锁，到那时，调用将锁定互斥量并返回。</p>
<p>​        如果发起 pthread_mutex_lock()调用的线程自身之前已然将目标互斥量锁定，对于互斥量 的默认类型而言，可能会产生两种后果—视具体实现而定：线程陷入死锁（deadlock），因 试图锁定已为自己所持有的互斥量而遭到阻塞；或者调用失败，返回 EDEADLK 错误。在 Linux 上，默认情况下线程会发生死锁。</p>
<p>​        函数 pthread_mutex_unlock()将解锁之前已遭调用线程锁定的互斥量。以下行为均属错误： 对处于未锁定状态的互斥量进行解锁，或者解锁由其他线程锁定的互斥量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br></pre></td></tr></table></figure>


<p>​        参数 mutex 指定函数执行初始化操作的目标互斥量。参数 attr 是指向pthread_mutexattr_t 类 型对象的指针，该对象在函数调用之前已经过了初始化处理，用于定义互斥量的属性。若将 attr 参数置为 NULL，则该互斥量的各种属性会取默认值。 </p>
<p>​        SUSv3 规定，初始化一个已初始化的互斥量将导致未定义的行为，应当避免这一行为。 </p>
<p>​        在如下情况下，必须使用函数 pthread_mutex_init()，而非静态初始化互斥量。 </p>
<ul>
<li><p>动态分配于堆中的互斥量。例如，动态创建针对某一结构的链表，表中每个结构都包 含一个 pthread_mutex_t 类型的字段来存放互斥量，借以保护对该结构的访问。 </p>
</li>
<li><p>互斥量是在栈中分配的自动变量。 </p>
</li>
<li><p>初始化经由静态分配，且不使用默认属性的互斥量。</p>
<p>当不再需要经由自动或动态分配的互斥量时，应使用 pthread_mutex_destroy()将其销毁。</p>
</li>
</ul>
<p>​      只有当互斥量处于未锁定状态，且后续也无任何线程企图锁定它时，将其销毁才是安全 的。若互斥量驻留于动态分配的一片内存区域中，应在释放（free）此内存区域前将其销毁。 对于自动分配的互斥量，也应在宿主函数返回前将其销毁。 </p>
<p>​        经由 pthread_mutex_destroy()销毁的互斥量，可调用 pthread_mutex_init()对其重新初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INS 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> *<span class="title">share_memory</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;share_memory-&gt;mutex);</span><br><span class="line">        pthread_cond_wait(&amp;share_memory-&gt;cond, &amp;share_memory-&gt;mutex);</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (share_memory-&gt;now &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                pthread_mutex_unlock(&amp;share_memory-&gt;mutex);</span><br><span class="line">                pthread_cond_signal(&amp;share_memory-&gt;cond);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            share_memory-&gt;sum += share_memory-&gt;now;</span><br><span class="line">            share_memory-&gt;now++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&lt;%d&gt; now = %d, sum = %d\n&quot;</span>, x, share_memory-&gt;now, share_memory-&gt;sum);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="comment">//pthread_mutex_unlock(&amp;share_memory-&gt;mutex);</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;share_memory-&gt;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;share_memory-&gt;cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, shmid;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">2021</span>);</span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, <span class="keyword">sizeof</span>(struct Num), IPC_CREAT | IPC_EXCL | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sshmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    share_memory = (struct Num*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (share_memory == (struct Num*)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;share_memory&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    share_memory-&gt;now = <span class="number">0</span>;</span><br><span class="line">    share_memory-&gt;sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;attr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_mutex_init(&amp;share_memory-&gt;mutex, &amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_condattr_t</span> condattr;</span><br><span class="line">    pthread_condattr_init(&amp;condattr);</span><br><span class="line">    pthread_condattr_setpshared(&amp;condattr, <span class="number">1</span>);</span><br><span class="line">    pthread_cond_init(&amp;share_memory-&gt;cond, &amp;condattr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;before fork()\n&quot;);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= INS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        x = i;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        do_add(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        pthread_cond_signal(&amp;share_memory-&gt;cond);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= INS; i++) &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end ==&gt; share_memory-&gt;sum = %d \n&quot;</span>, share_memory-&gt;sum);</span><br><span class="line">    shmdt(share_memory);</span><br><span class="line">    shmctl(shmid, IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-4进程调度"><a href="#5-4进程调度" class="headerlink" title="5.4进程调度"></a>5.4进程调度</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%882.47.16.png" alt="截屏2021-01-21 下午2.47.16"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%882.49.36.png" alt="截屏2021-01-21 下午2.49.36"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%882.52.55.png" alt="截屏2021-01-21 下午2.52.55"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%883.02.41.png" alt="截屏2021-01-21 下午3.02.41"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%883.06.29.png" alt="截屏2021-01-21 下午3.06.29"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%883.08.34.png" alt="截屏2021-01-21 下午3.08.34"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%883.09.54.png" alt="截屏2021-01-21 下午3.09.54"></p>
<h1 id="6-进程间通信下"><a href="#6-进程间通信下" class="headerlink" title="6.进程间通信下"></a>6.进程间通信下</h1><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>shmctl</p>
<p>ftok</p>
<p>聊天系统</p>
<p><code>18.ipc.chat.server.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;17.ipc.chat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> *<span class="title">shar_memory</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">202101</span>);</span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, <span class="keyword">sizeof</span>(struct Msg), IPC_CREAT | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((shar_memory = (struct Msg *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (struct Msg *)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(shar_memory, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Msg));</span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> m_attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;m_attr);</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;m_attr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_mutex_init(&amp;shar_memory-&gt;mutex, &amp;m_attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_condattr_t</span> c_attr;</span><br><span class="line">    pthread_condattr_init(&amp;c_attr);</span><br><span class="line">    pthread_condattr_setpshared(&amp;c_attr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_cond_init(&amp;shar_memory-&gt;cond, &amp;c_attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;shar_memory-&gt;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Server got the Mutex!\n&quot;</span>);</span><br><span class="line">        pthread_cond_wait(&amp;shar_memory-&gt;cond, &amp;shar_memory-&gt;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Server got the cond signal!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; : %s.\n&quot;</span>, shar_memory-&gt;name, shar_memory-&gt;msg);</span><br><span class="line">        <span class="built_in">memset</span>(shar_memory-&gt;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(shar_memory-&gt;msg));</span><br><span class="line">        pthread_mutex_unlock(&amp;shar_memory-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>19.ipc.chat.client.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;17.ipc.chat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> *<span class="title">shar_memory</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt, shmid;<span class="comment">//.,共享内存id</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;n:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(name, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -n name\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">202101</span>);</span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, <span class="keyword">sizeof</span>(struct Msg), IPC_CREAT | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((shar_memory = (struct Msg *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (struct Msg *)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> msg[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, msg);</span><br><span class="line">        getchar();<span class="comment">//吃掉缓冲区的回车键</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strlen</span>(msg)) <span class="keyword">continue</span>;<span class="comment">//字符串为空</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strlen</span>(shar_memory-&gt;msg)) &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;shar_memory-&gt;mutex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pthread_mutex_lock(&amp;shar_memory-&gt;mutex);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sending : %s...\n&quot;</span>, msg);</span><br><span class="line">        <span class="built_in">strcpy</span>(shar_memory-&gt;msg, msg);</span><br><span class="line">        <span class="built_in">strcpy</span>(shar_memory-&gt;name, name);</span><br><span class="line">        pthread_cond_signal(&amp;shar_memory-&gt;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;shar_memory-&gt;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Client signaled the cond\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>17.ipc.chat.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><code>00.head.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure>




<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程的一个分支</p>
<p>pthread process thread</p>
<p>一个进程可以有多个线程，本质上是一种轻量级进程</p>
<p>共享内存，通信简单，调度成本低，</p>
<p>进程与进程之间调度成本高：</p>
<p>有时间局部性，运行一段时间，就将进程调度出去，换一个新的程序，缓冲也会被干掉</p>
<p>线程本质上的共享内存，一个进程的多个线程在调度的时候，不需要做切换，直接用就可以，原先线程建立起的缓冲信息可以直接用</p>
<p>pthread_create</p>
<p>argument参数</p>
<p>pthread_exit(3)线程自杀</p>
<p>线程创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyArg</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">print</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyArg</span> <span class="title">copyMyarg</span>;</span></span><br><span class="line">    copyMyarg = *(struct MyArg *)arg;<span class="comment">//防止在执行过程中会被其他线程改变，所以先拷贝下来</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyArg</span> *<span class="title">in</span>;</span></span><br><span class="line">    in = (struct MyArg *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In Thread\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s is %d years old!\n&quot;</span>, in-&gt;name, in-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s is %d years old!\n&quot;</span>, copyMyarg.name, copyMyarg.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyArg</span> <span class="title">arg</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(arg.name, <span class="string">&quot;古子秋&quot;</span>);</span><br><span class="line">    arg.age = age;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, print, &amp;arg);</span><br><span class="line">    usleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程是为了解决一个确定性的工作</p>
<p>用理发店举例</p>
<p>刚开始创业开理发店</p>
<p>只有我一个人会理发，如果来了一个人，就可以直接理发，如果来了多个人，除了第一个其他人就只能处于等待状态，就相当于早期的单线程或者单进程处理</p>
<p>现在我学会了一种神奇的技术，叫克隆(fork())，如果我正在理发，又有新客户新来了，那么我克隆一个自己，让他去服务，这就是多进程</p>
<p>但是我发现，克隆自己的代价太大了，系统只能同意我们打开1024个进程，而且拷贝进程会占内存，国家又禁止克隆技术</p>
<p>现在突然发现旁边的理发学院有的学生想做兼职，如果来了很多客人，我就在微信群里面喊多少人过来做兼职，做完了就让他们走。(多线程)</p>
<p> 但是创建进程或者线程比较麻烦，客人需要等待，又要创建又要销毁，</p>
<p>现在我发现店里面人很多。基本上天天都有人，然后我就在人才市场找了几个固定员工，签了合同，如果有人来就去照顾客人，没有人就在店里等待客人到来。（线程池）</p>
<p>所有的客人都处于等待理发的状态，一个员工理发之后继续处于等待状态，为了激励员工，如果多理发的员工会得到更多的薪资(饥渴的线程)，但是为了避免线程同事竞争同一个客户，我们将所有的客户放在一个房子里面(资源加锁)，客户一个一个出来，只有一个员工可以帮客人理发。</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-26%20%E4%B8%8B%E5%8D%885.22.46.png" alt="截屏2021-01-26 下午5.22.46"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-26%20%E4%B8%8B%E5%8D%885.29.35.png" alt="截屏2021-01-26 下午5.29.35"></p>
<p>23.thread_pool.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;24.thread_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_queue_init</span><span class="params">(struct task_queue *taskQueue, <span class="keyword">int</span> size)</span> </span>&#123;<span class="comment">//初始化队列</span></span><br><span class="line">    taskQueue-&gt;size = size;</span><br><span class="line">    taskQueue-&gt;total = <span class="number">0</span>;</span><br><span class="line">    taskQueue-&gt;head = taskQueue-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;taskQueue-&gt;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;taskQueue-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line">    taskQueue-&gt;data = <span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_queue_push</span><span class="params">(struct task_queue *taskQueue, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (taskQueue-&gt;total == taskQueue-&gt;size) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task queue is full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;push&gt;:%s\n&quot;</span>, str);</span><br><span class="line">    taskQueue-&gt;data[taskQueue-&gt;tail] = str;</span><br><span class="line">    taskQueue-&gt;total++;</span><br><span class="line">    <span class="keyword">if</span> (++taskQueue-&gt;tail == taskQueue-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task queue reach end!\n&quot;</span>);</span><br><span class="line">        taskQueue-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cond_signal(&amp;taskQueue-&gt;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">task_queue_pop</span><span class="params">(struct task_queue *taskQueue)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">    <span class="keyword">while</span> (taskQueue-&gt;total == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task queue is empty!\n&quot;</span>);</span><br><span class="line">        pthread_cond_wait(&amp;taskQueue-&gt;cond, &amp;taskQueue-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *str = taskQueue-&gt;data[taskQueue-&gt;head];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;pop&gt;:%s\n&quot;</span>, str);</span><br><span class="line">    taskQueue-&gt;total--;</span><br><span class="line">    <span class="keyword">if</span> (++taskQueue-&gt;head == taskQueue-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task queue reach end!\n&quot;</span>);</span><br><span class="line">        taskQueue-&gt;head = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环打印</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>24.thread_pool.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_queue</span>&#123;</span></span><br><span class="line">    <span class="comment">//循环队列</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">char</span> **data;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;<span class="comment">//检测是否又客人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_queue_init</span><span class="params">(struct task_queue *taskQueue, <span class="keyword">int</span> size)</span></span>;<span class="comment">//建立等待区，等待区又size大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_queue_push</span><span class="params">(struct task_queue *taskQueue, <span class="keyword">char</span> *str)</span></span>;<span class="comment">//str入队列</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">task_queue_pop</span><span class="params">(struct task_queue *taskQueue)</span></span>;<span class="comment">//str入队列</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;24.thread_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_work</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    pthread_detach(pthread_self());<span class="comment">//线程分离</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_queue</span> *<span class="title">taskQueue</span> =</span> (struct task_queue *)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *str = task_queue_pop(taskQueue);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%d&gt; : %s !\n&quot;</span>, pthread_self, str);<span class="comment">//线程拿到自己的id</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THREAD];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_queue</span> <span class="title">taskQueue</span>;</span></span><br><span class="line">    task_queue_init(&amp;taskQueue, QUEUE);</span><br><span class="line">    <span class="keyword">char</span> buff[QUEUE][<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD; i++) &#123;</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, do_work, (<span class="keyword">void</span> *) &amp;taskQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sub = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FILE *fp = fopen(<span class="string">&quot;./25.thread_pool_text.c&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fgets(buff[sub++], <span class="number">1024</span>, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            task_queue_push(&amp;taskQueue, buff[sub]);</span><br><span class="line">            <span class="keyword">if</span> (sub == QUEUE) &#123;</span><br><span class="line">                <span class="comment">//满了</span></span><br><span class="line">                sub = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (taskQueue.total == taskQueue.size) &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (taskQueue.total&lt; taskQueue.size) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    usleep(<span class="number">10000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="7-多线程编程基础"><a href="#7-多线程编程基础" class="headerlink" title="7.多线程编程基础"></a>7.多线程编程基础</h1><p>pthread_create产生线程</p>
<p>谁生的线程</p>
<p>线程模型</p>
<p>内核线程在内核上产生的</p>
<p>用户线程在用户空间上产生的</p>
<p>pthread_t线程ID</p>
<p>判断线程是否相等？</p>
<p>不能用线程ID判断，用pthread_equal</p>
<p>pthread_exit()线程自杀</p>
<p>pthread_cancel线程自杀</p>
<p>exit()</p>
<p>pthread_join()等待另一个线程结束，</p>
<p>成功0，</p>
<p>pthread_detach<br>标记一个分离的线程，线程结束后，所有的有关线程的内容都会被释放</p>
<p>同时分离同一个线程为被定义</p>
<p>attr线程属性</p>
<p>pthread_yield()</p>
<p>让出处理器，</p>
<h1 id="8-socket编程"><a href="#8-socket编程" class="headerlink" title="8.socket编程"></a>8.socket编程</h1><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%883.54.54.png" alt="截屏2021-01-29 下午3.54.54"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.06.49.png" alt="截屏2021-01-29 下午4.06.49"></p>
<p>连接的本质是双方都保存一些变量，用来描述双方之间的状态</p>
<p>端口是一种计算机设备，就像一个大楼(计算机)里面的一个房间，一个大楼都会有一个独立的地址，可能会与多个地址，如果有多个地址，端口就是具体的房间后</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.22.00.png" alt="截屏2021-01-29 下午4.22.00"></p>
<p>序列号：第几回发送</p>
<p>确认应答号：确认收到1可以发送2了</p>
<p>字：32位，4字节=1字</p>
<p>字节</p>
<p>RST=reset重置连接</p>
<p>SYN=1,对方收到包，建立请求连接，如果正确恢复SYN</p>
<p>SYN+ACK二次握手</p>
<p>ACK三次握手</p>
<p>FIN结束包</p>
<p>检验和：检验包是否有问题，</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/image-20210129163616346.png" alt="image-20210129163616346"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.40.49.png" alt="截屏2021-01-29 下午4.40.49"></p>
<p>TCP的本质是字节流</p>
<p>listen切换套接字主动为被动</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.46.27.png" alt="截屏2021-01-29 下午4.46.27"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.54.09.png" alt="截屏2021-01-29 下午4.54.09"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.02.56.png" alt="截屏2021-01-29 下午5.02.56"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.04.51.png" alt="截屏2021-01-29 下午5.04.51"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.14.09.png" alt="截屏2021-01-29 下午5.14.09"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.20.19.png" alt="截屏2021-01-29 下午5.20.19"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.22.03.png" alt="截屏2021-01-29 下午5.22.03"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.24.01.png" alt="截屏2021-01-29 下午5.24.01"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.25.23.png" alt="截屏2021-01-29 下午5.25.23"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.25.44.png" alt="截屏2021-01-29 下午5.25.44"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.26.03.png" alt="截屏2021-01-29 下午5.26.03"></p>
<p>26.tcp.server.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_create</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;<span class="comment">//创建套接字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    addr.sin_port = htons(port);<span class="comment">//主机字节序转换成本地字节序</span></span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd, <span class="number">20</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>27.tcp.server.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义函数接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_create</span><span class="params">(<span class="keyword">int</span> port)</span></span>;<span class="comment">//创建套接字，参数端口</span></span><br></pre></td></tr></table></figure>


<p>28.tcp.client.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_connect</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span></span>;</span><br></pre></td></tr></table></figure>


<p>29.tcp.client.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_connect</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(port);</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>30.tcp.main.server.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_listen, sockfd, port;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((server_listen = socket_create(port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sockfd = accept(server_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Something is online\n&quot;</span>);</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//支持并发</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                recv(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv : %s\n&quot;</span>, buff);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>32.tcp.main.client.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd, port;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, ip[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s is port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(ip, argv[<span class="number">1</span>]);</span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket_connect(ip, port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before loop!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, buff);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strlen</span>(buff)) <span class="keyword">continue</span>;</span><br><span class="line">        send(sockfd, buff, <span class="built_in">strlen</span>(buff), <span class="number">0</span>);</span><br><span class="line">        bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc 30.tcp.main.server.c 26.tcp.server.c -o 31.tcp.server</span><br><span class="line">gcc 32.tcp.main.client.c 29.tcp.client.c -o 33.tcp.client</span><br><span class="line"></span><br><span class="line">./31.tcp.server 9000                      [130]</span><br><span class="line">Something is online</span><br><span class="line">recv : hello</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line">./33.tcp.client 8.129.127.2 9000</span><br><span class="line">before loop!</span><br><span class="line">hello</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>




<h1 id="输入一个网址发生了什么？"><a href="#输入一个网址发生了什么？" class="headerlink" title="输入一个网址发生了什么？"></a>输入一个网址发生了什么？</h1><p>端口复用：</p>
<p>from IP</p>
<p>from port</p>
<p>to ip</p>
<p>to port</p>
<p>singnal</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//26.tcp.server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_create</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;<span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;<span class="comment">//创建套接字,ipv4，socker流</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//有太多的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;<span class="comment">//协议组 IPV4</span></span><br><span class="line">    addr.sin_port = htons(port);<span class="comment">//端口，主机字节序转换成本地字节序</span></span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>) &#123;<span class="comment">//绑定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//端口被占用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd, <span class="number">20</span>) &lt; <span class="number">0</span>) &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//27.tcp.server.h</span></span><br><span class="line"><span class="comment">//定义函数接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_create</span><span class="params">(<span class="keyword">int</span> port)</span></span>;<span class="comment">//创建套接字，参数端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//30.tcp.main.server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_listen, sockfd, port;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((server_listen = socket_create(port)) &lt; <span class="number">0</span>) &#123;<span class="comment">//创建套接字</span></span><br><span class="line">        perror(<span class="string">&quot;socket_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//用于等待接收数据</span></span><br><span class="line">        <span class="keyword">if</span> ((sockfd = accept(server_listen, (struct sockaddr *)&amp;client, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);<span class="comment">//三次握手失败</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; is online\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            close(server_listen);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//</span></span><br><span class="line">                <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">char</span> tobuff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">size_t</span> ret = recv(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; is offline\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                    perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv &lt;%s&gt;: %s\n&quot;</span>, inet_ntoa(client.sin_addr), buff);</span><br><span class="line">                <span class="built_in">sprintf</span>(tobuff, <span class="string">&quot;I&#x27;ve recvd your message : %s!\n&quot;</span>, buff);</span><br><span class="line">                send(sockfd, tobuff, <span class="built_in">strlen</span>(tobuff), <span class="number">0</span>);<span class="comment">//发送给客户端</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&lt;Parent&gt; : 什么也不gan。。。\n&quot;</span>);</span><br><span class="line">            close(sockfd);<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc <span class="number">30.</span>tcp.main.server.c <span class="number">26.</span>tcp.server.c -o <span class="number">31.</span>tcp.server</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//28.tcp.client.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_connect</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//29.tcp.client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_connect</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(port);</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//32.tcp.main.client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ByeBye\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, ip[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s is port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(ip, argv[<span class="number">1</span>]);</span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    signal(SIGINT, logout);</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket_connect(ip, port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before loop!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;please&gt; : &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, buff);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strlen</span>(buff)) <span class="keyword">continue</span>;</span><br><span class="line">        send(sockfd, buff, <span class="built_in">strlen</span>(buff), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sending %s ...\n&quot;</span>, buff);</span><br><span class="line">        bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">        recv(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;server&gt; : %s\n&quot;</span>, buff);</span><br><span class="line">        bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc <span class="number">32.</span>tcp.main.client.c <span class="number">29.</span>tcp.client.c -o <span class="number">33.</span>tcp.client</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./31.tcp.server 9000</span><br><span class="line">&lt;110.176.185.233&gt; is online</span><br><span class="line">&lt;Parent&gt; : 什么也不gan。。。</span><br><span class="line">recv &lt;110.176.185.233&gt;: hello</span><br><span class="line">recv &lt;110.176.185.233&gt;: hello 古子秋!</span><br><span class="line">&lt;110.176.185.233&gt; is offline</span><br><span class="line">recv: Success</span><br><span class="line"></span><br><span class="line">./33.tcp.client 8.129.127.2 9000</span><br><span class="line">before loop!</span><br><span class="line">&lt;please&gt; : hello</span><br><span class="line">sending hello ...</span><br><span class="line">&lt;server&gt; : I&#x27;ve recvd your message : hello!</span><br><span class="line"></span><br><span class="line">&lt;please&gt; : hello 古子秋!</span><br><span class="line">sending hello 古子秋! ...</span><br><span class="line">&lt;server&gt; : I&#x27;ve recvd your message : hello 古子秋!!</span><br><span class="line"></span><br><span class="line">&lt;please&gt; : ^CByeBye</span><br></pre></td></tr></table></figure>






<h1 id="0000000"><a href="#0000000" class="headerlink" title="0000000"></a>0000000</h1><h1 id="0作业"><a href="#0作业" class="headerlink" title="0作业"></a>0作业</h1><h2 id="0-1-作业1-ls实现"><a href="#0-1-作业1-ls实现" class="headerlink" title="0.1 作业1:ls实现"></a>0.1 作业1:ls实现</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%8811.11.26.png" alt="截屏2021-01-05 上午11.11.26"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="0-2-ls作业-gt-opendir"><a href="#0-2-ls作业-gt-opendir" class="headerlink" title="0.2 ls作业-&gt;opendir()"></a>0.2 ls作业-&gt;opendir()</h2><blockquote>
<p>opendir()</p>
<p>readdir()</p>
<p>closedir()</p>
<p>ftell()</p>
<p>readdir()</p>
</blockquote>
<p>man getpwpid getpwuid getgrgid</p>
<p>0</p>
<p>锁：数据保护，互斥，</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/fc73bb52fe85013f9d2b4713814cfa29.jpg" alt="fc73bb52fe85013f9d2b4713814cfa29"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="comment">//#define INS 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> num_file[] = <span class="string">&quot;./.num&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> lock_file[] = <span class="string">&quot;./.lock&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> <span class="title">num</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">set_num</span><span class="params">(struct Msg *msg)</span> </span>&#123;</span><br><span class="line">    FILE *f = fopen(num_file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(f);</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> nwrite = fwrite(msg, <span class="number">1</span>, <span class="keyword">sizeof</span>(struct Msg), f);</span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="keyword">return</span> nwrite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_num</span><span class="params">(struct Msg *msg)</span> </span>&#123;</span><br><span class="line">    FILE *f = fopen(num_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(f);</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> nread = fread(msg, <span class="number">1</span>, <span class="keyword">sizeof</span>(struct Msg), f);</span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="keyword">return</span> nread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_add</span><span class="params">(<span class="keyword">int</span> end, <span class="keyword">int</span> pid_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FILE *lock = fopen(lock_file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        flock(lock-&gt;_fileno, LOCK_EX);</span><br><span class="line">        <span class="keyword">if</span> (get_num(&amp;num) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fclose(lock);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num.now &gt; end) &#123;</span><br><span class="line">            fclose(lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num.sum += num.now;</span><br><span class="line">        num.now++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the %dth child : now = %d, sum = %d\n&quot;</span>, pid_num, num.now, num.sum);</span><br><span class="line">        set_num(&amp;num);</span><br><span class="line">        flock(lock-&gt;_fileno, LOCK_UN);</span><br><span class="line">        fclose(lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt, start = <span class="number">0</span>, end = <span class="number">0</span>, ins = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;s:e:i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            start = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            end = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            ins = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -s start_num -e end_num -i\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start = %d\n end = %d\n&quot;</span>, start, end);</span><br><span class="line"></span><br><span class="line">    num.now = <span class="number">0</span>;</span><br><span class="line">    num.sum = <span class="number">0</span>;</span><br><span class="line">    set_num(&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ins; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//孩子</span></span><br><span class="line">            x = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ins; i++) &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printf(&quot;I am father!\n&quot;);</span></span><br><span class="line">        <span class="comment">//sleep(100);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        do_add(end, x);</span><br><span class="line">    &#125;</span><br><span class="line">    get_num(&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, num.sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a.out -s 0 -e 100 -i 10                                                                   [0]</span><br><span class="line">start = 0</span><br><span class="line"> end = 100</span><br><span class="line">the 1th child : now = 1, sum = 0</span><br><span class="line">the 7th child : now = 2, sum = 1</span><br><span class="line">the 1th child : now = 3, sum = 3</span><br><span class="line">the 7th child : now = 4, sum = 6</span><br><span class="line">the 1th child : now = 5, sum = 10</span><br><span class="line">the 7th child : now = 6, sum = 15</span><br><span class="line">the 1th child : now = 7, sum = 21</span><br><span class="line">the 7th child : now = 8, sum = 28</span><br><span class="line">the 1th child : now = 9, sum = 36</span><br><span class="line">the 7th child : now = 10, sum = 45</span><br><span class="line">the 1th child : now = 11, sum = 55</span><br><span class="line">the 7th child : now = 12, sum = 66</span><br><span class="line">the 7th child : now = 13, sum = 78</span><br><span class="line">the 7th child : now = 14, sum = 91</span><br><span class="line">the 1th child : now = 15, sum = 105</span><br><span class="line">the 7th child : now = 16, sum = 120</span><br><span class="line">the 1th child : now = 17, sum = 136</span><br><span class="line">the 7th child : now = 18, sum = 153</span><br><span class="line">the 1th child : now = 19, sum = 171</span><br><span class="line">the 2th child : now = 20, sum = 190</span><br><span class="line">the 1th child : now = 21, sum = 210</span><br><span class="line">the 1th child : now = 22, sum = 231</span><br><span class="line">the 3th child : now = 23, sum = 253</span><br><span class="line">the 1th child : now = 24, sum = 276</span><br><span class="line">the 3th child : now = 25, sum = 300</span><br><span class="line">the 1th child : now = 26, sum = 325</span><br><span class="line">the 3th child : now = 27, sum = 351</span><br><span class="line">the 1th child : now = 28, sum = 378</span><br><span class="line">the 3th child : now = 29, sum = 406</span><br><span class="line">the 1th child : now = 30, sum = 435</span><br><span class="line">the 6th child : now = 31, sum = 465</span><br><span class="line">the 1th child : now = 32, sum = 496</span><br><span class="line">the 3th child : now = 33, sum = 528</span><br><span class="line">the 1th child : now = 34, sum = 561</span><br><span class="line">the 6th child : now = 35, sum = 595</span><br><span class="line">the 1th child : now = 36, sum = 630</span><br><span class="line">the 3th child : now = 37, sum = 666</span><br><span class="line">the 1th child : now = 38, sum = 703</span><br><span class="line">the 6th child : now = 39, sum = 741</span><br><span class="line">the 1th child : now = 40, sum = 780</span><br><span class="line">the 2th child : now = 41, sum = 820</span><br><span class="line">the 1th child : now = 42, sum = 861</span><br><span class="line">the 2th child : now = 43, sum = 903</span><br><span class="line">the 2th child : now = 44, sum = 946</span><br><span class="line">the 3th child : now = 45, sum = 990</span><br><span class="line">the 2th child : now = 46, sum = 1035</span><br><span class="line">the 1th child : now = 47, sum = 1081</span><br><span class="line">the 2th child : now = 48, sum = 1128</span><br><span class="line">the 2th child : now = 49, sum = 1176</span><br><span class="line">the 1th child : now = 50, sum = 1225</span><br><span class="line">the 2th child : now = 51, sum = 1275</span><br><span class="line">the 1th child : now = 52, sum = 1326</span><br><span class="line">the 2th child : now = 53, sum = 1378</span><br><span class="line">the 1th child : now = 54, sum = 1431</span><br><span class="line">the 7th child : now = 55, sum = 1485</span><br><span class="line">the 7th child : now = 56, sum = 1540</span><br><span class="line">the 7th child : now = 57, sum = 1596</span><br><span class="line">the 1th child : now = 58, sum = 1653</span><br><span class="line">the 6th child : now = 59, sum = 1711</span><br><span class="line">the 1th child : now = 60, sum = 1770</span><br><span class="line">the 2th child : now = 61, sum = 1830</span><br><span class="line">the 1th child : now = 62, sum = 1891</span><br><span class="line">the 1th child : now = 63, sum = 1953</span><br><span class="line">the 1th child : now = 64, sum = 2016</span><br><span class="line">the 4th child : now = 65, sum = 2080</span><br><span class="line">the 1th child : now = 66, sum = 2145</span><br><span class="line">the 4th child : now = 67, sum = 2211</span><br><span class="line">the 1th child : now = 68, sum = 2278</span><br><span class="line">the 4th child : now = 69, sum = 2346</span><br><span class="line">the 1th child : now = 70, sum = 2415</span><br><span class="line">the 4th child : now = 71, sum = 2485</span><br><span class="line">the 1th child : now = 72, sum = 2556</span><br><span class="line">the 4th child : now = 73, sum = 2628</span><br><span class="line">the 1th child : now = 74, sum = 2701</span><br><span class="line">the 4th child : now = 75, sum = 2775</span><br><span class="line">the 4th child : now = 76, sum = 2850</span><br><span class="line">the 1th child : now = 77, sum = 2926</span><br><span class="line">the 4th child : now = 78, sum = 3003</span><br><span class="line">the 1th child : now = 79, sum = 3081</span><br><span class="line">the 3th child : now = 80, sum = 3160</span><br><span class="line">the 1th child : now = 81, sum = 3240</span><br><span class="line">the 2th child : now = 82, sum = 3321</span><br><span class="line">the 1th child : now = 83, sum = 3403</span><br><span class="line">the 1th child : now = 84, sum = 3486</span><br><span class="line">the 6th child : now = 85, sum = 3570</span><br><span class="line">the 6th child : now = 86, sum = 3655</span><br><span class="line">the 4th child : now = 87, sum = 3741</span><br><span class="line">the 3th child : now = 88, sum = 3828</span><br><span class="line">the 1th child : now = 89, sum = 3916</span><br><span class="line">the 2th child : now = 90, sum = 4005</span><br><span class="line">the 1th child : now = 91, sum = 4095</span><br><span class="line">the 2th child : now = 92, sum = 4186</span><br><span class="line">the 1th child : now = 93, sum = 4278</span><br><span class="line">the 3th child : now = 94, sum = 4371</span><br><span class="line">the 4th child : now = 95, sum = 4465</span><br><span class="line">the 6th child : now = 96, sum = 4560</span><br><span class="line">the 6th child : now = 97, sum = 4656</span><br><span class="line">the 6th child : now = 98, sum = 4753</span><br><span class="line">the 4th child : now = 99, sum = 4851</span><br><span class="line">the 6th child : now = 100, sum = 4950</span><br><span class="line">the 1th child : now = 101, sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br></pre></td></tr></table></figure>
<p>flock</p>
<h1 id="1-作业2"><a href="#1-作业2" class="headerlink" title="1.作业2"></a>1.作业2</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令.&#x2F;test -m &quot;msg&quot;</span><br><span class="line">结果输出：msg</span><br><span class="line">命令.&#x2F;test</span><br><span class="line">vim a.txt</span><br><span class="line">input msg</span><br><span class="line">printf msg</span><br><span class="line">delete a.txt</span><br><span class="line">模拟过程，可能需要3个进程</span><br></pre></td></tr></table></figure>


<p>ls，ls -al,</p>
<p>分列显示，有排序</p>
<p>显示/不显示隐藏文件，</p>
<h1 id="0-end"><a href="#0-end" class="headerlink" title="0.end"></a>0.end</h1>]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
