<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="关键字" />
   
  <meta name="description" content="说明" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    网络编程 |  古子秋
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-06.网络编程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  网络编程
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/12/29/06.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-12-29T00:08:15.000Z" itemprop="datePublished">2020-12-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">21.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">90 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>2020.12.29</p>
<p>说明:本文档的部分图片来至于开课吧宿船长PPT</p>
</blockquote>
<h1 id="一、系统编程"><a href="#一、系统编程" class="headerlink" title="一、系统编程"></a>一、系统编程</h1><h1 id="1-Linux下命令行解析"><a href="#1-Linux下命令行解析" class="headerlink" title="1.Linux下命令行解析"></a>1.Linux下命令行解析</h1><h2 id="1-getopt函数"><a href="#1-getopt函数" class="headerlink" title="1.getopt函数"></a>1.getopt函数</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.48.49.png" alt="截屏2021-01-05 上午9.48.49" style="zoom:80%;" />



<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.58.40.png" alt="截屏2021-01-05 上午9.58.40"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.58.59.png" alt="截屏2021-01-05 上午9.58.59"></p>
<h2 id="2-getopt函数代码演示"><a href="#2-getopt函数代码演示" class="headerlink" title="2.getopt函数代码演示"></a>2.getopt函数代码演示</h2><h3 id="演示1"><a href="#演示1" class="headerlink" title="演示1"></a>演示1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;al&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">//循环把参数读入opt中，直到函数返回值为-1</span></span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a found!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;l found!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -al\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>




<p>编译后运行结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./a.out ls -al -d                                                                                        </span><br><span class="line">a found!</span><br><span class="line">l found!</span><br><span class="line">./a.out: invalid option -- <span class="string">&#x27;d&#x27;</span></span><br><span class="line">Usage : ./a.out -al</span><br></pre></td></tr></table></figure>


<h3 id="演示2：可选和不可选参数"><a href="#演示2：可选和不可选参数" class="headerlink" title="演示2：可选和不可选参数"></a>演示2：可选和不可选参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;alm:o::&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a found!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;l found!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg = %s \n&quot;</span>, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;opt = %s\n&quot;</span>, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -al\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">运行结果</span></span><br><span class="line">./a.out -m &quot;lsm1&quot; -m&quot;lsm2&quot; -o&quot;lso1&quot; -o &quot;lso2&quot;               </span><br><span class="line">msg = lsm1</span><br><span class="line">msg = lsm2</span><br><span class="line">opt = lso1</span><br><span class="line">opt = (null)</span><br><span class="line"><span class="meta">#</span><span class="bash">加入m后面没有参数</span></span><br><span class="line">./a.out   -m              </span><br><span class="line">./a.out: option requires an argument -- &#x27;m&#x27;</span><br><span class="line">Usage : ./a.out -al</span><br></pre></td></tr></table></figure>




<h2 id="3-extern"><a href="#3-extern" class="headerlink" title="3.extern"></a>3.extern</h2><h2 id="4-optind-optopt"><a href="#4-optind-optopt" class="headerlink" title="4.optind,optopt"></a>4.optind,optopt</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;optind = %d \noptopt = %d\n&quot;</span>, optind, optopt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行结果</span></span><br><span class="line">optind = 1</span><br><span class="line">optopt = 0</span><br></pre></td></tr></table></figure>






<h1 id="2-文件与IO"><a href="#2-文件与IO" class="headerlink" title="2.文件与IO"></a>2.文件与IO</h1><h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h2><blockquote>
<p>所有执行 I/O 操作的系统调用都以文件描述符，一个非负整数（通常是小整数），来指代 打开的文件。文件描述符用以表示所有类型的已打开文件，包括管道（pipe）、FIFO、socket、终端、 设备和普通文件。针对每个进程，文件描述符都自成一套。</p>
</blockquote>
<blockquote>
<p>按照惯例，大多数程序都期望能够使用 3 种标准的文件描述符，见表 4-1。在程序开始运 行之前，shell 代表程序打开这 3 个文件描述符。更确切地说，程序继承了 shell 文件描述符的 副本—在 shell 的日常操作中，这 3 个文件描述符始终是打开的。（在交互式 shell 中，这 3 个文件描述符通常指向 shell 运行所在的终端。）如果命令行指定对输入/输出进行重定向操作， 那么 shell 会对文件描述符做适当修改，然后再启动程序。</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%883.51.09.png" alt="截屏2021-01-07 下午3.51.09"></p>
<p>下面介绍执行文件 I/O 操作的 4 个主要系统调用（编程语言和软件包通常会利用 I/O 函数 库对它们进行间接调用）。 </p>
<ol>
<li> fd = open(pathname, flags, mode) 函数打开 pathname 所标识的文件，并返回文件描 述符，用以在后续函数调用中指代打开的文件。如果文件不存在，open()函数可以 创建之，这取决于对位掩码参数 flags 的设置。flags 参数还可指定文件的打开方式：只 读、只写亦或是读写方式。mode 参数则指定了由 open()调用创建文件的访问权限， 如果 open()函数并未创建文件，那么可以忽略或省略 mode 参数。 </li>
</ol>
<ol start="2">
<li>numread = read(fd, buffer, count) 调用从 fd 所指代的打开文件中读取至多 count 字节的 数据，并存储到 buffer 中。read()调用的返回值为实际读取到的字节数。如果再无字节 可读（例如：读到文件结尾符 EOF 时），则返回值为 0。 </li>
</ol>
<ol start="3">
<li>numwritten = write(fd, buffer, count) 调用从 buffer 中读取多达 count 字节的数据写入由 fd 所指代的已打开文件中。write()调用的返回值为实际写入文件中的字节数，且有可 能小于 count。 </li>
</ol>
<ol start="4">
<li>status = close(fd)在所有输入/输出操作完成后，调用 close()，释放文件描述符 fd 以及 与之相关的内核资源。</li>
</ol>
<h2 id="1-打开一个文件-open函数"><a href="#1-打开一个文件-open函数" class="headerlink" title="1.打开一个文件:open函数"></a>1.打开一个文件:open函数</h2><h3 id="1-open简介"><a href="#1-open简介" class="headerlink" title="1.open简介"></a>1.open简介</h3><p><code>int open(const char *pathname, int flags)</code></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%883.55.29.png" alt="截屏2021-01-07 下午3.55.29"></p>
<p>​        </p>
<p>​        要打开的文件由参数 pathname 来标识。如果 pathname 是一符号链接，会对其进行解引用。 如果调用成功，open()将返回一文件描述符，用于在后续函数调用中指代该文件。若发生错误， 则返回−1，并将 errno 置为相应的错误标志。</p>
<p>​        </p>
<p>​        参数 flags 为位掩码，用于指定文件的访问模式，</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%883.57.06.png" alt="截屏2021-01-07 下午3.57.06"></p>
<p>​        </p>
<p>​        当调用 open()创建新文件时，位掩码参数 mode 指定了文件的访问权限。（SUSv3 规定，mode 的数据类型 mode_t 属于整数类型。）如果 open()并未指定 O_CREAT 标志，则可以省略 mode 参数。</p>
<p>​        SUSv3 规定，如果调用 open()成功，必须保证其返回值为进程未用文件描述符中数值最 小者。可以利用该特性以特定文件描述符打开某一文件。</p>
<h3 id="2-open-调用中的-flags-参数"><a href="#2-open-调用中的-flags-参数" class="headerlink" title="2.open()调用中的 flags 参数"></a>2.open()调用中的 flags 参数</h3><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.07.42.png" alt="截屏2021-01-07 下午4.07.42"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.13.14.png" alt="截屏2021-01-07 下午4.13.14"></p>
<h3 id="3-open-函数的错误"><a href="#3-open-函数的错误" class="headerlink" title="3.open()函数的错误"></a>3.open()函数的错误</h3><p>若打开文件时发生错误，open()将返回−1，错误号 errno 标识错误原因。以下是一些可能 发生的错误（除了在上节参数描述中已经提及的错误之外）。 </p>
<p>EACCES </p>
<p>​        文件权限不允许调用进程以 flags 参数指定的方式打开文件。无法访问文件，其可能的原 因有目录权限的限制、文件不存在并且也无法创建该文件。 </p>
<p>EISDIR </p>
<p>​        所指定的文件属于目录，而调用者企图打开该文件进行写操作。不允许这种用法。</p>
<p> EMFILE </p>
<p>​        进程已打开的文件描述符数量达到了进程资源限制所设定的上限</p>
<p> ENFILE </p>
<p>​        文件打开数量已经达到系统允许的上限。 </p>
<p>ENOENT </p>
<p>​        要么文件不存在且未指定 O_CREAT 标志，要么指定了 O_CREAT 标志，但 pathname 参数所指定路径的目录之一不存在，或者 pathname 参数为符号链接，而该链接指向的文件不存 在（空链接）。</p>
<p>EROFS </p>
<p>​        所指定的文件隶属于只读文件系统，而调用者企图以写方式打开文件。 </p>
<p>ETXTBSY </p>
<p>​        所指定的文件为可执行文件（程序），且正在运行。系统不允许修改正在运行的程序（比如 以写方式打开文件）。（必须首先终止程序运行，然后方可修改可执行文件。）</p>
<h3 id="4-open代码演示"><a href="#4-open代码演示" class="headerlink" title="4.open代码演示"></a>4.open代码演示</h3><blockquote>
<p><code>open, read, write, close</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;./a.txt&quot;</span>, O_CREAT | O_RDONLY)) &lt; <span class="number">0</span>) &#123;<span class="comment">//打开文件</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//return 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((nread = read(fd, buff, <span class="keyword">sizeof</span>(buff))) &gt; <span class="number">0</span>) &#123;<span class="comment">//从fd读入到buff，每次的大小为buff的大小</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %ld\n buffer =  %s&quot;</span>, nread, buff);</span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>perror : perror - print a system error message</code></p>
<p>打印系统错误信息</p>
<h2 id="2-读取文件内容-read"><a href="#2-读取文件内容-read" class="headerlink" title="2.读取文件内容:read()"></a>2.读取文件内容:read()</h2><blockquote>
<p>read()系统调用从文件描述符 fd 所指代的打开文件中读取数据。</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.15.35.png" alt="截屏2021-01-07 下午4.15.35"></p>
<p>​        count 参数指定最多能读取的字节数。（size_t 数据类型属于无符号整数类型。）buffer 参数提供用来存放输入数据的内存缓冲区地址。缓冲区至少应有 count 个字节。</p>
<p>​        如果 read()调用成功，将==返回实际读取的字节数==，如果遇到文件结束（EOF）则返回 0， 如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数 或-1（表示错误）。</p>
<p>​        一次 read()调用所读取的字节数可以小于请求的字节数。对于普通文件而言，这有可能是 因为当前读取位置靠近文件尾部。 </p>
<p>​        当 read()应用于其他文件类型时，比如管道、FIFO、socket 或者终端，在不同环境下也会 出现 read()调用读取的字节数小于请求字节数的情况。</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.22.37.png" alt="截屏2021-01-07 下午4.22.37"></p>
<h2 id="3-数据写入文件-write"><a href="#3-数据写入文件-write" class="headerlink" title="3.数据写入文件:write()"></a>3.数据写入文件:write()</h2><blockquote>
<p>write()系统调用将数据写入一个已打开的文件中。</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.24.18.png" alt="截屏2021-01-07 下午4.24.18"></p>
<p>​        write()调用的参数含义与 read()调用相类似。buffer 参数为要写入文件中数据的内存地址，count 参数为欲从 buffer 写入文件的数据字节数，fd 参数为一文件描述符，指代数据要写入的文件。 </p>
<p>​        如果 write()调用成功，将返回实际写入文件的字节数，该返回值可能小于 count 参数值。 这被称为“部分写”。对磁盘文件来说，造成“部分写”的原因可能是由于磁盘已满，或是因 为进程资源对文件大小的限制。 </p>
<p>​        对磁盘文件执行 I/O 操作时，write()调用成功并不能保证数据已经写入磁盘。因为为了减 少磁盘活动量和加快 write()系统调用，内核会缓存磁盘的 I/O 操作。</p>
<h2 id="4-关闭文件：close"><a href="#4-关闭文件：close" class="headerlink" title="4.关闭文件：close()"></a>4.关闭文件：close()</h2><blockquote>
<p>​        close()系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。 当一进程终止时，将自动关闭其已打开的所有文件描述符。</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.26.46.png" alt="截屏2021-01-07 下午4.26.46"></p>
<p>​        显式关闭不再需要的文件描述符往往是良好的编程习惯，会使代码在后续修改时更具可 读性，也更可靠。进而言之，文件描述符属于有限资源，因此文件描述符关闭失败可能会导 致一个进程将文件描述符资源消耗殆尽。在编写需要长期运行并处理大量文件的程序时，比 如 shell 或者网络服务器软件，需要特别加以关注。</p>
<p>小结：为了对普通文件执行 I/O 操作，首先必须调用 open()以获得一个文件描述符。随之使用 read()和 write()执行文件的 I/O 操作，然后应使用 close()释放文件描述符及相关资源。这些系 统调用可对所有类型的文件执行 I/O 操作。 所有类型的文件和设备驱动都实现了相同的 I/O 接口，这保证了 I/O 操作的通用性，同时 也意味着在无需针对特定文件类型编写代码的情况下，程序通常就能操作所有类型的文件。</p>
<h2 id="5-fopen函数"><a href="#5-fopen函数" class="headerlink" title="5.fopen函数"></a>5.fopen函数</h2><blockquote>
<p><code>fopen, fwrite, fread, fclose</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;./b.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);<span class="comment">//fopen: No such file or directory</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//循环读入，直到文件结尾</span></span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">size_t</span> nread = fread(buff, <span class="number">1</span>, <span class="keyword">sizeof</span>(buff), fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line">        <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>标准IO都是缓冲IO</p>
<p>标准错误输出都会无缓冲输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep()库函数可将当前执行的进程挂起指定的秒数。</p>
<h1 id="3-阻塞IO与非阻塞IO"><a href="#3-阻塞IO与非阻塞IO" class="headerlink" title="3.阻塞IO与非阻塞IO"></a>3.阻塞IO与非阻塞IO</h1><h2 id="1-阻塞和非阻塞的概念"><a href="#1-阻塞和非阻塞的概念" class="headerlink" title="1.阻塞和非阻塞的概念"></a>1.阻塞和非阻塞的概念</h2><blockquote>
<p>什么是阻塞、什么是非阻塞</p>
</blockquote>
<p>阻塞操作是指在执行设备操作时若不能获得资源则挂起进程，直到满足可操作的条件后再进行操作。被挂起的进程进入休眠状态，被从调度器的运行队列移走，直到等待的条件被满足。非阻塞操作的进程在不能进行设备操作时并不挂起，它或者放弃，或者不停地查询，直至可以进行操作为止。</p>
<p>阻塞就是数据给了内核，内核没有返回结果之前，你必须等待。非阻塞就是数据给了内核，不论结果如何。</p>
<p>阻塞的代价：必须等待，等待会占用系统资源</p>
<p>非阻塞的优点：不会占用系统资源</p>
<p>非阻塞的代价</p>
<h2 id="2-对阻塞非阻塞的理解"><a href="#2-对阻塞非阻塞的理解" class="headerlink" title="2.对阻塞非阻塞的理解"></a>2.对阻塞非阻塞的理解</h2><blockquote>
<p>废话不说，老张爱喝茶，煮开水，有两个水壶，普通水壶，响水壶（水开会提示）</p>
</blockquote>
<p><strong>同步</strong>就是普通水壶烧开水，要没事儿自己过来来看开没开；<br><strong>异步</strong>就是响水壶烧开水，水开了水壶响了通知你。<br><strong>阻塞</strong>是烧开水的过程中，你不能干其他事情（即你被阻塞住了），只能站那等水开；<br><strong>非阻塞</strong>是烧开水的过程里可以干其他事情。比如去客厅看看电视；</p>
<blockquote>
<p>同步与异步说的是你获得水开了的方式不同。<br>阻塞与非阻塞说的是你得到结果之前能不能干其他事情。<br>两组概念描述的是不同的内容。</p>
</blockquote>
<p>这里你看明白了，就会发现：</p>
<blockquote>
<p>效率最高的办法是 <strong>响水壶烧水（异步）</strong><br><strong>水烧开提示你之前可以去干别的事儿（非阻塞）</strong><br>等到水开了提示你你再去拿水<br>所以异步和非阻塞常常在一起大大提高每个线程的效率</p>
</blockquote>
<p>摘自<a target="_blank" rel="noopener" href="https://blog.csdn.net/evanxuhe/article/details/79627709">阻塞</a></p>
<h2 id="3-非阻塞IO有什么用"><a href="#3-非阻塞IO有什么用" class="headerlink" title="3.非阻塞IO有什么用"></a>3.非阻塞IO有什么用</h2><p>当我们告诉内核，如果数据没有到来，你立马给我返回，不用等待数据了。设置成非阻塞的方法如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);   <span class="comment">//设置成非阻塞模式；</span></span><br></pre></td></tr></table></figure>
<p>其实非阻塞模式的使用并不普遍，因为非阻塞模式会浪费大量的CPU资源。、</p>
<p>用户态下沉到内核态</p>
<p>内核是一个快缓冲</p>
<p>fcntl</p>
<h2 id="4-fcntl"><a href="#4-fcntl" class="headerlink" title="4.fcntl()"></a>4.fcntl()</h2><p>fcntl()系统调用对一个打开的文件描述符执行一系列控制操作。</p>
<p>函数原型</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%8810.55.21.png" alt="截屏2021-01-08 上午10.55.21"></p>
<p>函数描述</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%8810.55.49.png" alt="截屏2021-01-08 上午10.55.49"></p>
<p>​        cmd 参数所支持的操作范围很广。</p>
<p>​        fcntl()的第三个参数以省略号来表示，这意味着可以将其设置为不同的类型，或者加以省 略。内核会依据 cmd 参数（如果有的话）的值来确定该参数的数据类型。</p>
<p>​        fcntl()的用途之一是针对一个打开的文件，获取或修改其访问模式和状态标志（这些值是 通过指定 open()调用的 flag 参数来设置的）。要获取这些设置，应将 fcntl()的 cmd 参数设置为 F_GETFL。</p>
<p>fcntl函数有5种功能：</p>
<p>　 1.复制一个现有的描述符（cmd=F_DUPFD）.</p>
<p>　 2.获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD).</p>
<p>​      3.获得／设置文件状态标记(cmd=F_GETFL或F_SETFL).</p>
<p>​      4.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN).</p>
<p>​      5.获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW).</p>
<h2 id="5-fcntl-代码演示"><a href="#5-fcntl-代码演示" class="headerlink" title="5.fcntl()代码演示"></a>5.fcntl()代码演示</h2><h3 id="1-00-head-h"><a href="#1-00-head-h" class="headerlink" title="1.00.head.h"></a>1.00.head.h</h3><p>头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;05.common.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-04-common-c"><a href="#2-04-common-c" class="headerlink" title="2.04.common.c"></a>2.04.common.c</h3><p>阻塞与非阻塞的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_nonblock</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;<span class="comment">//设置非阻塞</span></span><br><span class="line">    <span class="comment">//fcntl(fd, F_SETFL, O_NONBLOCK);</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">if</span> ((flag = fcntl(fd, F_GETFL)) &lt; <span class="number">0</span>) &#123;<span class="comment">//获得文件状态标记</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag |= O_NONBLOCK;<span class="comment">//flag = O_NONBLOCK,以非阻塞方式打开，在原先flag的基础加上非阻塞方式</span></span><br><span class="line">    <span class="keyword">return</span> fcntl(fd, F_SETFL, flag);<span class="comment">//设置文件状态标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_block</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;<span class="comment">//设置阻塞方式</span></span><br><span class="line">    <span class="comment">//fcntl(fd, F_SETFL, O_NONBLOCK);</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">if</span> ((flag = fcntl(fd, F_GETFL)) &lt; <span class="number">0</span>) &#123;<span class="comment">//获得文件状态标记flag</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag &amp;= ~O_NONBLOCK;<span class="comment">//flag = O_NONBLOCK,以非阻塞方式打开，设置非阻塞方式</span></span><br><span class="line">    <span class="keyword">return</span> fcntl(fd, F_SETFL, flag);<span class="comment">//设置文件状态标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-05-common-h"><a href="#3-05-common-h" class="headerlink" title="3.05.common.h"></a>3.05.common.h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifdef _COMMON_H</span><br><span class="line">#define _COMMON_H</span><br><span class="line">int make_nonblock(int fd);</span><br><span class="line">int make_block(int fd);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="4-07-testblock-c"><a href="#4-07-testblock-c" class="headerlink" title="4.07.testblock.c"></a>4.07.testblock.c</h3><p>//测试阻塞和非阻塞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="comment">//test1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_nonblock</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    make_nonblock(<span class="number">0</span>);<span class="comment">//设置当前文件打开方式为非阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;guziqiu is %d years old!, ret = %d \n&quot;</span>, age, ret);</span><br><span class="line">    perror(<span class="string">&quot;scanf&quot;</span>);<span class="comment">//打印scanf错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">guziqiu is <span class="number">-151492080</span> years old!, ret = <span class="number">-1</span></span><br><span class="line"><span class="built_in">scanf</span>: Resource temporarily unavailable</span><br><span class="line">  <span class="comment">//sacnf返回值是成功读入变量的个数，-1为报错</span></span><br><span class="line">  <span class="comment">//文件资源占时不可访问</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">//test 2 </span></span><br><span class="line"><span class="keyword">int</span> make_nonblock(<span class="keyword">int</span> fd);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    make_nonblock(<span class="number">0</span>);<span class="comment">//设置当前文件打开方式为非阻塞</span></span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;guziqiu is %d years old!, ret = %d \n&quot;</span>, age, ret);</span><br><span class="line">    perror(<span class="string">&quot;scanf&quot;</span>);<span class="comment">//打印scanf错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line">guziqiu is <span class="number">18</span> years old!, ret = <span class="number">1</span></span><br><span class="line"><span class="built_in">scanf</span>: Success</span><br></pre></td></tr></table></figure>


<h2 id="6-select"><a href="#6-select" class="headerlink" title="6.select()"></a>6.select()</h2><p>部分内容来至于<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57518857">linux select函数解析以及事例</a></p>
<h3 id="6-1select详解"><a href="#6-1select详解" class="headerlink" title="6.1select详解"></a>6.1select详解</h3><p>IO感知</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8B%E5%8D%884.25.54.png" alt="截屏2021-01-08 下午4.25.54"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfd, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">nfds：被监听的文件描述符的总数，它比所有文件描述符集合中的文件描述符的最大值大1，因为文件描述符是从0开始计数的；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">readfds、writefds、exceptset：分别指向可读、可写和异常等事件对应的描述符集合。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">timeout:用于设置select函数的超时时间，即告诉内核select等待多长时间之后就放弃等待。timeout == NULL 表示等待无限长的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<p>参数说明</p>
<ul>
<li>nfds：是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错。在linux系统中，select的默认最大值为1024。设置这个值的目的是为了不用每次都去轮询这1024个fd，假设我们只需要几个套接字，我们就可以用最大的那个套接字的值加上1作为这个参数的值，当我们在等待是否有套接字准备就绪时，只需要监测maxfd+1个套接字就可以了，这样可以减少轮询时间以及系统的开销。</li>
<li>readfds：首先需要明白，fd_set是什么数据类型，有一点像int，又有点像struct，其实，fd_set声明的是一个集合，也就是说，readfs是一个容器，里面可以容纳多个文件描述符，把==需要监视的描述符==放入这个集合中，==当有文件描述符可读时，select就会返回一个大于0的值，表示有文件可读==；</li>
<li>writefds：和readfs类似，表示有一个==可写的文件描述符==集合，当有文件可写时，select就会返回一个大于0的值，表示有文件可写；</li>
<li>fd_set*errorfds同上面两个参数的意图，用来==监视文件错误异常文件==。</li>
<li>timeout：这个参数一出来就可以知道，可以选择阻塞，可以选择非阻塞，还可以选择定时返回。当将timeout置为NULL时，表明此时select是阻塞的；当将tineout设置为timeout-&gt;tv_sec = 0，timeout-&gt;tv_usec = 0时，表明这个函数为非阻塞；当将timeout设置为非0的时间，表明select有超时时间，当这个时间走完，select函数就会返回。从这个角度看，个人觉得可以用select来做超时处理，因为你如果使用recv函数的话，你还需要去设置recv的模式，麻烦的很。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span>      </span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> tv_sec;   <span class="comment">/*秒 */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> tv_usec;  <span class="comment">/*微秒 */</span>   </span><br><span class="line"></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>返回值：超时返回0;失败返回-1；成功返回大于0的整数，这个整数表示就绪描述符的数目</p>
<p>fd_set的几个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//一个 fd_set类型变量的所有位都设为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//清除某个位时可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">//设置变量的某个位置位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//测试某个位是否被置位</span></span><br></pre></td></tr></table></figure>


<p>对fd_set的理解：fd_set可以理解为一个集合，那么集合就会有一个数量，在&lt;sys/select.h&gt;总定义了一个常量FD_SETSIZE，默认为1024，也就是说在这个集合内默认最多有1024个文件描述符，但是通常你用不了这么多，你通常只是关心nfds个描述符。也就是说你现在有nfds个文件描述符在这个集合里，那么我怎么知道集合里的哪个文件描述符有消息来了呢？你可以将fd_set中的集合看成是二进制bit位，一位代表着一个文件描述符。==0代表文件描述符处于睡眠状态，没有数据到来；1代表文件描述符处于准备状态，可以被应用层处理。==我觉得select函数可以分下面几步进行理解</p>
<ol>
<li>在你开始监测这些描述符时，你先将这些文件描述符全部置为0</li>
<li>当你需要监测的描述符置为1</li>
<li>使用select函数监听置为1的文件描述符是否有数据到来</li>
<li>==当状态为1的文件描述符有数据到来时，此时你的状态仍然为1，但是其他状态为1的文件描述如果没有数据到来，那么此时会将这些文件描述符置为0==</li>
<li>当select函数返回后，可能有一个或者多个文件描述符为1，那么你怎么知道是哪个文件描述符准备好了呢？其实select并不会告诉你说，我哪个文件描述符准备好了，他只会告诉你他的那些bit为位哪些是0，哪些是1。也就是说你需要自己用逻辑去判断你要的那个文件描是否准备好了</li>
</ol>
<p>理解了上面几步的话，下面这些宏就比较好理解了。</p>
<ul>
<li>FD_ZERO：将指定集合里面所有的描述符全部置为0，==在对文件描述符集合进行设置前，必须对其进行初始化==，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的</li>
<li>FD_SET：用于在文件描述符集合中增加一个新的文件描述符，将相应的位置置为1</li>
<li>FD_CLR：用来清除集合里面的某个文件描述符</li>
<li>FD_ISSET：用来检测指定的某个描述符是否有数据到来。- 那么假如在我们的程序中有5个客户端已经连接上了服务器，这个时候突然有一条数据过来了。select返回了，但是此时你并不知道是哪个客户发过来的消息，因为你每个客户发过来的消息都是一样重要的。所以你没法去只针对一个套接字使用FD_ISSET，你需要做的是用一个循环去检测（FD_ISSET）到底是哪一个客户发过来的消息，因为如果此时你监测一个套接字的话，其他客户的信息你会丢失。这个也是select的一个缺点，你需要去检测所有的套接字，看看这个套接字到底是谁来的数据。</li>
</ul>
<h3 id="6-2对fd-set的理解"><a href="#6-2对fd-set的理解" class="headerlink" title="6.2对fd_set的理解"></a>6.2对fd_set的理解</h3><p>理解select模型的关键在于理解fd_set,为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。</p>
<p>（1）执行fd_set set; FD_ZERO(&amp;set); 则set用位表示是0000,0000。</p>
<p>（2）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1)</p>
<p>（3）若再加入fd＝2，fd=1,则set变为0001,0011</p>
<p>（4）执行select(6,&amp;set,0,0,0)阻塞等待</p>
<p>（5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。</p>
<p>内容来自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skyfsm/p/7079458.html">Linux编程之select</a></p>
<h3 id="6-3select代码演示"><a href="#6-3select代码演示" class="headerlink" title="6.3select代码演示"></a>6.3select代码演示</h3><p><strong>select的使用流程</strong></p>
<p>1.先调用宏FD_ZERO将指定的fd_set清零，</p>
<p>2.然后调用宏FD_SET将需要测试的fd加入fd_set，</p>
<p>3.接着调用函数select监测fd_set中的所有fd，</p>
<p>4.最后用宏FD_ISSET检查某个fd在函数select调用后，相应位是否仍然为1，然后做相应的逻辑处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    fd_set rfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Watch stdin (fd 0) to see when it has input. */</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;rfds);<span class="comment">//将rdfs的fd_set清零，</span></span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;rfds);<span class="comment">//fd = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait up to five seconds. */</span></span><br><span class="line"></span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;<span class="comment">//等待5秒</span></span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;<span class="comment">//设置等待微秒</span></span><br><span class="line"></span><br><span class="line">    retval = select(<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);<span class="comment">//fd + 1</span></span><br><span class="line">    <span class="comment">/* Don&#x27;t rely on the value of tv now! */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">&quot;select()&quot;</span>);<span class="comment">//失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data is available now.\n&quot;</span>);<span class="comment">//成功</span></span><br><span class="line">        <span class="comment">/* FD_ISSET(0, &amp;rfds) will be true. */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No data within five seconds.\n&quot;</span>);<span class="comment">//超时</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./a.out                                                  </span><br><span class="line">ls</span><br><span class="line">Data is available now.</span><br><span class="line"><span class="meta">apricity@Apricity%</span><span class="bash"> ls</span></span><br><span class="line">00.head.h  01.open.c  02.fopen.c  03.fflush.c  04.common.c  05.common.h  06.fork.c  07.testblock.c  08.select.c  a.out  b.txt</span><br></pre></td></tr></table></figure>


<p>==&gt;为什么会出现 ls命令</p>
<p>输入ls,select感知IO成功,程序执行完毕，ls被zsh执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">   <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Data is available now.\n&quot;</span>);<span class="comment">//成功</span></span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buff);<span class="comment">//吃掉输入的数据</span></span><br><span class="line">&#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>


<h2 id="6-补充-用户态和内核态"><a href="#6-补充-用户态和内核态" class="headerlink" title="6.补充:用户态和内核态"></a>6.补充:用户态和内核态</h2><h1 id="4-多进程"><a href="#4-多进程" class="headerlink" title="4.多进程"></a>4.多进程</h1><h2 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1.什么是进程"></a>1.什么是进程</h2><blockquote>
<p>什么是程序</p>
</blockquote>
<p>程序是编译好的可执行的二进制文件。应用是程序的集合。</p>
<blockquote>
<p>什么是进程</p>
</blockquote>
<p>一种说法是进程是程序在内存中的镜像，另一种常见的说法是进程是运行中的程序。</p>
<p>进程（process）是一个可执行程序（program）的实例。</p>
<p><strong>进程号和父进程号</strong></p>
<p>​        每个进程都有一个进程号（PID），进程号是一个正数，用以唯一标识系统中的某个进程。对 各种系统调用而言，进程号有时可以作为传入参数，有时可以作为返回值。</p>
<p>​        系统调用 getpid()返回调用进程的进程号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span>  <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span>  <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​        getpid()返回值的数据类型为 pid_t，该类型是由 SUSv3 所规定的整数类型，专用于存储进 程号。 </p>
<p>​        除了少数系统进程外，比如 init 进程（进程号为 1），程序与运行该程序进程的进程号之 间没有固定关系。</p>
<p>​        每个进程都有一个创建自己的父进程。使用系统调用 getppid()可以检索到父进程的进程号。</p>
<p>​        实际上，每个进程的父进程号属性反映了系统上所有进程间的树状关系。每个进程的父 进程又有自己的父进程，以此类推，回溯到 1 号进程—init 进程，即所有进程的始祖。</p>
<p>​        如果子进程的父进程终止，则子进程就会变成“孤儿”，init 进程随即将收养该进程，子 进程后续对 getppid()的调用将返回进程号 1。</p>
<p><strong>孤儿进程与僵尸进程</strong></p>
<p>父进程与子进程的生命周期一般都不相同，父、子进程间互有长短。这就引出了下面两个问题。 </p>
<ul>
<li><p>谁会是孤儿（orphan）子进程的父进程？进程 ID 为 1 的众进程之祖—init 会接管孤儿 进程。换言之，某一子进程的父进程终止后，对 getppid()的调用将返回 1。这是判定 某一子进程之“生父”是否“在世”的方法之一（前提是假设该子进程由 init 之外的 进程创建）。</p>
</li>
<li><p>在父进程执行 wait()之前，其子进程就已经终止，这将会发生什么？此处的要点在于，即使 子进程已经结束，系统仍然允许其父进程在之后的某一时刻去执行 wait()，以确定该子进程 是如何终止的。内核通过将子进程转为僵尸进程（zombie）来处理这种情况。这也意味着将 释放子进程所把持的大部分资源，以便供其他进程重新使用。该进程所唯一保留的是内核进 程表中的一条记录，其中包含了子进程ID、终止状态、资源使用数据等信息。</p>
<p>​        至于僵尸进程名称的由来，则源于 UNIX 系统对电影情节的效仿—无法通过信号来杀死 僵尸进程，即便(银弹）SIGKILL。这就确保了父进程总是可以执行 wait()方法。 </p>
<p>​        当父进程执行 wait()后，由于不再需要子进程所剩余的最后信息，故而内核将删除僵尸进 程。另一方面，如果父进程未执行 wait()随即退出，那么 init 进程将接管子进程并自动调用 wait()，从而从系统中移除僵尸进程.</p>
<p>​        如果父进程创建了某一子进程，但并未执行 wait()，那么在内核的进程表中将为该子进程永 久保留一条记录。如果存在大量此类僵尸进程，它们势必将填满内核进程表，从而阻碍新进程的 创建。既然无法用信号杀死僵尸进程，那么从系统中将其移除的唯一方法就是杀掉它们的父进程 （或等待其父进程终止），此时 init 进程将接管和等待这些僵尸进程，从而从系统中将它们清理掉。</p>
</li>
</ul>
<h2 id="2-fork-详解"><a href="#2-fork-详解" class="headerlink" title="2.fork()详解"></a>2.fork()详解</h2><blockquote>
<p>fork()创建一个子进程</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%886.18.51.png" alt="截屏2021-01-07 下午6.18.51"></p>
<p>​        系统调用 <code>fork()</code>允许一进程（父进程）创建一新进程（子进程）。具体做法是，新 的子进程几近于对父进程的翻版：子进程获得父进程的栈、数据段、堆和执行文 本段的拷贝。可将此视为把父进程一分为二，术语 fork 也由此得名。</p>
<p>​        理解 fork()的诀窍是，要意识到，完成对其调用后将存在两个进程，且每个进程都会从 fork() 的返回处继续执行。 </p>
<p>​        这两个进程将执行相同的程序文本段，但却各自拥有不同的栈段、数据段以及堆段拷贝。子进程的栈、数据以及栈段开始时是对父进程内存相应各部分的完全复制。执行 fork() 之后，每个进程均可修改各自的栈数据、以及堆段中的变量，而并不影响另一进程。 </p>
<p>​        程序代码则可通过 fork()的返回值来区分父、子进程。在父进程中，fork()将返回新创建 子进程的进程 ID。鉴于父进程可能需要创建，进而追踪多个子进程（通过 wait()或类似方法）， 这种安排还是很实用的。而 fork()在子进程中则返回 0。如有必要，子进程可调用 getpid()以获 取自身的进程 ID，调用 getppid()以获取父进程 ID。 </p>
<p>​        当无法创建子进程时，fork()将返回-1。失败的原因可能在于，进程数量要么超出了系统 针对此真实用户（real user ID）在进程数量上所施加的限制，要么是触及允许该系统创建的最大进程数这一系统级上限。</p>
<p><strong>重点</strong></p>
<p>1.pid_t进程id</p>
<p>2.创建一个新的进程，复制了一份自己,新的进程被叫作子进程,父亲和孩子分别运行在一个完全独立隔离的内存空间，fork时，共用一样的内存空间，只有内存才发生变化时，拷贝才会真实发生(称为写拷贝)</p>
<p>子进程是一个严格的</p>
<p>3.==fork()的子进程返回值为0，父进程返回子进程pid==</p>
<p>4.子进程和父进程的区别：</p>
<p>子进程和父进程的进程ID不一样，且唯一</p>
<p>子进程的父亲ID和父亲pid一样</p>
<p>孩子不会继承父亲的内存锁</p>
<p>进程资源使用和CPU使用都会被清空</p>
<ul>
<li><p>子进程不继承信号量</p>
</li>
<li><p>不会继承计时器</p>
</li>
<li><p>不会继承异步IO操作</p>
<p>进程的属性</p>
</li>
</ul>
<p>返回值：</p>
<p>父进程中返回子进程的pid,子进程返回0,</p>
<p>getpid获得自己的id</p>
<p>getppid获得父进程id</p>
<h2 id="3-fork-代码演示"><a href="#3-fork-代码演示" class="headerlink" title="3.fork()代码演示"></a>3.fork()代码演示</h2><h3 id="3-1fork-理解"><a href="#3-1fork-理解" class="headerlink" title="3.1fork()理解"></a>3.1fork()理解</h3><p>#include “00.head.h”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">guziqiu</span><br><span class="line">guziqiuguziqiu%</span><br></pre></td></tr></table></figure>
<p>==&gt;输出2个<code>name变量</code></p>
<p>原因:fork之后的代码会有两份，之前的代码只执行了一次,标准IO是缓冲IO(没有遇到换行或者缓冲区内容过多或者程序结束，printf的内容会留在输出缓冲区,缓冲区内容被fork,return  0 ;后输出缓冲区内容被释放，输出一个name变量)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==&gt;输出1个<code>name</code></p>
<p>标准IO是缓冲IO,缓冲区被换行符刷新</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==&gt;输出2个<code>name</code></p>
<p>fork后的内容被复制</p>
<h3 id="3-2-fork-进阶"><a href="#3-2-fork-进阶" class="headerlink" title="3.2.fork()进阶"></a>3.2.fork()进阶</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;<span class="comment">//必须有括号，否则逻辑会不同，子进程一生下来就在11行的位置</span></span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);<span class="comment">//fork出错，fork = -1,大部分是因为内存不够</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//==&gt;思考：一定是父进程先执行吗?</span></span><br><span class="line">        <span class="comment">//父进程和子进程空间相互独立，谁先跑都没有关系，由内核调度决定</span></span><br><span class="line">        <span class="comment">//基于内核算法，极大概率先执行父进程</span></span><br><span class="line">        <span class="comment">//原因:父进程正在执行，此时复制父进程，父进程执行完才会执行子进程，所以一般会先执行父进程</span></span><br><span class="line">        <span class="comment">//如果此时cpu强制停用父进程，先执行别的进程，则可能会出现子进程先执行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Process!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent Process\n&quot;</span>);<span class="comment">//父子进程有同一份代码，孩子从11行开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程管理子进程，</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="4-wait-详解"><a href="#4-wait-详解" class="headerlink" title="4.wait()详解"></a>4.wait()详解</h2><p>​        系统调用 <code>wait()</code>等待调用进程的任一子进程终止，同时在参数 status 所指向的缓冲区中返回 该子进程的终止状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *wstatus)</span></span>;</span><br></pre></td></tr></table></figure>
<p>系统调用 wait()执行如下动作。 </p>
<p>1． 如果调用进程并无之前未被等待的子进程终止 ，调用将一直阻塞，直至某个子进程终止。 如果调用时已有子进程终止，wait()则立即返回。</p>
<p> 2． 如果 status 非空，那么关于子进程如何终止的信息则会通过 status 指向的整型变量返回。 </p>
<p> 3． 内核将会为父进程下所有子进程的运行总量追加进程 CPU 时间以及资源使用 数据。 </p>
<p>4． 将终止子进程的 ID 作为 <code>wait()</code>的结果返回。</p>
<p>​        出错时，wait()返回-1。可能的错误原因之一是调用进程并无之前未被等待的1子进程，此 时会将 errno 置为 ECHILD。换言之，可使用如下代码中的循环来等待调用进程的所有子进程 退出。</p>
<p>子进程退出状态</p>
<p>所有的系统进程都在等待子进程的变化，并且获得状态变化（孩子被终结，杀死，唤醒），对于一个被终结的进程，执行wait，由系统释放孩子所关联的资源</p>
<p>孩子死了父进程没有为孩子收尸，孩子变成了僵尸进程，没有占用cpu但是会占用系统资源和pid，</p>
<p>wait没有被执行会变成僵尸进程</p>
<p>如果进程以及死了，wait会立马返回，孩子没死，父进程会一直等着，或者收到一个中断信号</p>
<p>​        父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。<br>注：</p>
<ol>
<li>当父进程忘了用wait()函数等待已终止的子进程时,子进程就会进入一种无父进程的状态,此时子进程就是僵尸进程.</li>
<li>wait()要与fork()配套出现,如果在使用fork()之前调用wait(),wait()的返回值则为-1,正常情况下wait()的返回值为子进程的PID.</li>
<li>如果先终止父进程,子进程将继续正常进行，只是它将由init进程(PID 1)继承,当子进程终止时,init进程捕获这个状态.</li>
<li>参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就像下面这样：<br><code>pid = wait(NULL);</code><br>如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。<br>　　如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中， 这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的，以及正常结束时的返回值，或被哪一个信号结束的等信息。由于这些信息 被存放在一个整数的不同二进制位中，所以用常规的方法读取会非常麻烦，人们就设计了一套专门的宏（macro）来完成这项工作，下面我们来学习一下其中最常用的两个：<br>1，WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。<br>（请注意，虽然名字一样，这里的参数status并不同于wait唯一的参数–指向整数的指针status，而是那个指针所指向的整数，切记不要搞混了。）<br>2， WEXITSTATUS(status) 当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status) 就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。请注意，如果进程不是正常退出的，也就是说， WIFEXITED返回0，这个值就毫无意义。</li>
</ol>
<h2 id="5-wait-代码演示"><a href="#5-wait-代码演示" class="headerlink" title="5.wait()代码演示"></a>5.wait()代码演示</h2><h3 id="产生僵尸进程"><a href="#产生僵尸进程" class="headerlink" title="产生僵尸进程"></a>产生僵尸进程</h3><p><code>fork.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Process!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent Process\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;--sleep(5)&quot;</span>);</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apricity@Apricity 00.课程代码 % ./a.out                                                                                                   </span><br><span class="line">Parent Process</span><br><span class="line">Child Process!</span><br><span class="line">^Z</span><br><span class="line">[1]  + 16838 suspended  ./a.out</span><br><span class="line">apricity@Apricity 00.课程代码 % bg                            </span><br><span class="line">[1]  + 16838 continued  ./a.out</span><br><span class="line">apricity@Apricity 00.课程代码 % ps                                                                                                        </span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">16342 pts/0    00:00:03 zsh</span><br><span class="line">16838 pts/0    00:00:00 a.out</span><br><span class="line">16839 pts/0    00:00:00 a.out &lt;defunct&gt;#僵尸进程</span><br><span class="line">16842 pts/0    00:00:00 ps</span><br><span class="line">apricity@Apricity 00.课程代码 %ps -aux | grep 16839                </span><br><span class="line">apricity 16839  0.0  0.0      0     0 pts/0    Z    11:12   0:00 [a.out] &lt;defunct&gt;</span><br><span class="line">apricity 16852  0.0  0.0  14428  1044 pts/0    S+   11:15   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox 16839</span><br><span class="line">apricity@Apricity 00.课程代码 % ps -aux | grep Z             </span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">apricity 16839  0.0  0.0      0     0 pts/0    Z    11:12   0:00 [a.out] &lt;defunct&gt;</span><br><span class="line">apricity 16858  0.0  0.0  14428   996 pts/0    S+   11:16   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox Z</span><br><span class="line"><span class="meta">#</span><span class="bash">Z的意思就是僵尸进程</span></span><br></pre></td></tr></table></figure>


<p><code>fork.wait.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Process!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent Process\n&quot;</span>);</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;--wait status = %d \n&quot;</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./a.out                                                            </span><br><span class="line">Parent Process</span><br><span class="line">Child Process!</span><br><span class="line">--wait status = 256</span><br></pre></td></tr></table></figure>


<p>创建10个子进程,每个子进程打印自己是子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; I am %d Child Process!\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">500</span>);</span><br><span class="line">    &#125; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep  &quot;./a.out&quot; | grep -v &quot;grep&quot; | wc -l</span><br><span class="line">1024</span><br><span class="line"><span class="meta">#</span><span class="bash">一共产生1024个进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2^10 = 1024，会以子数倍增长</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">break</span>;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; I am %d Child Process!\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">500</span>);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">./a.out                                                            </span><br><span class="line"> I am 1 Child Process!</span><br><span class="line"> I am 3 Child Process!</span><br><span class="line"> I am 2 Child Process!</span><br><span class="line"> I am 4 Child Process!</span><br><span class="line"> I am 9 Child Process!</span><br><span class="line"> I am 10 Child Process!</span><br><span class="line"> I am 5 Child Process!</span><br><span class="line"> I am 6 Child Process!</span><br><span class="line"> I am 7 Child Process!</span><br><span class="line"> I am 8 Child Process!</span><br><span class="line">ps -aux | grep &quot;a.out&quot; | grep -v &quot;grep&quot; | wc -l                                              </span><br><span class="line">10</span><br></pre></td></tr></table></figure>


<h2 id="6-exec-家族详解"><a href="#6-exec-家族详解" class="headerlink" title="6.exec()家族详解"></a>6.exec()家族详解</h2><p>​        系统调用 execve()可以将新程序加载到某一进程的内存空间。在这一操作过程中，将丢弃 旧有程序，而进程的栈、数据以及堆段会被新程序的相应部件所替换。</p>
<p>​        基于系统调用 execve()，还提供了一系列冠以 exec 来命名的上层库函数，虽然接口方式 各异，但功能相同。通常将调用这些函数加载一个新程序的过程称作 exec 操作，或是简单地 以 exec()来表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<p>​        </p>
<p>​        参数 pathname 包含准备载入当前进程空间的新程序的路径名，既可以是绝对路径（冠 之以/），也可以是相对于调用进程当前工作目录（current working directory）的相对路径。</p>
<p>​        参数 argv 则指定了传递给新进程的命令行参数。该数组对应于 C 语言 main()函数的第 2 个参数（argv），且格式也与之相同：是由字符串指针所组成的列表，以 NULL 结束。argv[0]的 值则对应于命令名。通常情况下，该值与 pathname 中的 basename（路径名的最后部分）相同。</p>
<p>​        最后一个参数 envp 指定了新程序的环境列表。参数 envp 对应于新程序的 environ 数组：也是由字符串指针组成的列表，以 NULL 结束，所指向的字符串格式为 name=value。</p>
<p>　exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件<strong>。</strong>这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。</p>
<p>　　与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行</p>
<p>exec族的任一函数都不创建一个新的进程，而是在调用进程里面去执行新的程序。所以进程id不变，还是调用exec函数前的进程id，但是用户空间的代码和数据都更新了，变为新程序的代码和数据了。 </p>
<p>​    extern char **environ;    //全局环境变量，导入到本文件即可直接使用</p>
<ol>
<li>int execl(const char *path, const char *arg, …);    </li>
</ol>
<p>​    功能：通过路径+文件名来加载一个进程；path文件路径；arg文件名称；…可变参数，至少一个NULL</p>
<p>​    附：l即list </p>
<p>​    返回值：成功的情况下是没有返回的，失败时返回-1 。</p>
<p>​    举例说明：</p>
<p>​        execl(“/bin/ls”, “ls”, “-a”, “-l”, NULL);    //path绝对路径，如/bin/ls；文件名称ls；后面三个可变参数，最后必须以NULL结束</p>
<ol start="2">
<li>int execlp(const char *file, const char *arg, …);    </li>
</ol>
<p>​    功能：借助PATH环境变量加载一个进程，file要加载的程序的名称</p>
<p>​    附：l即list；p即path </p>
<p>​    该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数file，则出错返回。</p>
<p>​    该函数通常用来调用系统程序。如：ls、cp、cat等命令。 </p>
<p>​    返回值：成功的情况下是没有返回的，失败时返回-1 。</p>
<p>​    举例说明：</p>
<p>​        execlp(“ls”, “ls”, “-a”, “-l”, NULL);    //第一个ls是指查看PATH环境变量里的ls；第二个ls是名称文件；后面是可变参数，NULL结束</p>
<ol start="3">
<li>int execle(const char *path, const char *arg, …, char * const envp[]);    </li>
</ol>
<p>​    功能：加载指定路径的程序，并为新程序复制最后一个环境变量</p>
<p> 附：l即list；e即environment</p>
<p>​    举例说明：</p>
<p>​        char* envp[] = {NULL};</p>
<p>​        execlp(“ls”, “ls”, “-a”, “-l”, NULL, envp);</p>
<ol start="4">
<li>int execv(const char *path, char *const argv[]);</li>
</ol>
<p>​    功能：加载指定路径的程序 </p>
<p>​    附：v即vector，命令行参数列表</p>
<p>​    举例说明：</p>
<p>​        char* argv[] = {“ls”, “-a”, “-l”, NULL}; </p>
<p>​        execl(“/bin/ls”,argv);</p>
<ol start="5">
<li>int execvp(const char *file, char *const argv[]);</li>
</ol>
<p>​    功能：加载path环境变量里的名称为file的程序 </p>
<p>​    附：v即命令行参数列表，p即path </p>
<p>​    int main(int argc, char *argv[]) {</p>
<p>​        pid_t pid = fork();</p>
<p>​        if (pid == 0) {    //子进程里加载ls程序</p>
<p>​            char* argvv[] = {“ls”, “-a”, “-l”, NULL};</p>
<p>​            execvp(“ls”, argvv);</p>
<p>​            perror(“execlp”);  exit(1);    //只有execl函数执行失败的情况下才有机会执行这两句代码，执行的成功话就有去无回了。</p>
<p>​        } else if (pid &gt; 0) {</p>
<p>​            sleep(1);    printf(“parent\n”);</p>
<p>​        }</p>
<p>​        return 0;</p>
<p>​    }</p>
<ol start="6">
<li>int  execve(const  char  *filename, char *const argv[], char *const envp[]);</li>
</ol>
<p>​    功能：加载指定的程序；filename必须是一个可执行程序或者一个以#! interpreter [optional-arg] 开始的脚本。</p>
<p>​        上面的五个exec函数是库函数，这个是系统函数；上面的五个exec函数最终都是调用这个函数实现的。 </p>
<p>总结：exec族函数的规律</p>
<p>​    exec函数一旦调用成功就有去无回了，去执行新的程序去了。只有失败时才有返回，返回值为-1。所以我们直接在exec函数调用后直接调用perror()和exit()，不需要if判断，因为失败的情况才会执行。</p>
<p>​    函数名的意义的理解： </p>
<p>​        l (list) 命令行参数列表</p>
<p>​        p (path) 环境变量，环境变量搜素文件名称file</p>
<p>​        v (vector) 命令行参数数组</p>
<p>​        e (environment) 环境变量数组，给新加载程序设置指定的环境变量</p>
<p>​    函数的相似性： </p>
<p>​        execlp——&gt;execvp </p>
<p>​                  |         </p>
<p>​        execl  ——&gt;execv</p>
<p>​                  | </p>
<p>​        execle——&gt;execve</p>
<p>​        从左往右，可变参数转为以NULL结尾的指针数组；从左往右， 从上往下，最后归根结底都是调用execve函数实现的。</p>
<p>替换当前进程映像用一个新的进程映像，</p>
<h2 id="7-exec-代码演示"><a href="#7-exec-代码演示" class="headerlink" title="7.exec()代码演示"></a>7.exec()代码演示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt;  <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;start\n&quot;</span>);</span><br><span class="line">        execlp(<span class="string">&quot;vim&quot;</span>, <span class="string">&quot;vim&quot;</span>, <span class="string">&quot;12.exec.c&quot;</span>, <span class="literal">NULL</span>);<span class="comment">//子进程，在子进程中执行vim,名字是vim,名字是12.exec.c</span></span><br><span class="line">        sleep(<span class="number">10000000</span>);<span class="comment">//子进程中不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;END!\n&quot;</span>);<span class="comment">//子进程中不存在</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After child terminated!\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//12.exec.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt;  <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;start\n&quot;</span>);</span><br><span class="line">        execl(<span class="string">&quot;./a.out&quot;</span>, <span class="string">&quot;haha&quot;</span>, <span class="string">&quot;12.exec.c&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        sleep(<span class="number">10000000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;END!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After child terminated!\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//13.test_exec.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg0 = %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc 13.test_exec.c</span><br><span class="line">./a.out                                   </span><br><span class="line">arg0 = ./a.out</span><br><span class="line">gcc 12.exec.c -o exec</span><br><span class="line"> ./exec                                                        </span><br><span class="line">start</span><br><span class="line">arg0 = haha#习惯上将此处设置为文件名</span><br><span class="line">After child terminated!</span><br></pre></td></tr></table></figure>


<h2 id="8-高级进程管理"><a href="#8-高级进程管理" class="headerlink" title="8.高级进程管理"></a>8.高级进程管理</h2><p>进程调度</p>
<p>进程调度是一个内核子系统</p>
<p>进程调度的主要任务是决定哪一个“就绪”状态的进程来执行</p>
<p>就绪进程就是 非阻塞进程</p>
<p>阻塞进程就是正在睡眠的进程，需要内核唤醒的进程;</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%882.43.53.png" alt="截屏2021-01-21 下午2.43.53"></p>
<h1 id="5-进程间通信上"><a href="#5-进程间通信上" class="headerlink" title="5.进程间通信上"></a>5.进程间通信上</h1><h2 id="5-1进程间通信"><a href="#5-1进程间通信" class="headerlink" title="5.1进程间通信"></a>5.1进程间通信</h2><p>Linux 系统上运行有多个进程，其中许多都是独立运行。然而，有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制。 </p>
<p>​        读写磁盘文件中的信息是进程间通信的方法之一。可是，对许多程序来说，这种方法既 慢又缺乏灵活性。因此，像所有现代 UNIX 实现那样，Linux 也提供了丰富的进程间通信（IPC） 机制，如下所示。 </p>
<ul>
<li> 信号（signal），用来表示事件的发生。 </li>
<li> 管道（亦即 shell 用户所熟悉的“|”操作符）和 FIFO，用于在进程间传递数据。 </li>
<li>套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据。 </li>
<li>文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以 锁定。 </li>
<li>消息队列，用于在进程间交换消息（数据包）。 </li>
<li>信号量（semaphore），用来同步进程动作。 </li>
<li>共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容 时，其他所有进程会立即了解到这一变化。 </li>
</ul>
<p>​        </p>
<h2 id="5-2System-V-共享内存"><a href="#5-2System-V-共享内存" class="headerlink" title="5.2System V 共享内存"></a>5.2System V 共享内存</h2><p>​         共享内存允许两个或多个进程共享物理内存的同一块区 域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间内存的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分 数据会对其他所有共享同一个段的进程可用。与管道或消息队列要求发送进程将数据从用户 空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法 相比，这种 IPC 技术的速度更快。（每个进程也存在通过系统调用来执行复制操作的开销。） </p>
<p>​         另一方面，共享内存这种 IPC 机制不由内核控制意味着通常需要通过某些同步方法使得 进程不会出现同时访问共享内存的情况（如两个进程同时执行更新操作或者一个进程在从共 享内存中获取数据的同时另一个进程正在更新这些数据）。System V 信号量天生就是用来完成 这种同步的一种方法。当然，还可以使用其他方法，如 POSIX 信号量和文件锁.</p>
<h3 id="5-2-1共享内存的使用"><a href="#5-2-1共享内存的使用" class="headerlink" title="5.2.1共享内存的使用"></a>5.2.1共享内存的使用</h3><p>为使用一个共享内存段通常需要执行下面的步骤。 </p>
<ul>
<li>调用 shmget()创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程 创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 </li>
<li>使用 shmat()来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 </li>
<li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内 存，程序需要使用由 shmat()调用返回的 addr 值，它是一个指向进程的虚拟地址空间 中该共享内存段的起点的指针。</li>
<li>调用 shmdt()来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存 了。这一步是可选的，并且在进程终止时会自动完成这一步。 </li>
<li>调用 shmctl()来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后 内存段才会被销毁。只有一个进程需要执行这一步。</li>
</ul>
<h3 id="5-2-2创建或打开一个共享内存段shmget"><a href="#5-2-2创建或打开一个共享内存段shmget" class="headerlink" title="5.2.2创建或打开一个共享内存段shmget()"></a>5.2.2创建或打开一个共享内存段shmget()</h3><p>shmget()系统调用创建一个新共享内存段或获取一个既有段的标识符。新创建的内存段中 的内容会被初始化为 0。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       shmget - allocates a System V shared memory segment</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/ipc.h&gt;</span><br><span class="line">       #include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">       int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>​         当使用 shmget()创建一个新共享内存段时，size 则是一个正整数，它表示需分配的段的字 节数。内核是以系统分页大小的整数倍来分配共享内存的，因此实际上 size 会被提升到最近 的系统分页大小的整数倍。如果使用 shmget()来获取一个既有段的标识符，那么 size 对段不会 产生任何效果，但它必须要小于或等于段的大小。 </p>
<p>​        shmflg 参数执行的任务与其在其他 IPC get 调用中执行的任务一样，即指定施加于新共享 内存段上的权限或需检查的既有内存段的权限。此外，在 shmflg 中还可以对下列标 记中的零个或多个取 OR 来控制 shmget()的操作。 </p>
<p>​        IPC_CREAT </p>
<p>如果不存在与指定的 key 对应的段，那么就创建一个新段。 </p>
<p>​        IPC_EXCL </p>
<p>如果同时指定了IPC_CREAT 并且与指定的key 对应的段已经存在，那么返回EEXIST 错误。  SHM_HUGETLB（自 Linux 2.6 起） </p>
<p>特权（CAP_IPC_LOCK）进程能够使用这个标记创建一个使用巨页（huge page）的共享内存 段。巨页是很多现代硬件架构提供的一项特性用来管理使用超大分页尺寸的内存。（如 x86-32 允 许使用 4MB 的分页大小来替代 4KB 的分页大小。）在那些拥有大量内存的系统上并且应用程序需 要使用大量内存块时，使用巨页可以降低硬件内存管理单元的超前转换缓冲器（translation look-aside buffer，TLB）中的条目数量。这之所以会带来益处是因为 TLB 中的条目通常是一种稀 缺资源。更多信息可参考内核源文件 Documentation/vm/ hugetlbpage.txt。 </p>
<p>SHM_NORESERVE（自 Linux 2.6.15 起）</p>
<p> 这个标记在 shmget()中所起的作用与 MAP_NORESERVE 标记在 mmap()中所起的作用一 样。 shmget()在成功时返回新或既有共享内存段的标识符。</p>
<h3 id="5-2-3-使用共享内存shmat"><a href="#5-2-3-使用共享内存shmat" class="headerlink" title="5.2.3 使用共享内存shmat()"></a>5.2.3 使用共享内存shmat()</h3><p>shmat()系统调用将 shmid 标识的共享内存段附加到调用进程的虚拟地址空间中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       shmat, shmdt - System V shared memory operations</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/types.h&gt;</span><br><span class="line">       #include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">       void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line"></span><br><span class="line">       int shmdt(const void *shmaddr);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, a valid shared memory identifier is returned.  On error, <span class="number">-1</span> is returned, <span class="keyword">and</span> errno is <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>


<p>shmaddr 参数和 shmflg 位掩码参数中 SHM_RND 位的设置控制着段是如何被附加上去的。 </p>
<ul>
<li>如果 shmaddr 是 NULL，那么段会被附加到内核所选择的一个合适的地址处。这是附 加一个段的优选方法。 </li>
<li>如果 shmaddr 不为 NULL 并且没有设置 SHM_RND，那么段会被附加到由 shmaddr 指 定的地址处，它必须是系统分页大小的一个倍数（否则会发生 EINVAL 错误）。 </li>
<li>如果 shmaddr 不为 NULL 并且设置了 SHM_RND，那么段会被映射到的地址为在 shmaddr 中提供的地址被舍入到最近的常量 SHMLBA（shared memory low boundary address）的倍数。这个常量等于系统分页大小的某个倍数。将一个段附加到值为 SHMLBA 的倍数的地址处在一些架构上是有必要的，因为这样才能够提升 CPU 的快 速缓冲性能和防止出现同一个段的不同附加操作在 CPU 快速缓冲中存在不一致的视 图的情况</li>
</ul>
<p>​        shmat()的函数结果是返回附加共享内存段的地址。开发人员可以像对待普通的 C 指针那 样对待这个值，段与进程的虚拟内存的其他部分看起来毫无差异。通常会将 shmat()的返回值 赋给一个指向某个由程序员定义的结构的指针以便在该段上设定该结构。 </p>
<p>​        要附加一个共享内存段以供只读访问，那么就需要在 shmflg 中指定 SHM_RDONLY 标记。 试图更新只读段中的内容会导致段错误（SIGSEGV 信号）的发生。如果没有指定 SHM_ RDONLY，那么就既可以读取内存又可以修改内存。 </p>
<p>​        一个进程要附加一个共享内存段就需要在该段上具备读和写权限，除非指定了 SHM_ RDONLY 标记，那样的话就只需要具备读权限即可。</p>
<p>​        最后一个可以在 shmflg 中指定的值是 SHM_REMAP。在指定了这个标记之后 shmaddr 的值 必须为非 NULL。这个标记要求 shmat()调用替换起点在 shmaddr 处长度为共享内存段的长度的 任何既有共享内存段或内存映射。一般来讲，如果试图将一个共享内存段附加到一个已经在用 的地址范围时将会导致 EINVAL 错误的发生。SHM_REMAP 是一个非标准的 Linux 扩展。</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-22%20%E4%B8%8A%E5%8D%8810.43.15.png" alt="截屏2021-01-22 上午10.43.15"></p>
<p>​        </p>
<p>​        当一个进程不再需要访问一个共享内存段时就可以调用 shmdt()来讲该段分离出其虚拟地 址空间了。shmaddr 参数标识出了待分离的段，它应该是由之前的 shmat()调用返回的一个值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​        分离一个共享内存段与删除它是不同的。删除是通过 shmctl() IPC_ RMID 操作来完成的。</p>
<p>​        通过 fork()创建的子进程会继承其父进程附加的共享内存段。因此，共享内存为父进程和 子进程之间的通信提供了一种简单的 IPC 方法。 </p>
<p>​        在一个 exec()中，所有附加的共享内存段都会被分离。在进程终止之后共享内存段也会自 动被分离</p>
<h3 id="5-2-4ipcs-和-ipcrm-命令"><a href="#5-2-4ipcs-和-ipcrm-命令" class="headerlink" title="5.2.4ipcs 和 ipcrm 命令"></a>5.2.4ipcs 和 ipcrm 命令</h3><p>​        ipcs 和 ipcrm 命令是 System V IPC 领域中类似于 ls 和 rm 文件命令的命令。使用 ipcs 能够 获取系统上 IPC 对象的信息。在默认情况下，ipcs 会显示出所有对象，如下面的例子所示。</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-22%20%E4%B8%8A%E5%8D%8810.52.09.png" alt="截屏2021-01-22 上午10.52.09"></p>
<p>​        在 Linux 上，ipcs(1)只显示出拥有读权限的 IPC 对象的信息，而不管是否拥有这些对象。 在一些 UNIX 实现上，ipcs 的行为与它在 Linux 上的行为一样，但在其他实现上，ipcs 会显示 出所有对象，不管当前用户是否拥有这些对象上的读权限。 </p>
<p>​        在默认情况下，ipcs 会显示出每个对象的 key、标识符、所有者以及权限（用一个八进制 数字表示），后面跟着对象所特有的信息。 </p>
<ul>
<li><p>对于共享内存，ipcs 会显示出共享内存区域的大小、当前将共享内存区域附加到自己 的虚拟地址空间的进程数以及状态标记。状态标记标识出了区域是否被锁进了 RAM 以防止交换以及在所有进程都与该区域分离之后是否已经将其标记为待销毁了。</p>
</li>
<li><p>对于信号量，ipcs 会显示出信号集的大小。 </p>
</li>
<li><p>对于消息队列，ipcs 会显示出队列中数据占据的字节总数以及消息数量。</p>
<p>ipcs(1)手册对各种能够显示 IPC 对象的其他信息的选项进行了说明。 ipcrm 命令删除一个 IPC 对象。这个命令的常规形式为下面两种形式中的一种</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -X key</span><br><span class="line">ipcrm -x id</span><br></pre></td></tr></table></figure>
<p>​        在上面给出的命令中既可以将一个 IPC 对象的 key 指定为参数 key，也可以将一个 IPC 对象 的标识符指定为参数 id 并且使用小写的 x 替换其大写形式或使用小写的 q（用于消息队列）或 s （用于信号量）或 m（用于共享内存）。因此使用下面的命令可以删除标识符为 65538 的信号量集。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -s 65538  #删除标识符为 65538 的信号量集</span><br><span class="line">ipcrm -m 65538 #删除标识符为 65538 的共享内存</span><br></pre></td></tr></table></figure>




<h2 id="5-3互斥量-mutexe-和条件变量-condition-variable"><a href="#5-3互斥量-mutexe-和条件变量-condition-variable" class="headerlink" title="5.3互斥量(mutexe)和条件变量(condition variable)"></a>5.3互斥量(mutexe)和条件变量(condition variable)</h2><p>​        互斥量可以帮助线程同步对共享资源的使用，以防如下情况发生：线程某甲试图访 问一共享变量时，线程某乙正在对其进行修改。条件变量则是在此之外的拾遗补缺，允许线 程相互通知共享变量（或其他共享资源）的状态发生了变化。</p>
<p>​        互斥量既可以像静态变量那样分配，也可以在运行时动态创建。</p>
<p>​        互斥量是属于 pthread_mutex_t 类型的变量。在使用之前必须对其初始化。对于静态分配 的互斥量而言，可将 PTHREAD_MUTEX_INITIALIZER 赋给互斥量。</p>
<p>​        初始化之后，互斥量处于未锁定状态。函数 pthread_mutex_lock()可以锁定某一互斥量，而 函数 pthread_mutex_unlock()则可以将一个互斥量解锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       pthread_mutex_init, pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock, pthread_mutex_destroy - operations on mutexes</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">pthread_mutex_t</span> fastmutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">pthread_mutex_t</span> recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">pthread_mutex_t</span> errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       pthread_mutex_init always returns <span class="number">0.</span> The other mutex functions <span class="keyword">return</span> <span class="number">0</span> on success <span class="keyword">and</span> a non-zero error code on error.</span><br></pre></td></tr></table></figure>


<p>​        要锁定互斥量，在调用 pthread_mutex_lock()时需要指定互斥量。如果互斥量当前处于未锁定 状态，该调用将锁定互斥量并立即返回。如果其他线程已经锁定了这一互斥量，那么 pthread_ mutex_lock()调用会一直堵塞，直至该互斥量被解锁，到那时，调用将锁定互斥量并返回。</p>
<p>​        如果发起 pthread_mutex_lock()调用的线程自身之前已然将目标互斥量锁定，对于互斥量 的默认类型而言，可能会产生两种后果—视具体实现而定：线程陷入死锁（deadlock），因 试图锁定已为自己所持有的互斥量而遭到阻塞；或者调用失败，返回 EDEADLK 错误。在 Linux 上，默认情况下线程会发生死锁。</p>
<p>​        函数 pthread_mutex_unlock()将解锁之前已遭调用线程锁定的互斥量。以下行为均属错误： 对处于未锁定状态的互斥量进行解锁，或者解锁由其他线程锁定的互斥量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br></pre></td></tr></table></figure>


<p>​        参数 mutex 指定函数执行初始化操作的目标互斥量。参数 attr 是指向pthread_mutexattr_t 类 型对象的指针，该对象在函数调用之前已经过了初始化处理，用于定义互斥量的属性。若将 attr 参数置为 NULL，则该互斥量的各种属性会取默认值。 </p>
<p>​        SUSv3 规定，初始化一个已初始化的互斥量将导致未定义的行为，应当避免这一行为。 </p>
<p>​        在如下情况下，必须使用函数 pthread_mutex_init()，而非静态初始化互斥量。 </p>
<ul>
<li><p>动态分配于堆中的互斥量。例如，动态创建针对某一结构的链表，表中每个结构都包 含一个 pthread_mutex_t 类型的字段来存放互斥量，借以保护对该结构的访问。 </p>
</li>
<li><p>互斥量是在栈中分配的自动变量。 </p>
</li>
<li><p>初始化经由静态分配，且不使用默认属性的互斥量。</p>
<p>当不再需要经由自动或动态分配的互斥量时，应使用 pthread_mutex_destroy()将其销毁。</p>
</li>
</ul>
<p>​      只有当互斥量处于未锁定状态，且后续也无任何线程企图锁定它时，将其销毁才是安全 的。若互斥量驻留于动态分配的一片内存区域中，应在释放（free）此内存区域前将其销毁。 对于自动分配的互斥量，也应在宿主函数返回前将其销毁。 </p>
<p>​        经由 pthread_mutex_destroy()销毁的互斥量，可调用 pthread_mutex_init()对其重新初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INS 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> *<span class="title">share_memory</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;share_memory-&gt;mutex);</span><br><span class="line">        pthread_cond_wait(&amp;share_memory-&gt;cond, &amp;share_memory-&gt;mutex);</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (share_memory-&gt;now &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                pthread_mutex_unlock(&amp;share_memory-&gt;mutex);</span><br><span class="line">                pthread_cond_signal(&amp;share_memory-&gt;cond);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            share_memory-&gt;sum += share_memory-&gt;now;</span><br><span class="line">            share_memory-&gt;now++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&lt;%d&gt; now = %d, sum = %d\n&quot;</span>, x, share_memory-&gt;now, share_memory-&gt;sum);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="comment">//pthread_mutex_unlock(&amp;share_memory-&gt;mutex);</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;share_memory-&gt;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;share_memory-&gt;cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, shmid;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">2021</span>);</span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, <span class="keyword">sizeof</span>(struct Num), IPC_CREAT | IPC_EXCL | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sshmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    share_memory = (struct Num*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (share_memory == (struct Num*)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;share_memory&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    share_memory-&gt;now = <span class="number">0</span>;</span><br><span class="line">    share_memory-&gt;sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;attr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_mutex_init(&amp;share_memory-&gt;mutex, &amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_condattr_t</span> condattr;</span><br><span class="line">    pthread_condattr_init(&amp;condattr);</span><br><span class="line">    pthread_condattr_setpshared(&amp;condattr, <span class="number">1</span>);</span><br><span class="line">    pthread_cond_init(&amp;share_memory-&gt;cond, &amp;condattr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;before fork()\n&quot;);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= INS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        x = i;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        do_add(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        pthread_cond_signal(&amp;share_memory-&gt;cond);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= INS; i++) &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end ==&gt; share_memory-&gt;sum = %d \n&quot;</span>, share_memory-&gt;sum);</span><br><span class="line">    shmdt(share_memory);</span><br><span class="line">    shmctl(shmid, IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-4进程调度"><a href="#5-4进程调度" class="headerlink" title="5.4进程调度"></a>5.4进程调度</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%882.47.16.png" alt="截屏2021-01-21 下午2.47.16"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%882.49.36.png" alt="截屏2021-01-21 下午2.49.36"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%882.52.55.png" alt="截屏2021-01-21 下午2.52.55"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%883.02.41.png" alt="截屏2021-01-21 下午3.02.41"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%883.06.29.png" alt="截屏2021-01-21 下午3.06.29"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%883.08.34.png" alt="截屏2021-01-21 下午3.08.34"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%883.09.54.png" alt="截屏2021-01-21 下午3.09.54"></p>
<h1 id="6-进程间通信下"><a href="#6-进程间通信下" class="headerlink" title="6.进程间通信下"></a>6.进程间通信下</h1><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>shmctl</p>
<p>ftok</p>
<p>聊天系统</p>
<p><code>18.ipc.chat.server.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;17.ipc.chat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> *<span class="title">shar_memory</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">202101</span>);</span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, <span class="keyword">sizeof</span>(struct Msg), IPC_CREAT | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((shar_memory = (struct Msg *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (struct Msg *)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(shar_memory, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Msg));</span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> m_attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;m_attr);</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;m_attr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_mutex_init(&amp;shar_memory-&gt;mutex, &amp;m_attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_condattr_t</span> c_attr;</span><br><span class="line">    pthread_condattr_init(&amp;c_attr);</span><br><span class="line">    pthread_condattr_setpshared(&amp;c_attr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_cond_init(&amp;shar_memory-&gt;cond, &amp;c_attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;shar_memory-&gt;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Server got the Mutex!\n&quot;</span>);</span><br><span class="line">        pthread_cond_wait(&amp;shar_memory-&gt;cond, &amp;shar_memory-&gt;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Server got the cond signal!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; : %s.\n&quot;</span>, shar_memory-&gt;name, shar_memory-&gt;msg);</span><br><span class="line">        <span class="built_in">memset</span>(shar_memory-&gt;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(shar_memory-&gt;msg));</span><br><span class="line">        pthread_mutex_unlock(&amp;shar_memory-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>19.ipc.chat.client.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;17.ipc.chat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> *<span class="title">shar_memory</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt, shmid;<span class="comment">//.,共享内存id</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;n:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(name, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -n name\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">202101</span>);</span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, <span class="keyword">sizeof</span>(struct Msg), IPC_CREAT | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((shar_memory = (struct Msg *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (struct Msg *)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> msg[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, msg);</span><br><span class="line">        getchar();<span class="comment">//吃掉缓冲区的回车键</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strlen</span>(msg)) <span class="keyword">continue</span>;<span class="comment">//字符串为空</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strlen</span>(shar_memory-&gt;msg)) &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;shar_memory-&gt;mutex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pthread_mutex_lock(&amp;shar_memory-&gt;mutex);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sending : %s...\n&quot;</span>, msg);</span><br><span class="line">        <span class="built_in">strcpy</span>(shar_memory-&gt;msg, msg);</span><br><span class="line">        <span class="built_in">strcpy</span>(shar_memory-&gt;name, name);</span><br><span class="line">        pthread_cond_signal(&amp;shar_memory-&gt;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;shar_memory-&gt;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Client signaled the cond\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>17.ipc.chat.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><code>00.head.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure>




<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程的一个分支</p>
<p>pthread process thread</p>
<p>一个进程可以有多个线程，本质上是一种轻量级进程</p>
<p>共享内存，通信简单，调度成本低，</p>
<p>进程与进程之间调度成本高：</p>
<p>有时间局部性，运行一段时间，就将进程调度出去，换一个新的程序，缓冲也会被干掉</p>
<p>线程本质上的共享内存，一个进程的多个线程在调度的时候，不需要做切换，直接用就可以，原先线程建立起的缓冲信息可以直接用</p>
<p>pthread_create</p>
<p>argument参数</p>
<p>pthread_exit(3)线程自杀</p>
<p>线程创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyArg</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">print</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyArg</span> <span class="title">copyMyarg</span>;</span></span><br><span class="line">    copyMyarg = *(struct MyArg *)arg;<span class="comment">//防止在执行过程中会被其他线程改变，所以先拷贝下来</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyArg</span> *<span class="title">in</span>;</span></span><br><span class="line">    in = (struct MyArg *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In Thread\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s is %d years old!\n&quot;</span>, in-&gt;name, in-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s is %d years old!\n&quot;</span>, copyMyarg.name, copyMyarg.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyArg</span> <span class="title">arg</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(arg.name, <span class="string">&quot;古子秋&quot;</span>);</span><br><span class="line">    arg.age = age;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, print, &amp;arg);</span><br><span class="line">    usleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程是为了解决一个确定性的工作</p>
<p>用理发店举例</p>
<p>刚开始创业开理发店</p>
<p>只有我一个人会理发，如果来了一个人，就可以直接理发，如果来了多个人，除了第一个其他人就只能处于等待状态，就相当于早期的单线程或者单进程处理</p>
<p>现在我学会了一种神奇的技术，叫克隆(fork())，如果我正在理发，又有新客户新来了，那么我克隆一个自己，让他去服务，这就是多进程</p>
<p>但是我发现，克隆自己的代价太大了，系统只能同意我们打开1024个进程，而且拷贝进程会占内存，国家又禁止克隆技术</p>
<p>现在突然发现旁边的理发学院有的学生想做兼职，如果来了很多客人，我就在微信群里面喊多少人过来做兼职，做完了就让他们走。(多线程)</p>
<p> 但是创建进程或者线程比较麻烦，客人需要等待，又要创建又要销毁，</p>
<p>现在我发现店里面人很多。基本上天天都有人，然后我就在人才市场找了几个固定员工，签了合同，如果有人来就去照顾客人，没有人就在店里等待客人到来。（线程池）</p>
<p>所有的客人都处于等待理发的状态，一个员工理发之后继续处于等待状态，为了激励员工，如果多理发的员工会得到更多的薪资(饥渴的线程)，但是为了避免线程同事竞争同一个客户，我们将所有的客户放在一个房子里面(资源加锁)，客户一个一个出来，只有一个员工可以帮客人理发。</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-26%20%E4%B8%8B%E5%8D%885.22.46.png" alt="截屏2021-01-26 下午5.22.46"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-26%20%E4%B8%8B%E5%8D%885.29.35.png" alt="截屏2021-01-26 下午5.29.35"></p>
<p>23.thread_pool.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;24.thread_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_queue_init</span><span class="params">(struct task_queue *taskQueue, <span class="keyword">int</span> size)</span> </span>&#123;<span class="comment">//初始化队列</span></span><br><span class="line">    taskQueue-&gt;size = size;</span><br><span class="line">    taskQueue-&gt;total = <span class="number">0</span>;</span><br><span class="line">    taskQueue-&gt;head = taskQueue-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;taskQueue-&gt;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;taskQueue-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line">    taskQueue-&gt;data = <span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_queue_push</span><span class="params">(struct task_queue *taskQueue, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (taskQueue-&gt;total == taskQueue-&gt;size) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task queue is full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;push&gt;:%s\n&quot;</span>, str);</span><br><span class="line">    taskQueue-&gt;data[taskQueue-&gt;tail] = str;</span><br><span class="line">    taskQueue-&gt;total++;</span><br><span class="line">    <span class="keyword">if</span> (++taskQueue-&gt;tail == taskQueue-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task queue reach end!\n&quot;</span>);</span><br><span class="line">        taskQueue-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cond_signal(&amp;taskQueue-&gt;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">task_queue_pop</span><span class="params">(struct task_queue *taskQueue)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">    <span class="keyword">while</span> (taskQueue-&gt;total == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task queue is empty!\n&quot;</span>);</span><br><span class="line">        pthread_cond_wait(&amp;taskQueue-&gt;cond, &amp;taskQueue-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *str = taskQueue-&gt;data[taskQueue-&gt;head];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;pop&gt;:%s\n&quot;</span>, str);</span><br><span class="line">    taskQueue-&gt;total--;</span><br><span class="line">    <span class="keyword">if</span> (++taskQueue-&gt;head == taskQueue-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task queue reach end!\n&quot;</span>);</span><br><span class="line">        taskQueue-&gt;head = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环打印</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>24.thread_pool.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_queue</span>&#123;</span></span><br><span class="line">    <span class="comment">//循环队列</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">char</span> **data;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;<span class="comment">//检测是否又客人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_queue_init</span><span class="params">(struct task_queue *taskQueue, <span class="keyword">int</span> size)</span></span>;<span class="comment">//建立等待区，等待区又size大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_queue_push</span><span class="params">(struct task_queue *taskQueue, <span class="keyword">char</span> *str)</span></span>;<span class="comment">//str入队列</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">task_queue_pop</span><span class="params">(struct task_queue *taskQueue)</span></span>;<span class="comment">//str入队列</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;24.thread_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_work</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    pthread_detach(pthread_self());<span class="comment">//线程分离</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_queue</span> *<span class="title">taskQueue</span> =</span> (struct task_queue *)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *str = task_queue_pop(taskQueue);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%d&gt; : %s !\n&quot;</span>, pthread_self, str);<span class="comment">//线程拿到自己的id</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THREAD];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_queue</span> <span class="title">taskQueue</span>;</span></span><br><span class="line">    task_queue_init(&amp;taskQueue, QUEUE);</span><br><span class="line">    <span class="keyword">char</span> buff[QUEUE][<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD; i++) &#123;</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, do_work, (<span class="keyword">void</span> *) &amp;taskQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sub = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FILE *fp = fopen(<span class="string">&quot;./25.thread_pool_text.c&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fgets(buff[sub++], <span class="number">1024</span>, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            task_queue_push(&amp;taskQueue, buff[sub]);</span><br><span class="line">            <span class="keyword">if</span> (sub == QUEUE) &#123;</span><br><span class="line">                <span class="comment">//满了</span></span><br><span class="line">                sub = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (taskQueue.total == taskQueue.size) &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (taskQueue.total&lt; taskQueue.size) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    usleep(<span class="number">10000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="7-多线程编程基础"><a href="#7-多线程编程基础" class="headerlink" title="7.多线程编程基础"></a>7.多线程编程基础</h1><p>pthread_create产生线程</p>
<p>谁生的线程</p>
<p>线程模型</p>
<p>内核线程在内核上产生的</p>
<p>用户线程在用户空间上产生的</p>
<p>pthread_t线程ID</p>
<p>判断线程是否相等？</p>
<p>不能用线程ID判断，用pthread_equal</p>
<p>pthread_exit()线程自杀</p>
<p>pthread_cancel线程自杀</p>
<p>exit()</p>
<p>pthread_join()等待另一个线程结束，</p>
<p>成功0，</p>
<p>pthread_detach<br>标记一个分离的线程，线程结束后，所有的有关线程的内容都会被释放</p>
<p>同时分离同一个线程为被定义</p>
<p>attr线程属性</p>
<p>pthread_yield()</p>
<p>让出处理器，</p>
<h1 id="8-socket编程"><a href="#8-socket编程" class="headerlink" title="8.socket编程"></a>8.socket编程</h1><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%883.54.54.png" alt="截屏2021-01-29 下午3.54.54"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.06.49.png" alt="截屏2021-01-29 下午4.06.49"></p>
<p>连接的本质是双方都保存一些变量，用来描述双方之间的状态</p>
<p>端口是一种计算机设备，就像一个大楼(计算机)里面的一个房间，一个大楼都会有一个独立的地址，可能会与多个地址，如果有多个地址，端口就是具体的房间后</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.22.00.png" alt="截屏2021-01-29 下午4.22.00"></p>
<p>序列号：第几回发送</p>
<p>确认应答号：确认收到1可以发送2了</p>
<p>字：32位，4字节=1字</p>
<p>字节</p>
<p>RST=reset重置连接</p>
<p>SYN=1,对方收到包，建立请求连接，如果正确恢复SYN</p>
<p>SYN+ACK二次握手</p>
<p>ACK三次握手</p>
<p>FIN结束包</p>
<p>检验和：检验包是否有问题，</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/image-20210129163616346.png" alt="image-20210129163616346"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.40.49.png" alt="截屏2021-01-29 下午4.40.49"></p>
<p>TCP的本质是字节流</p>
<p>listen切换套接字主动为被动</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.46.27.png" alt="截屏2021-01-29 下午4.46.27"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.54.09.png" alt="截屏2021-01-29 下午4.54.09"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.02.56.png" alt="截屏2021-01-29 下午5.02.56"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.04.51.png" alt="截屏2021-01-29 下午5.04.51"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.14.09.png" alt="截屏2021-01-29 下午5.14.09"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.20.19.png" alt="截屏2021-01-29 下午5.20.19"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.22.03.png" alt="截屏2021-01-29 下午5.22.03"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.24.01.png" alt="截屏2021-01-29 下午5.24.01"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.25.23.png" alt="截屏2021-01-29 下午5.25.23"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.25.44.png" alt="截屏2021-01-29 下午5.25.44"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.26.03.png" alt="截屏2021-01-29 下午5.26.03"></p>
<p>26.tcp.server.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_create</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;<span class="comment">//创建套接字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    addr.sin_port = htons(port);<span class="comment">//主机字节序转换成本地字节序</span></span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd, <span class="number">20</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>27.tcp.server.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义函数接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_create</span><span class="params">(<span class="keyword">int</span> port)</span></span>;<span class="comment">//创建套接字，参数端口</span></span><br></pre></td></tr></table></figure>


<p>28.tcp.client.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_connect</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span></span>;</span><br></pre></td></tr></table></figure>


<p>29.tcp.client.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_connect</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(port);</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>30.tcp.main.server.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_listen, sockfd, port;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((server_listen = socket_create(port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sockfd = accept(server_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Something is online\n&quot;</span>);</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//支持并发</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                recv(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv : %s\n&quot;</span>, buff);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>32.tcp.main.client.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd, port;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, ip[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s is port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(ip, argv[<span class="number">1</span>]);</span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket_connect(ip, port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before loop!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, buff);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strlen</span>(buff)) <span class="keyword">continue</span>;</span><br><span class="line">        send(sockfd, buff, <span class="built_in">strlen</span>(buff), <span class="number">0</span>);</span><br><span class="line">        bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gcc 30.tcp.main.server.c 26.tcp.server.c -o 31.tcp.server</span><br><span class="line">gcc 32.tcp.main.client.c 29.tcp.client.c -o 33.tcp.client</span><br><span class="line"></span><br><span class="line">./31.tcp.server 9000                      [130]</span><br><span class="line">Something is online</span><br><span class="line">recv : hello</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line">./33.tcp.client 8.129.127.2 9000</span><br><span class="line">before loop!</span><br><span class="line">hello</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>




<h1 id="输入一个网址发生了什么？"><a href="#输入一个网址发生了什么？" class="headerlink" title="输入一个网址发生了什么？"></a>输入一个网址发生了什么？</h1><p>端口复用：</p>
<p>from IP</p>
<p>from port</p>
<p>to ip</p>
<p>to port</p>
<p>singnal</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//26.tcp.server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_create</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;<span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;<span class="comment">//创建套接字,ipv4，socker流</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//有太多的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;<span class="comment">//协议组 IPV4</span></span><br><span class="line">    addr.sin_port = htons(port);<span class="comment">//端口，主机字节序转换成本地字节序</span></span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>) &#123;<span class="comment">//绑定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//端口被占用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd, <span class="number">20</span>) &lt; <span class="number">0</span>) &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//27.tcp.server.h</span></span><br><span class="line"><span class="comment">//定义函数接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_create</span><span class="params">(<span class="keyword">int</span> port)</span></span>;<span class="comment">//创建套接字，参数端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//30.tcp.main.server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_listen, sockfd, port;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((server_listen = socket_create(port)) &lt; <span class="number">0</span>) &#123;<span class="comment">//创建套接字</span></span><br><span class="line">        perror(<span class="string">&quot;socket_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//用于等待接收数据</span></span><br><span class="line">        <span class="keyword">if</span> ((sockfd = accept(server_listen, (struct sockaddr *)&amp;client, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);<span class="comment">//三次握手失败</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; is online\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            close(server_listen);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//</span></span><br><span class="line">                <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">char</span> tobuff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">size_t</span> ret = recv(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; is offline\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                    perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv &lt;%s&gt;: %s\n&quot;</span>, inet_ntoa(client.sin_addr), buff);</span><br><span class="line">                <span class="built_in">sprintf</span>(tobuff, <span class="string">&quot;I&#x27;ve recvd your message : %s!\n&quot;</span>, buff);</span><br><span class="line">                send(sockfd, tobuff, <span class="built_in">strlen</span>(tobuff), <span class="number">0</span>);<span class="comment">//发送给客户端</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&lt;Parent&gt; : 什么也不gan。。。\n&quot;</span>);</span><br><span class="line">            close(sockfd);<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc <span class="number">30.</span>tcp.main.server.c <span class="number">26.</span>tcp.server.c -o <span class="number">31.</span>tcp.server</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//28.tcp.client.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_connect</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//29.tcp.client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_connect</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(port);</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//32.tcp.main.client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ByeBye\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, ip[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s is port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(ip, argv[<span class="number">1</span>]);</span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    signal(SIGINT, logout);</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket_connect(ip, port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before loop!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;please&gt; : &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, buff);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strlen</span>(buff)) <span class="keyword">continue</span>;</span><br><span class="line">        send(sockfd, buff, <span class="built_in">strlen</span>(buff), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sending %s ...\n&quot;</span>, buff);</span><br><span class="line">        bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">        recv(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;server&gt; : %s\n&quot;</span>, buff);</span><br><span class="line">        bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc <span class="number">32.</span>tcp.main.client.c <span class="number">29.</span>tcp.client.c -o <span class="number">33.</span>tcp.client</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">./31.tcp.server 9000</span><br><span class="line">&lt;110.176.185.233&gt; is online</span><br><span class="line">&lt;Parent&gt; : 什么也不gan。。。</span><br><span class="line">recv &lt;110.176.185.233&gt;: hello</span><br><span class="line">recv &lt;110.176.185.233&gt;: hello 古子秋!</span><br><span class="line">&lt;110.176.185.233&gt; is offline</span><br><span class="line">recv: Success</span><br><span class="line"></span><br><span class="line">./33.tcp.client 8.129.127.2 9000</span><br><span class="line">before loop!</span><br><span class="line">&lt;please&gt; : hello</span><br><span class="line">sending hello ...</span><br><span class="line">&lt;server&gt; : I&#x27;ve recvd your message : hello!</span><br><span class="line"></span><br><span class="line">&lt;please&gt; : hello 古子秋!</span><br><span class="line">sending hello 古子秋! ...</span><br><span class="line">&lt;server&gt; : I&#x27;ve recvd your message : hello 古子秋!!</span><br><span class="line"></span><br><span class="line">&lt;please&gt; : ^CByeBye</span><br></pre></td></tr></table></figure>






<h1 id="0000000"><a href="#0000000" class="headerlink" title="0000000"></a>0000000</h1><h1 id="0作业"><a href="#0作业" class="headerlink" title="0作业"></a>0作业</h1><h2 id="0-1-作业1-ls实现"><a href="#0-1-作业1-ls实现" class="headerlink" title="0.1 作业1:ls实现"></a>0.1 作业1:ls实现</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%8811.11.26.png" alt="截屏2021-01-05 上午11.11.26"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="0-2-ls作业-gt-opendir"><a href="#0-2-ls作业-gt-opendir" class="headerlink" title="0.2 ls作业-&gt;opendir()"></a>0.2 ls作业-&gt;opendir()</h2><blockquote>
<p>opendir()</p>
<p>readdir()</p>
<p>closedir()</p>
<p>ftell()</p>
<p>readdir()</p>
</blockquote>
<p>man getpwpid getpwuid getgrgid</p>
<p>0</p>
<p>锁：数据保护，互斥，</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/fc73bb52fe85013f9d2b4713814cfa29.jpg" alt="fc73bb52fe85013f9d2b4713814cfa29"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;00.head.h&quot;</span></span></span><br><span class="line"><span class="comment">//#define INS 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> num_file[] = <span class="string">&quot;./.num&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> lock_file[] = <span class="string">&quot;./.lock&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> <span class="title">num</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">set_num</span><span class="params">(struct Msg *msg)</span> </span>&#123;</span><br><span class="line">    FILE *f = fopen(num_file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(f);</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> nwrite = fwrite(msg, <span class="number">1</span>, <span class="keyword">sizeof</span>(struct Msg), f);</span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="keyword">return</span> nwrite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_num</span><span class="params">(struct Msg *msg)</span> </span>&#123;</span><br><span class="line">    FILE *f = fopen(num_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(f);</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> nread = fread(msg, <span class="number">1</span>, <span class="keyword">sizeof</span>(struct Msg), f);</span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="keyword">return</span> nread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_add</span><span class="params">(<span class="keyword">int</span> end, <span class="keyword">int</span> pid_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FILE *lock = fopen(lock_file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        flock(lock-&gt;_fileno, LOCK_EX);</span><br><span class="line">        <span class="keyword">if</span> (get_num(&amp;num) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fclose(lock);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num.now &gt; end) &#123;</span><br><span class="line">            fclose(lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num.sum += num.now;</span><br><span class="line">        num.now++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the %dth child : now = %d, sum = %d\n&quot;</span>, pid_num, num.now, num.sum);</span><br><span class="line">        set_num(&amp;num);</span><br><span class="line">        flock(lock-&gt;_fileno, LOCK_UN);</span><br><span class="line">        fclose(lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt, start = <span class="number">0</span>, end = <span class="number">0</span>, ins = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;s:e:i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            start = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            end = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            ins = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -s start_num -e end_num -i\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start = %d\n end = %d\n&quot;</span>, start, end);</span><br><span class="line"></span><br><span class="line">    num.now = <span class="number">0</span>;</span><br><span class="line">    num.sum = <span class="number">0</span>;</span><br><span class="line">    set_num(&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ins; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//孩子</span></span><br><span class="line">            x = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ins; i++) &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printf(&quot;I am father!\n&quot;);</span></span><br><span class="line">        <span class="comment">//sleep(100);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        do_add(end, x);</span><br><span class="line">    &#125;</span><br><span class="line">    get_num(&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, num.sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">./a.out -s 0 -e 100 -i 10                                                                   [0]</span><br><span class="line">start = 0</span><br><span class="line"> end = 100</span><br><span class="line">the 1th child : now = 1, sum = 0</span><br><span class="line">the 7th child : now = 2, sum = 1</span><br><span class="line">the 1th child : now = 3, sum = 3</span><br><span class="line">the 7th child : now = 4, sum = 6</span><br><span class="line">the 1th child : now = 5, sum = 10</span><br><span class="line">the 7th child : now = 6, sum = 15</span><br><span class="line">the 1th child : now = 7, sum = 21</span><br><span class="line">the 7th child : now = 8, sum = 28</span><br><span class="line">the 1th child : now = 9, sum = 36</span><br><span class="line">the 7th child : now = 10, sum = 45</span><br><span class="line">the 1th child : now = 11, sum = 55</span><br><span class="line">the 7th child : now = 12, sum = 66</span><br><span class="line">the 7th child : now = 13, sum = 78</span><br><span class="line">the 7th child : now = 14, sum = 91</span><br><span class="line">the 1th child : now = 15, sum = 105</span><br><span class="line">the 7th child : now = 16, sum = 120</span><br><span class="line">the 1th child : now = 17, sum = 136</span><br><span class="line">the 7th child : now = 18, sum = 153</span><br><span class="line">the 1th child : now = 19, sum = 171</span><br><span class="line">the 2th child : now = 20, sum = 190</span><br><span class="line">the 1th child : now = 21, sum = 210</span><br><span class="line">the 1th child : now = 22, sum = 231</span><br><span class="line">the 3th child : now = 23, sum = 253</span><br><span class="line">the 1th child : now = 24, sum = 276</span><br><span class="line">the 3th child : now = 25, sum = 300</span><br><span class="line">the 1th child : now = 26, sum = 325</span><br><span class="line">the 3th child : now = 27, sum = 351</span><br><span class="line">the 1th child : now = 28, sum = 378</span><br><span class="line">the 3th child : now = 29, sum = 406</span><br><span class="line">the 1th child : now = 30, sum = 435</span><br><span class="line">the 6th child : now = 31, sum = 465</span><br><span class="line">the 1th child : now = 32, sum = 496</span><br><span class="line">the 3th child : now = 33, sum = 528</span><br><span class="line">the 1th child : now = 34, sum = 561</span><br><span class="line">the 6th child : now = 35, sum = 595</span><br><span class="line">the 1th child : now = 36, sum = 630</span><br><span class="line">the 3th child : now = 37, sum = 666</span><br><span class="line">the 1th child : now = 38, sum = 703</span><br><span class="line">the 6th child : now = 39, sum = 741</span><br><span class="line">the 1th child : now = 40, sum = 780</span><br><span class="line">the 2th child : now = 41, sum = 820</span><br><span class="line">the 1th child : now = 42, sum = 861</span><br><span class="line">the 2th child : now = 43, sum = 903</span><br><span class="line">the 2th child : now = 44, sum = 946</span><br><span class="line">the 3th child : now = 45, sum = 990</span><br><span class="line">the 2th child : now = 46, sum = 1035</span><br><span class="line">the 1th child : now = 47, sum = 1081</span><br><span class="line">the 2th child : now = 48, sum = 1128</span><br><span class="line">the 2th child : now = 49, sum = 1176</span><br><span class="line">the 1th child : now = 50, sum = 1225</span><br><span class="line">the 2th child : now = 51, sum = 1275</span><br><span class="line">the 1th child : now = 52, sum = 1326</span><br><span class="line">the 2th child : now = 53, sum = 1378</span><br><span class="line">the 1th child : now = 54, sum = 1431</span><br><span class="line">the 7th child : now = 55, sum = 1485</span><br><span class="line">the 7th child : now = 56, sum = 1540</span><br><span class="line">the 7th child : now = 57, sum = 1596</span><br><span class="line">the 1th child : now = 58, sum = 1653</span><br><span class="line">the 6th child : now = 59, sum = 1711</span><br><span class="line">the 1th child : now = 60, sum = 1770</span><br><span class="line">the 2th child : now = 61, sum = 1830</span><br><span class="line">the 1th child : now = 62, sum = 1891</span><br><span class="line">the 1th child : now = 63, sum = 1953</span><br><span class="line">the 1th child : now = 64, sum = 2016</span><br><span class="line">the 4th child : now = 65, sum = 2080</span><br><span class="line">the 1th child : now = 66, sum = 2145</span><br><span class="line">the 4th child : now = 67, sum = 2211</span><br><span class="line">the 1th child : now = 68, sum = 2278</span><br><span class="line">the 4th child : now = 69, sum = 2346</span><br><span class="line">the 1th child : now = 70, sum = 2415</span><br><span class="line">the 4th child : now = 71, sum = 2485</span><br><span class="line">the 1th child : now = 72, sum = 2556</span><br><span class="line">the 4th child : now = 73, sum = 2628</span><br><span class="line">the 1th child : now = 74, sum = 2701</span><br><span class="line">the 4th child : now = 75, sum = 2775</span><br><span class="line">the 4th child : now = 76, sum = 2850</span><br><span class="line">the 1th child : now = 77, sum = 2926</span><br><span class="line">the 4th child : now = 78, sum = 3003</span><br><span class="line">the 1th child : now = 79, sum = 3081</span><br><span class="line">the 3th child : now = 80, sum = 3160</span><br><span class="line">the 1th child : now = 81, sum = 3240</span><br><span class="line">the 2th child : now = 82, sum = 3321</span><br><span class="line">the 1th child : now = 83, sum = 3403</span><br><span class="line">the 1th child : now = 84, sum = 3486</span><br><span class="line">the 6th child : now = 85, sum = 3570</span><br><span class="line">the 6th child : now = 86, sum = 3655</span><br><span class="line">the 4th child : now = 87, sum = 3741</span><br><span class="line">the 3th child : now = 88, sum = 3828</span><br><span class="line">the 1th child : now = 89, sum = 3916</span><br><span class="line">the 2th child : now = 90, sum = 4005</span><br><span class="line">the 1th child : now = 91, sum = 4095</span><br><span class="line">the 2th child : now = 92, sum = 4186</span><br><span class="line">the 1th child : now = 93, sum = 4278</span><br><span class="line">the 3th child : now = 94, sum = 4371</span><br><span class="line">the 4th child : now = 95, sum = 4465</span><br><span class="line">the 6th child : now = 96, sum = 4560</span><br><span class="line">the 6th child : now = 97, sum = 4656</span><br><span class="line">the 6th child : now = 98, sum = 4753</span><br><span class="line">the 4th child : now = 99, sum = 4851</span><br><span class="line">the 6th child : now = 100, sum = 4950</span><br><span class="line">the 1th child : now = 101, sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br><span class="line">sum = 5050</span><br></pre></td></tr></table></figure>
<p>flock</p>
<h1 id="1-作业2"><a href="#1-作业2" class="headerlink" title="1.作业2"></a>1.作业2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">命令.&#x2F;test -m &quot;msg&quot;</span><br><span class="line">结果输出：msg</span><br><span class="line">命令.&#x2F;test</span><br><span class="line">vim a.txt</span><br><span class="line">input msg</span><br><span class="line">printf msg</span><br><span class="line">delete a.txt</span><br><span class="line">模拟过程，可能需要3个进程</span><br></pre></td></tr></table></figure>


<p>ls，ls -al,</p>
<p>分列显示，有排序</p>
<p>显示/不显示隐藏文件，</p>
<h1 id="0-end"><a href="#0-end" class="headerlink" title="0.end"></a>0.end</h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://guziqiu.cn/2020/12/29/06.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">网络编程</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/12/29/07.%E4%B9%A0%E9%A2%98%E7%AD%94%E7%96%91/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            习题答疑
          
        </div>
      </a>
    
    
      <a href="/2020/12/22/03.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">基础数据结构</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021
        <i class="ri-heart-fill heart_icon"></i> guziqiu
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.jpeg" alt="古子秋"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>