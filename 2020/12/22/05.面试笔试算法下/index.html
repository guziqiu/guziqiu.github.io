<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="关键字" />
   
  <meta name="description" content="说明" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    面试笔试算法 |  古子秋
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-05.面试笔试算法下"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  面试笔试算法
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/12/22/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E4%B8%8B/" class="article-date">
  <time datetime="2020-12-22T00:08:15.000Z" itemprop="datePublished">2020-12-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95/">面试笔试算法</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">16.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">78 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-线段树"><a href="#1-线段树" class="headerlink" title="1.线段树"></a>1.线段树</h1><h2 id="0-线段树结构"><a href="#0-线段树结构" class="headerlink" title="0.线段树结构"></a>0.线段树结构</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.22.png" alt="截屏2020-12-31 上午11.32.22" style="zoom: 50%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.35.png" alt="截屏2020-12-31 上午11.32.35" style="zoom:50%;" />





<h2 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1.问题背景"></a>1.问题背景</h2><ol>
<li>单点修改，区间查询（基础版）</li>
<li>区间修改，区间查询（进阶版）</li>
<li>单点修改，单点查询（用不着线段树）</li>
<li>区间修改，单点查询（是第二种情况的特例）</li>
</ol>
<h2 id="2-线段树区间查询及单点修改"><a href="#2-线段树区间查询及单点修改" class="headerlink" title="2.线段树区间查询及单点修改"></a>2.线段树区间查询及单点修改</h2><h3 id="1-操作"><a href="#1-操作" class="headerlink" title="1.操作"></a>1.操作</h3><p>Modify(7,9) ：修改7位置上的值为9</p>
<p>Query(2, 6) : 查询[2,6]区间的和值==&gt; 30</p>
<p>Modify(2,3) ：修改2位置上的值为3</p>
<p>Query(2, 6) : 查询[2,6]区间的和值==&gt; 25</p>
<a id="more"></a>

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.10.png" alt="截屏2020-12-31 上午11.32.10" style="zoom:50%;" />



<h3 id="2-具体过程"><a href="#2-具体过程" class="headerlink" title="2.具体过程"></a>2.具体过程</h3><p>1）Modify(2,3)<!--图中0--1出有错误,tree[0]=8 --></p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.42.png" alt="截屏2020-12-31 上午11.32.42" style="zoom:50%;" />



<p>2）将2上面的值改为3</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.48.png" alt="截屏2020-12-31 上午11.32.48" style="zoom:50%;" />

<p>3）更新根节点上的和值</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.56.png" alt="截屏2020-12-31 上午11.32.56" style="zoom:50%;" />

<p>4）Query(2, 6) :</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.33.02.png" alt="截屏2020-12-31 上午11.33.02" style="zoom:50%;" />





<h2 id="3-基础版线段树"><a href="#3-基础版线段树" class="headerlink" title="3.基础版线段树"></a>3.基础版线段树</h2><ol>
<li>线段树是对于一维序列的一种维护结构</li>
<li>采用的分治的思想，将总区间分成左右两部分，一直进行下去，直到区间中只剩下一个节点为止</li>
<li>线段树的叶子结点，代表了原序列中的单个位置的值</li>
<li>如果采用完全二叉树的存储结构的话，最起码需要 $4n$ 的存储空间</li>
<li>当面对区间修改的时候，基础版的线段树效率上还不如直接在一维序列上修改</li>
<li>只适用于单点修改，区间查询</li>
</ol>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.37.41.png" alt="截屏2020-12-31 上午11.37.41"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//海贼OJ222</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> max_num;<span class="comment">//结点和值</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">&#125; tree[MAX_N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> arr[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> ind)</span> </span>&#123;<span class="comment">//更新结点的和值</span></span><br><span class="line">    tree[ind].max_num = max(tree[ind &lt;&lt; <span class="number">1</span>].max_num, tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].max_num);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//创建线段树,在tree[ind]上插入l，r</span></span><br><span class="line">    tree[ind].l = l;</span><br><span class="line">    tree[ind].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;<span class="comment">//l==r，l、r各代表一个值，不能再分裂</span></span><br><span class="line">        tree[ind].max_num = arr[l];<span class="comment">//将值挂在叶子结点上</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build_tree(ind * <span class="number">2</span>, l, mid);<span class="comment">//递归左子树</span></span><br><span class="line">    build_tree(ind * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);<span class="comment">//递归右子树</span></span><br><span class="line">    update(ind);<span class="comment">//更新和值</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;<span class="comment">//修改tree[ind]上tree[k]的值为value,ind代表当前节点的编号</span></span><br><span class="line">    <span class="keyword">if</span> (tree[ind].l == tree[ind].r) &#123;</span><br><span class="line">        tree[ind].max_num = val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[ind].l + tree[ind].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= mid ) &#123;</span><br><span class="line">        modify(ind &lt;&lt; <span class="number">1</span>, k, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        modify(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, k, val);</span><br><span class="line">    &#125;</span><br><span class="line">    update(ind);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">//查询[x,y]的和值</span></span><br><span class="line">    <span class="keyword">if</span> (tree[ind].l &gt;= x &amp;&amp; tree[ind].r &lt;= y) &#123;<span class="comment">//要查找的值在这个根的</span></span><br><span class="line">        <span class="keyword">return</span> tree[ind].max_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[ind].l + tree[ind].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= x) &#123;<span class="comment">//在左子树中查找</span></span><br><span class="line">        ans = max(ans, Query(ind &lt;&lt; <span class="number">1</span>, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) &#123;<span class="comment">//在右子树中查找</span></span><br><span class="line">        ans = max(ans, Query(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    build_tree(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: modify(<span class="number">1</span>, b, c); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (b &gt; c) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-2147483648&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; Query(<span class="number">1</span>, b, c) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>==&gt;总结</p>
<p>单点查询：log(n)</p>
<p>区间查询：log(n)</p>
<blockquote>
<p>1.若采用完全能二叉树的存储方式，n个节点的线段树，最多需要多少个节点空间？</p>
<p>$n + n - 1 + 2n = 4n -1$</p>
<p>2.如何做区间修改</p>
</blockquote>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8810.56.59.png" alt="截屏2020-12-31 下午10.56.59"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8810.59.54.png" alt="截屏2020-12-31 下午10.59.54"></p>
<p>其实节点上l，r可以省略</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.01.08.png" alt="截屏2020-12-31 下午11.01.08"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//海贼OJ222</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> max_num;<span class="comment">//子树的和值</span></span><br><span class="line">&#125; tree[MAX_N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> arr[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> ind)</span> </span>&#123;<span class="comment">//更新结点的和值</span></span><br><span class="line">    tree[ind].max_num = max(tree[ind &lt;&lt; <span class="number">1</span>].max_num, tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].max_num);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//创建线段树,在ind上插入l，r</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;<span class="comment">//l==r，l、r各代表一个值，不能再分裂</span></span><br><span class="line">        tree[ind].max_num = arr[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build_tree(ind * <span class="number">2</span>, l, mid);</span><br><span class="line">    build_tree(ind * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    update(ind);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;<span class="comment">//在tree[ind](ind当前节点位置）维护的区间[l, r],上将tree[k]的值修改为val、</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[ind].max_num = val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= mid ) &#123;</span><br><span class="line">        modify(ind &lt;&lt; <span class="number">1</span>, l, mid, k, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        modify(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, k, val);</span><br><span class="line">    &#125;</span><br><span class="line">    update(ind);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">//查询</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;<span class="comment">//要查找的值在这个根的</span></span><br><span class="line">        <span class="keyword">return</span> tree[ind].max_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= x) &#123;<span class="comment">//在左子树中查找</span></span><br><span class="line">        ans = max(ans, Query(ind &lt;&lt; <span class="number">1</span>, l, mid, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) &#123;<span class="comment">//在右子树中查找</span></span><br><span class="line">        ans = max(ans, Query(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<span class="comment">//n,数组长度，m,操作数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    build_tree(<span class="number">1</span>, <span class="number">1</span>, n);<span class="comment">//初始化线段树tree,根节点的范围是[1, n]</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: modify(<span class="number">1</span>, <span class="number">1</span>, n, b, c); <span class="keyword">break</span>;<span class="comment">//在根节点[1, n]上修改tree[b]的值为c</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (b &gt; c) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-2147483648&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; Query(<span class="number">1</span>, <span class="number">1</span>, n, b, c) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//在根节点tree[1,n]上查找[b, c]区间上的和值</span></span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="5-线段树区间修改"><a href="#5-线段树区间修改" class="headerlink" title="5.线段树区间修改"></a>5.线段树区间修改</h2><p>明朝时期有一位官员，皇帝下放粮食，下发到县令手里，县令自己拿着粮食，不下发，突然有一天，皇帝要微服私访，此时县令下发粮食</p>
<h3 id="1-Modify-0-6-3"><a href="#1-Modify-0-6-3" class="headerlink" title="1.Modify(0, 6, +3)"></a>1.Modify(0, 6, +3)</h3><p>1)在区间[0, 6]的结点上加3，此时在懒标记上加3而不是在叶子结点上加3，县令自己拿了粮食不下发给百姓</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.02.12.png" alt="截屏2020-12-31 下午11.02.12" style="zoom: 67%;" />



<p>2)叶子结点的值不变，但是区间根节点的值发生改变，农民没有拿到粮食，但是县令拿到了，县令上报农民已经拿到了粮食，向上更新区间和值</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.05.35.png" alt="截屏2020-12-31 下午11.05.35" style="zoom: 67%;" />

<h3 id="2-Query-2-7"><a href="#2-Query-2-7" class="headerlink" title="2.Query(2,7)"></a>2.Query(2,7)</h3><p>1）查询[2,7]区间上的和值</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.07.33.png" alt="截屏2020-12-31 下午11.07.33" style="zoom:67%;" />



<p>2）开始递归向下查找</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.08.27.png" alt="截屏2020-12-31 下午11.08.27" style="zoom:67%;" />





<p>3） <code>2 &lt; 4</code>  = ( 9 / 2) 到左子树查找</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.09.27.png" alt="截屏2020-12-31 下午11.09.27" style="zoom:67%;" />



<p>4)左子树中有懒标记，皇帝要来视察民情，县令下方粮食，懒标记下沉，</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.09.58.png" alt="截屏2020-12-31 下午11.09.58" style="zoom:67%;" />



<ol start="5">
<li><p>继续向下查询，</p>
<p><code>2 = 2</code>  = ( 4 / 2 )  向左子树递归</p>
</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.10.12.png" alt="截屏2020-12-31 下午11.10.12" style="zoom:67%;" />



<p>6)左子树有懒标记，懒标记下沉</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.10.24.png" alt="截屏2020-12-31 下午11.10.24" style="zoom:67%;" />



<ol start="7">
<li><code>2 &gt; 1</code> = 2 / 2 ,在右子树中查询，</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.10.38.png" alt="截屏2020-12-31 下午11.10.38" style="zoom:67%;" />



<p>8）找到节点2,更新结点的值，返回节点2的值</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.10.57.png" alt="截屏2020-12-31 下午11.10.57" style="zoom:67%;" />



<ol start="9">
<li>向上回溯，(4/2 + 1) = <code>3 &gt; 2</code>，4 &lt; 7  递归到右子树</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.11.10.png" alt="截屏2020-12-31 下午11.11.10" style="zoom:67%;" />



<ol start="10">
<li>结点的区间在待查找区间范围内，直接返回3-4结点的值</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.11.22.png" alt="截屏2020-12-31 下午11.11.22" style="zoom:67%;" />



<p>11） 向上回溯，(0 + 9) / 2  + 1= 5  &lt; 7 递归到右结点5–-9</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.11.39.png" alt="截屏2020-12-31 下午11.11.39" style="zoom:67%;" />





<p>12） (5 + 9) / 2 = 7 == 7,递归5–9左子树</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.11.51.png" alt="截屏2020-12-31 下午11.11.51" style="zoom:67%;" />

<ol start="13">
<li>找到结点 ，返回值</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.12.06.png" alt="截屏2020-12-31 下午11.12.06" style="zoom:67%;" />



<ol start="14">
<li>向上回溯，返回区间和值</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.12.16.png" alt="截屏2020-12-31 下午11.12.16" style="zoom:67%;" />







<h2 id="6-进阶版线段树"><a href="#6-进阶版线段树" class="headerlink" title="6.进阶版线段树"></a>6.进阶版线段树</h2><ol>
<li>优化掉了代码实现中的：l，r。区间变量</li>
<li>可以用于区间更新，区间查询</li>
<li>增加了懒标记，达到能够区间更新的目的</li>
<li>懒标记是需要向下下沉的</li>
<li>==标记下沉发生在递归之前，向上更新发生在具有修改操作的递归之后==</li>
</ol>
<h2 id="7-代码实现"><a href="#7-代码实现" class="headerlink" title="7.代码实现"></a>7.代码实现</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8810.48.39.png" alt="截屏2020-12-31 下午10.48.39"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> intl;</span><br><span class="line">intl flag = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    intl sum;<span class="comment">//和值</span></span><br><span class="line">    intl tag;<span class="comment">//懒标记</span></span><br><span class="line">&#125; tree[MAX_N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">intl arr[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(intl ind)</span> </span>&#123;<span class="comment">//更新tee[ind]结点和值</span></span><br><span class="line">    tree[ind].sum = tree[ind &lt;&lt; <span class="number">1</span>].sum + tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    <span class="comment">//tree[ind].sum = tree[ind * 2].sum + tree[ind * 2 + 1].sum;</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(intl index, intl left, intl right)</span> </span>&#123;<span class="comment">//懒标记下沉</span></span><br><span class="line">    <span class="keyword">if</span> (tree[index].tag) &#123;<span class="comment">//如果存在懒标记值 &gt; 0</span></span><br><span class="line">        intl mid = (left + right) &gt;&gt;  <span class="number">1</span>;</span><br><span class="line">        intl value = tree[index].tag;</span><br><span class="line">        tree[index &lt;&lt; <span class="number">1</span>].sum += value * (mid - left + <span class="number">1</span>);<span class="comment">//懒标记下沉左子树</span></span><br><span class="line">        tree[index &lt;&lt; <span class="number">1</span>].tag += value;</span><br><span class="line">        tree[index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += value * (right - mid);<span class="comment">//right - (mid + 1)+1//懒标记下沉右子树</span></span><br><span class="line">        tree[index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].tag += value;</span><br><span class="line">        tree[index].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(intl index, intl left, intl right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//初始化线段树tree[index],线段树区间为[left, right],right = n,即有n个值要存在线段树中</span></span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;<span class="comment">//左右区间相等，即为叶子节点，存放值</span></span><br><span class="line">        tree[index].sum = arr[left];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    intl mid = (left + right) &gt;&gt;  <span class="number">1</span>;</span><br><span class="line">    build_tree(index &lt;&lt; <span class="number">1</span>, left, mid);<span class="comment">//</span></span><br><span class="line">    build_tree(index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">    update(index);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(intl index, intl left, intl right, intl x, intl y, intl value)</span> </span>&#123;</span><br><span class="line">    <span class="function">flag &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;modify(%lld, %lld, %lld) : %lld, %lld, %lld, %lld\n&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                       x, y, value, index, left, right, tree[index].sum</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">    <span class="comment">//从根节点tree[index]开始查询，根节点的区间是[left, right],找到区间[x, y],把[x, y]区间上的值加上value</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= left &amp;&amp; right &lt;= y) &#123;<span class="comment">//待操作区间在包含区间的范围内，即要修改的区间比根节点区间大</span></span><br><span class="line">        tree[index].sum += value * (right - left + <span class="number">1</span>);</span><br><span class="line">        tree[index].tag += value;<span class="comment">//懒标记，皇帝给农民发放粮食，县令不放</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    down(index, left, right);<span class="comment">//懒标记下沉，皇帝要微服私访，县令下发粮食</span></span><br><span class="line">    intl mid = (left + right) &gt;&gt;  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= x) &#123;</span><br><span class="line">        modify(index &lt;&lt; <span class="number">1</span>, left, mid, x, y, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) &#123;</span><br><span class="line">        modify (index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, x, y, value);</span><br><span class="line">    &#125;</span><br><span class="line">    update(index);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">intl <span class="title">Query</span><span class="params">(intl index, intl left, intl right, intl x, intl y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= left &amp;&amp; right &lt;= y) &#123;<span class="comment">//要查询的区间[x, y]在[left, right]范围内</span></span><br><span class="line">        <span class="keyword">return</span> tree[index].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    down(index, left, right);</span><br><span class="line">    intl mid = (left + right) &gt;&gt;  <span class="number">1</span>;</span><br><span class="line">    intl ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= x) &#123;</span><br><span class="line">        ans += Query(index &lt;&lt; <span class="number">1</span>, left, mid, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) &#123;</span><br><span class="line">        ans += Query(index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    intl n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (intl i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, arr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    build_tree(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    intl a, b, c, d;</span><br><span class="line">    <span class="keyword">for</span> (intl i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">                    modify(<span class="number">1</span>, <span class="number">1</span>, n, b, c, d);</span><br><span class="line">                &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (b &gt; c) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>( <span class="string">&quot;0\n&quot;</span> );</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Query(<span class="number">1</span>, <span class="number">1</span>, n, b, c));<span class="comment">//从根节点开始查询，根节点的范围是[1,n],查询[b,c]区间范围内的值</span></span><br><span class="line">                &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="2-从递推动归-上"><a href="#2-从递推动归-上" class="headerlink" title="2.从递推动归(上)"></a>2.从递推动归(上)</h1><h2 id="1-兔子繁殖问题"><a href="#1-兔子繁殖问题" class="headerlink" title="1.兔子繁殖问题"></a>1.兔子繁殖问题</h2><p>兔子繁殖问题：斐波那切数列</p>
<p><strong>题目：</strong>如果1对兔子每月能生1对小兔子，而每对小兔在它出生后的第3个月就可以生1对小兔子，如果从1对初生的小兔子开始，1年后能繁殖多少兔子?</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%888.10.32.png" alt="截屏2021-01-01 下午8.10.32" style="zoom: 80%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/IMG_20210101_194745.jpg" style="zoom:15%;" />





<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%888.12.49.png" alt="截屏2021-01-01 下午8.12.49"></p>
<blockquote>
<p>思考：当存在n = 40,程序会有什么问题？当n=60呢？</p>
</blockquote>
<ol>
<li><p>程序运行效率问题(会出现重复计算的现象，如下图)</p>
<p>解决方法：递归过程加记忆化(用数组记忆)  或  改成逆向递推求解(从f(1)求解到f(n),利用循环求解)</p>
</li>
<li><p>程序计算结果超出整数范围，结果溢出出错</p>
<p>解决方法：改成大整数求解</p>
</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%888.15.11.png" alt="截屏2021-01-01 下午8.15.11" style="zoom:67%;" />





<h2 id="2-如何求解递推问题"><a href="#2-如何求解递推问题" class="headerlink" title="2.如何求解递推问题"></a>2.如何求解递推问题</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%888.27.42.png" alt="截屏2021-01-01 下午8.27.42" style="zoom: 80%;" />



<blockquote>
<p>递推问题求解套路</p>
</blockquote>
<ol>
<li>确定递推状态，一个数学符号 + 一个数学符号的语义解释</li>
<li>确定递推公式，推导递推状态符号的自我表示方法</li>
<li>程序实现，（递归+记忆化 / 循环实现）</li>
</ol>
<h3 id="确定递推状态"><a href="#确定递推状态" class="headerlink" title="确定递推状态"></a>确定递推状态</h3><p>注意：这是学习递推问题的重中之重。学习确定递推状态的技巧。</p>
<p>$f(x) = y$</p>
<p>y：问题中的求解量，也是我们所谓的因变量</p>
<p>x：问题中直接影响求解量的部分，也是我们所谓的自变量</p>
<p>本质：就是寻找问题中的自变量与因变量</p>
<h3 id="推导递推公式"><a href="#推导递推公式" class="headerlink" title="推导递推公式"></a>推导递推公式</h3><p>本质：分析状态中的容斥关系(互相排斥)</p>
<p>$f(n)=f(n-1)+f(n-2)$</p>
<p>$f(n-1)$，代表 n-1个月的兔子数量，恰巧等于第 n 个月的成年兔子数量</p>
<p>$f(n-2)$，代表 n-2个月的兔子数量，恰巧等于第 n 个月的幼年兔子数量</p>
<p>所谓的推导，就是推导上面的这两句话的内容</p>
<h2 id="3-爬楼梯问题"><a href="#3-爬楼梯问题" class="headerlink" title="3.爬楼梯问题"></a>3.爬楼梯问题</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lALPDiQ3NHubpPPNB3LNCzg_2872_1906.png_720x720g.jpg" alt="lALPDiQ3NHubpPPNB3LNCzg_2872_1906.png_720x720g" style="zoom:80%;" />



<h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><p>$f(n)$ 代表爬 n 节楼梯的方法总数</p>
<h3 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h3><p>$f(n)=f(n - 2) + f(n - 3)$</p>
<p>==&gt;用容斥原理对最后一种台阶的情况进行分类，展开讨论，分类后求和(站在最后面往前看)</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%8811.03.04.png" alt="截屏2021-01-01 下午11.03.04" style="zoom:67%;" />

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%8811.00.14.png" alt="截屏2021-01-01 下午11.00.14" style="zoom:67%;" />





<h2 id="4-凑钱币问题"><a href="#4-凑钱币问题" class="headerlink" title="4.凑钱币问题"></a>4.凑钱币问题</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lALPDgfLP1Vs-lrNCBrNC5Q_2964_2074.png_720x720g.jpg" alt="lALPDgfLP1Vs-lrNCBrNC5Q_2964_2074.png_720x720g"></p>
<h3 id="状态定义-1"><a href="#状态定义-1" class="headerlink" title="状态定义"></a>状态定义</h3><p>$f(n, m)$ 代表用前 n 种钱币，拼凑 m 元钱的方案总数</p>
<h3 id="递推公式-1"><a href="#递推公式-1" class="headerlink" title="递推公式"></a>递推公式</h3><p>$f(n, m) = f(n - 1, m) + f(n, m - val[n])*1$</p>
<p>没有使用n种钱币的方法+使用n种钱币的方法（拼凑m元钱的方案中减去最后一种钱币金额，确保最后一种金额只能为第n中钱币，即val[n]）</p>
<p>==&gt;递推技巧：用容斥原理对最后一种钱币讨论：（使用了第n种钱币/没有使用第n种钱币）拼凑了m元钱 </p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lADPDhYBOei5ckPNA3_NBQA_1280_895.jpg_720x720g.jpg" alt="lADPDhYBOei5ckPNA3_NBQA_1280_895.jpg_720x720g" style="zoom:80%;" />





<h2 id="5-墙壁涂色"><a href="#5-墙壁涂色" class="headerlink" title="5.墙壁涂色"></a>5.墙壁涂色</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lALPDhYBOeiGuN3NB-7NC1w_2908_2030.png_720x720g-1.jpg" alt="lALPDhYBOeiGuN3NB-7NC1w_2908_2030.png_720x720g-1"></p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>技巧：先按照非环情况做，保证所有方案之间，相邻墙壁颜色不同，最后再保证首尾颜色不同</p>
<h4 id="状态定义-2"><a href="#状态定义-2" class="headerlink" title="状态定义"></a>状态定义</h4><p>$f(n, i, j)$ 代表 n 块墙壁，第一块涂颜色 i，最后一块涂颜色 j 的方案总数</p>
<h4 id="递推公式-2"><a href="#递推公式-2" class="headerlink" title="递推公式"></a>递推公式</h4><p>$f(n, i, j) = \sum_{k}{f(n-1,i,k)}\ |\ k \ne j$</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lADPDhJzu0Qm8ZvNA3_NBQA_1280_895.jpg_720x720g.jpg" alt="lADPDhJzu0Qm8ZvNA3_NBQA_1280_895.jpg_720x720g" style="zoom:80%;" />

<hr>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>基于第一种做法，优化状态定义，忽略第一块的颜色</p>
<p>$f(n, 2, 3) == f(n, 1 , 3)$,即可以忽略i这个变量，变成隐藏的变量</p>
<h4 id="状态定义-3"><a href="#状态定义-3" class="headerlink" title="状态定义"></a>状态定义</h4><p>$f(n, j)$ 代表 n 块墙壁，第一块涂颜色 0，最后一块涂颜色 j 的方案总数，总方案数：$f(n,j)*3$</p>
<h4 id="递推公式-3"><a href="#递推公式-3" class="headerlink" title="递推公式"></a>递推公式</h4><p>$f(n, j) = \sum_{k}{f(n-1,k)}\ |\ k \ne j$</p>
<p>==&gt;$(f(n,1) + f(n,2))*3 = f(n,1) * 6$</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lADPDgfLP1XmGrbNA3_NBQA_1280_895.jpg_720x720g.jpg" alt="lADPDgfLP1XmGrbNA3_NBQA_1280_895.jpg_720x720g" style="zoom:80%;" />









<hr>
<h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><p>单刀直入，直接定义状态，求什么定义什么</p>
<h4 id="状态定义-4"><a href="#状态定义-4" class="headerlink" title="状态定义"></a>状态定义</h4><p>$f(n)$ 代表 n 块墙壁，首尾颜色不同的方法总数</p>
<h4 id="递推公式-4"><a href="#递推公式-4" class="headerlink" title="递推公式"></a>递推公式</h4><p>$f(n) = f(n-1) + 2 \times f(n-2)$</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lADPDg7mPJ-KA9LNA3_NBQA_1280_895.jpg_720x720g.jpg" alt="lADPDg7mPJ-KA9LNA3_NBQA_1280_895.jpg_720x720g" style="zoom:80%;" />



<p>1，3不同的方案总数，1，3不同，4颜色一定，3属于正常状态，所以1，3不同的方案总数为$1 \times f(n-1) = f(n-1)$</p>
<p>1和3颜色不同的方法，1，3颜色不同  ==&gt;1,2相同颜色，即1，3颜色不同的方案总数等于1，2相同颜色的方案总数；1，2不同的方案总数为$f(n-2)$,由于4有两种方案，计算总方案数时需要乘以2</p>
<p>总方案数$f(n)=1\times f(n-1)+2\times f(n-2)$</p>
<h2 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4.代码演示"></a>4.代码演示</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8A%E5%8D%8810.34.06.png" alt="截屏2021-01-04 上午10.34.06"></p>
<p>$f(n)=f(n-1)\times (k-2) + (k-1) \times f(n-2)$</p>
<p>(1,3不同+1,3相同)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义一个大整型数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigInt</span> :</span> <span class="keyword">public</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    BigInt() &#123;</span><br><span class="line">        push_back(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        push_back(x);</span><br><span class="line">        process_digit();</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>*(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="function">BigInt <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        ret *= x;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(); i++) at(i) *= x;</span><br><span class="line">        process_digit();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> BigInt &amp;num) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size()) push_back(num[i]);</span><br><span class="line">            <span class="keyword">else</span> at(i) += num[i];</span><br><span class="line">         &#125;</span><br><span class="line">        process_digit();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInt &amp;num) &#123;</span><br><span class="line">        <span class="function">BigInt <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        ret += num;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process_digit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (at(i) &lt; <span class="number">10</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == size()) push_back(<span class="number">0</span>);</span><br><span class="line">            at(i + <span class="number">1</span>) += at(i) / <span class="number">10</span>;</span><br><span class="line">            at(i) %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> BigInt &amp;num) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        out &lt;&lt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;<span class="comment">//n块墙壁k种颜色</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    BigInt f[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    f[<span class="number">1</span>] = k;<span class="comment">//有一块墙壁，，k种颜色，k&gt;=1</span></span><br><span class="line">    f[<span class="number">2</span>] = k * (k - <span class="number">1</span>);<span class="comment">//有两块墙壁，k种颜色,k&gt;=2</span></span><br><span class="line">    f[<span class="number">0</span>] = k * (k - <span class="number">1</span>) * (k - <span class="number">2</span>);<span class="comment">//有三块墙壁,k&gt;=3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i % <span class="number">3</span>] = f[(i - <span class="number">1</span>) % <span class="number">3</span>] * (k - <span class="number">2</span>) + f[(i - <span class="number">2</span>) % <span class="number">3</span>] * (k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n % <span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="3-从递推到动归-下"><a href="#3-从递推到动归-下" class="headerlink" title="3.从递推到动归(下)"></a>3.从递推到动归(下)</h1><blockquote>
<p>2021.1.4</p>
</blockquote>
<h2 id="1-数字三角形"><a href="#1-数字三角形" class="headerlink" title="1.数字三角形"></a>1.数字三角形</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%8812.32.26.png" alt="截屏2021-01-04 下午12.32.26" style="zoom:80%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%8812.32.26.png" alt="截屏2021-01-04 下午12.32.26" style="zoom:80%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%8812.32.59.png" alt="截屏2021-01-04 下午12.32.59" style="zoom:80%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%8812.45.491.png" alt="截屏2021-01-04 下午12.45.491" style="zoom:80%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/0012.png" alt="0012" style="zoom:80%;" />





<h3 id="惊人的发现"><a href="#惊人的发现" class="headerlink" title="惊人的发现"></a>惊人的发现</h3><p>$f(i, j)$ 代表从底边走到 i, j 点的最大值</p>
<p>$f(i, j)$ 代表从顶点走到 i, j 点的最大值</p>
<ol>
<li>数学符号完全一致</li>
<li>语义信息不同</li>
<li>递归公式不同</li>
<li>结论：数学符号无法完全代表状态定义</li>
</ol>
<h3 id="两种方法的对比"><a href="#两种方法的对比" class="headerlink" title="两种方法的对比"></a>两种方法的对比</h3><p>本质：两种状态定义方式的对比</p>
<ol>
<li>第一种：不用做边界判断，最终结果，直接存储在 $f[0][0]$</li>
<li>第二种：需要做边界判断，最终结果，存储在一组数据中</li>
<li>结论：第一种要比第二种优秀</li>
</ol>
<h2 id="2-数学归纳法"><a href="#2-数学归纳法" class="headerlink" title="2.数学归纳法"></a>2.数学归纳法</h2><p>用数学归纳法验证动态规划是否是正确的</p>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%883.41.45.png" alt="截屏2021-01-04 下午3.41.45" style="zoom:90%;" />





<h2 id="3-动态规划问题的求解套路"><a href="#3-动态规划问题的求解套路" class="headerlink" title="3.动态规划问题的求解套路"></a>3.动态规划问题的求解套路</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%883.49.09.png" alt="截屏2021-01-04 下午3.49.09" style="zoom:80%;" />

<ol>
<li>第一步：确定动归状态</li>
<li>第二步：推导状态转移方程，理解：转移、决策</li>
<li>第三步：正确性证明，利用数学归纳法</li>
<li>第四步：程序实现</li>
<li>所谓的转移，把所有决定 $f(i, j)$ 最优值的状态，放入到决策过程中。</li>
</ol>
<h2 id="4-递推问题求解方向"><a href="#4-递推问题求解方向" class="headerlink" title="4.递推问题求解方向"></a>4.递推问题求解方向</h2><p>1.我从哪里来：一般用for循环求解</p>
<p>例如：数字三角形、兔子繁殖问题、钱币问题、墙壁涂色…</p>
<p>2.我到哪里去：递归</p>
<p>例如：杂务(P1113)、神经网络(P1038)、旅行计划(P1137)…(P洛谷)</p>
<h3 id="补充-拓扑序"><a href="#补充-拓扑序" class="headerlink" title="补充:拓扑序"></a>补充:拓扑序</h3><p>图形结构是最最抽象的数据结构，必须理解成思维逻辑结构</p>
<ol>
<li>拓扑序是一种图形结构上的依赖顺序，一个图的拓扑序不唯一</li>
<li>拓扑序的本质作用：是把图形结构上变成一个一维序列</li>
<li>图形结构不能用循环遍历的，一维序列可以</li>
<li>所有递推问题中的状态更新过程，本质上满足拓扑序</li>
</ol>
<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%884.28.08.png" alt="截屏2021-01-04 下午4.28.08" style="zoom:80%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%884.28.17.png" alt="截屏2021-01-04 下午4.28.17" style="zoom:80%;" />

<h2 id="5-例题1：最长上升子序列"><a href="#5-例题1：最长上升子序列" class="headerlink" title="5.例题1：最长上升子序列"></a>5.例题1：最长上升子序列</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%884.34.45.png" alt="截屏2021-01-04 下午4.34.45"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%884.41.03.png" alt="截屏2021-01-04 下午4.41.03"></p>
<h3 id="状态定义-5"><a href="#状态定义-5" class="headerlink" title="状态定义"></a>状态定义</h3><p>$f(i)$ 代表以为 i 为结尾的，最长上升子序列的长度</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>$f(i) = max\left{f(j)\right} + 1 | j &lt; i, val[j] &lt; val[i] $</p>
<p>状态转移的时间复杂度：$O(n^2)$</p>
<p>后续重点：优化转移过程</p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[MAX_N + <span class="number">5</span>];<span class="comment">//子序列</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>];<span class="comment">//记录上升子序列最长长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">//记录最长长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;<span class="comment">//在子序列中寻扎比他小的值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt;= arr[i]) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, dp[i]);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a href="#5.3.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E4%BC%98%E5%8C%96">5.3.最长上升子序列优化</a></p>
<h2 id="6-例题2-最长公共子序列"><a href="#6-例题2-最长公共子序列" class="headerlink" title="6.例题2:最长公共子序列"></a>6.例题2:最长公共子序列</h2><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.24.57.png" alt="截屏2021-01-05 上午9.24.57" style="zoom:80%;" />

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.27.11.png" alt="截屏2021-01-05 上午9.27.11" style="zoom:80%;" />

<h3 id="状态定义-6"><a href="#状态定义-6" class="headerlink" title="状态定义"></a>状态定义</h3><p>$f(i,j)$ 代表第一个字符串取前 i 位，第二个字符串取前 j 位的，最长公共子序列的长度</p>
<h3 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>$f(i,j) = \left{\begin{aligned} &amp; max[f(i - 1, j), f(i, j - 1)] &amp;val(i) \neq val(j)\ &amp; f(i - 1, j - 1) &amp;val(i) = val(j)\end{aligned} \right.$</p>
<p>状态转移的时间复杂度：$O(n \times m)$</p>
<p>学习的重点：注意到，参与决策的状态数量，是会根据条件不同而改变的</p>
<h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="built_in">string</span> s1, s2;</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>][MAX_N + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s2.size(); j++) &#123;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[s1.size()][s2.size()] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="7-课后作业题"><a href="#7-课后作业题" class="headerlink" title="7.课后作业题"></a>7.课后作业题</h2><ol>
<li><strong><a target="_blank" rel="noopener" href="http://oj.haizeix.com/problem/46">HZOJ46-切割回文</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="http://oj.haizeix.com/problem/47">HZOJ47-0/1背包</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="http://oj.haizeix.com/problem/48">HZOJ48-完全背包</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="http://oj.haizeix.com/problem/49">HZOJ49-多重背包</a></strong></li>
</ol>
<h1 id="4-动归习题"><a href="#4-动归习题" class="headerlink" title="4.动归习题"></a>4.动归习题</h1><h2 id="1-切割回文"><a href="#1-切割回文" class="headerlink" title="1.切割回文"></a>1.切割回文</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-09%20%E4%B8%8B%E5%8D%882.43.31.png" alt="截屏2021-01-09 下午2.43.31"></p>
<p><strong>状态定义</strong></p>
<p>$dp[i]$ 代表取字符串的前 $i$ 位，最少分成多少段回文串</p>
<p><strong>状态转移</strong></p>
<p>$dp[i] = min(dp[j]) + 1\ |\ s[j + 1, i]\ is\ palindrome$</p>
<ol>
<li>根据状态转移，算法时间复杂度$O(n^2)$</li>
<li>所以，我们需要对转移阶段进行优化</li>
<li>动态规划优化章节的时候，重点解决</li>
</ol>
<h2 id="2-切割回文代码实现"><a href="#2-切割回文代码实现" class="headerlink" title="2.切割回文代码实现"></a>2.切割回文代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>];<span class="comment">//dp[i] 代表取字符串的前i位，最少分成多少段回文串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_palindrome</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//判断i~j是否是回文字符串</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] - s[j]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//s[i] != s[j]</span></span><br><span class="line">        i++,j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_palindrome(s, j, i - <span class="number">1</span>))<span class="comment">//是回文串</span></span><br><span class="line">                dp[i] = min(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[s.size()] - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="#5.4%E5%88%87%E5%89%B2%E5%9B%9E%E6%96%87">5.4切割回文</a></p>
<h2 id="3-HZOJ47-0-1背包"><a href="#3-HZOJ47-0-1背包" class="headerlink" title="3.HZOJ47-0/1背包"></a>3.HZOJ47-0/1背包</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8A%E5%8D%8811.09.46.png" alt="截屏2021-01-13 上午11.09.46"></p>
<p><strong>状态定义</strong></p>
<p>$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，得到物品的最大价值</p>
<p><strong>状态转移</strong></p>
<p>$$dp[i][j] = max\left{\begin{aligned}&amp;dp[i-1][j]&amp;没选第 i 件\&amp;dp[i-1][j-v[i]]+w[i] &amp;选了第 i 件\end{aligned}\right.$$</p>
<p>𝑉𝑖,𝑊𝑖,分别代表第i件物品的重量𝑉𝑖和价值𝑊𝑖。</p>
<ol>
<li>第一种程序实现，状态如何定义的，程序就如何实现</li>
<li>第二种程序实现，使用滚动数组，对代码进行了空间优化</li>
<li>第三种程序实现，将程序中的 $dp$ 数组变成一维的，并且修改了更新顺序</li>
</ol>
<h2 id="4-0-1背包代码演示"><a href="#4-0-1背包代码演示" class="headerlink" title="4.0/1背包代码演示"></a>4.0/1背包代码演示</h2><h3 id="1-方法一"><a href="#1-方法一" class="headerlink" title="1.方法一"></a>1.方法一</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_V 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[MAX_N + <span class="number">5</span>], w[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>][MAX_V + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; n;<span class="comment">//背包的最大承重v和物品数n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">  		<span class="comment">//物品从第一件开始,输入第i件物品的重量v[i]和价值w[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) </span><br><span class="line">              dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">            <span class="comment">//前 i 个物品，背包最大承重为 j 的情况下，得到物品的最大价值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-利用滚动数组进行优化"><a href="#2-利用滚动数组进行优化" class="headerlink" title="2.利用滚动数组进行优化"></a>2.利用滚动数组进行优化</h3><p>减少存储空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_V 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[MAX_N + <span class="number">5</span>], w[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][MAX_V + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; n;<span class="comment">//背包的最大承重v和物品数n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];<span class="comment">//物品从第一件开始,输入第i件物品的重量v[i]和价值w[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">            dp[i % <span class="number">2</span>][j] = dp[(i - <span class="number">1</span>) % <span class="number">2</span>][j];</span><br><span class="line">            <span class="comment">//此处只访问了dp[i]和dp[i-1]两行，可以利用滚动数组进行优化</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) dp[i % <span class="number">2</span>][j] = max(dp[i % <span class="number">2</span>][j], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][j - v[i]] + w[i]);</span><br><span class="line">            <span class="comment">//dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);</span></span><br><span class="line">            <span class="comment">//前 i 个物品，背包最大承重为 j 的情况下，得到物品的最大价值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n % <span class="number">2</span>][V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-优化"><a href="#3-优化" class="headerlink" title="3.优化"></a>3.优化</h3><p>将程序中的 $dp$ 数组变成一维的，并且修改了更新顺序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_V 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_V + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V, n; <span class="comment">//背包的最大承重V和物品数n。</span></span><br><span class="line">    <span class="keyword">int</span> v, w; <span class="comment">//物品的重量v和价值w</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; n; </span><br><span class="line">    <span class="comment">//for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span></span><br><span class="line">    <span class="comment">//物品从第一件开始,输入第i件物品的重量v[i]和价值w[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v; j--) &#123;</span><br><span class="line">          <span class="comment">//dp[j] = dp[j];</span></span><br><span class="line">            <span class="comment">//if (j &gt;= v) dp[j] = max(dp[j], dp[j - v] + w);</span></span><br><span class="line">            <span class="comment">//前 i 个物品，背包最大承重为 j 的情况下，得到物品的最大价值</span></span><br><span class="line">          dp[j] = max(dp[j], dp[j - v] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解：</p>
<p>1.j为什么逆序</p>
<p>==&gt;需要理解为什么是一维的</p>
<p>dp数组经过$dp[j] = max(dp[j], dp[j - v] + w)$后变成了$dp[i][j]$的含义,之前是$dp[i - 1][j]$的含义</p>
<p>$dp[j]$更新需要$dp[j]$和$dp[j - v]$的值(相对于二维数组来说，此处需要$dp[i - 1][j]$和$dp[i - 1][j - v]$的值，即上一行的数据)，如果从前面开始更新数据，后面需要的数组会被新一层的数据覆盖,所以需要从后面开始更新</p>
<p>2.为什么不需要v、w数组</p>
<p>读入一件商品，处理一件商品</p>
<p>3.dp数组为什么第一维没了</p>
<p>dp数组的含义没有变,只是在代码实现中变成了一维的</p>
<h2 id="5-海贼-OJ-48-完全背包"><a href="#5-海贼-OJ-48-完全背包" class="headerlink" title="5.海贼 OJ-48-完全背包"></a>5.海贼 OJ-48-完全背包</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%882.38.25.png" alt="截屏2021-01-13 下午2.38.25"></p>
<p><strong>状态定义</strong></p>
<p>$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，最大价值</p>
<p><strong>状态转移</strong></p>
<p>$$dp[i][j] = max\left{\begin{aligned}&amp;dp[i-1][j]&amp;没选第 i 件\&amp;dp[i][j-v[i]]+w[i] &amp;选了若干个第 i 件\end{aligned}\right.$$</p>
<p>(0/1背包)$dp[i-1][j-v[i]]+w[i] 选了第 i 件$</p>
<p>程序实现的时候，参考01背包的程序实现，将逆向刷表，改成正向刷表</p>
<h2 id="6-完全背包代码演示"><a href="#6-完全背包代码演示" class="headerlink" title="6.完全背包代码演示"></a>6.完全背包代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V, n, w, v;</span><br><span class="line">    <span class="comment">//第一行为两个整数𝑁、𝑉(1≤𝑁,𝑉≤10000)，分别代表题目描述中的物品种类数量N和背包容量V。</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;<span class="comment">//c = v,v = w</span></span><br><span class="line">        <span class="comment">//第 𝑖 行两个整数𝐶𝑖、𝑉𝑖，分别代表每种物品的体积和价值。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &lt;= V; j++) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - v] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处我们需要正向刷表，因为我们需要$dp[j - v[i]]$能够代表$dp[i][j - v[i]]$的值</p>
<p>$dp[i][j-v[i]]+w[i] 选了若干个第 i 件$此处需要的第$i$行的$dp[j-v[i]]$而不是需要第$i - 1$行的$dp[j-v[i]]$</p>
<h2 id="7-海贼-OJ-49-多重背包"><a href="#7-海贼-OJ-49-多重背包" class="headerlink" title="7.海贼 OJ-49-多重背包"></a>7.海贼 OJ-49-多重背包</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%883.17.52.png" alt="截屏2021-01-13 下午3.17.52"></p>
<p><strong>问题模型转换</strong></p>
<ol>
<li>多重背包，每类物品多了一个数量限制</li>
<li>01背包，每种物品只有一个</li>
<li>将多重背包中的数量限制，当做多个单一物品来处理</li>
<li>至此就将多重背包，转成了0/1背包问题</li>
</ol>
<p><strong>状态定义</strong></p>
<p>$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，最大价值</p>
<p><strong>状态转移</strong></p>
<p>$$dp[i][j] = max\left{\begin{aligned}&amp;dp[i-1][j]&amp;没选第 i 件\&amp;dp[i-1][j-v[i]]+w[i] &amp;选了第 i 件\end{aligned}\right.$$</p>
<h2 id="8-多重背包代码演示"><a href="#8-多重背包代码演示" class="headerlink" title="8.多重背包代码演示"></a>8.多重背包代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> V, n, v, w, s;</span><br><span class="line">    <span class="comment">//第一行输入两个数𝑉、𝑛，分别代表背包的最大承重和物品种类数。</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//𝑉𝑖、𝑊𝑖、𝑆𝑖，分别代表第 𝑖 种物品的重量、价值和数量。</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s; k++) &#123;</span><br><span class="line">          <span class="comment">//对数量分类，对每一种情况进行讨论</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v; j--) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - v] + w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a href="#5.2.%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%9A%84%E4%BC%98%E5%8C%96">5.2.多重背包的优化</a></p>
<h2 id="9-海贼-OJ-50-扔鸡蛋"><a href="#9-海贼-OJ-50-扔鸡蛋" class="headerlink" title="9.海贼 OJ-50-扔鸡蛋"></a>9.海贼 OJ-50-扔鸡蛋</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%883.56.18.png" alt="截屏2021-01-13 下午3.56.18"></p>
<p><strong>状态定义</strong></p>
<p>$dp[n][m]$ 用 n 个鸡蛋，测 m 层楼，最坏情况下最少测$dp[n][m]$次</p>
<p><strong>状态转移</strong></p>
<p>$$dp[n][m] = min(max\left{\begin{aligned}&amp;dp[n-1][k-1]+1&amp;鸡蛋碎了\&amp;dp[n][m-k]+1 &amp;鸡蛋没碎\end{aligned})\right.$$</p>
<p>楼层数k，最少min,最坏max,对于每一个枚举的k值中选一个值最小的方案，对于每一个确定的k值，都有两种解决方式，在这两种解决方式中取一个最大值</p>
<ol>
<li>程序所使用的存储空间与楼层数量强相关</li>
<li>楼层数量达到了 $2^{31}$，所以在这种状态定一下不可行</li>
<li>状态定义不可行，我们就需要优化状态定义</li>
<li>时间复杂度 $O(n \times m^2)$，当 m 过大的时候，无法通过时间限制</li>
</ol>
<h2 id="10-扔鸡蛋代码演示"><a href="#10-扔鸡蛋代码演示" class="headerlink" title="10.扔鸡蛋代码演示"></a>10.扔鸡蛋代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100000</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>][MAX_M + <span class="number">5</span>];</span><br><span class="line"><span class="comment">//dp[n][m]用n个鸡蛋，测 m 层楼，最坏情况下最少测dp[n][m]次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//输入两个数字 𝑛,𝑚（1≤𝑛≤32,1≤𝑚&lt;231），代表 𝑛 个鸡蛋和 𝑚 层楼。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) dp[<span class="number">1</span>][i] = i;</span><br><span class="line">  	<span class="comment">//一个鸡蛋测i层楼,有i种方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;<span class="comment">//从两个鸡蛋开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;<span class="comment">//楼层</span></span><br><span class="line">            dp[i][j] = j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j; k++) &#123;<span class="comment">//</span></span><br><span class="line">                dp[i][j] = min(dp[i][j], max(dp[i - <span class="number">1</span>][k - <span class="number">1</span>], dp[i][j - k]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30分，</p>
<p>时间复杂度$O(n \times m^2)$</p>
<p><a href="##5.1.%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96">扔鸡蛋问题优化</a></p>
<h1 id="5-动态规划优化的分类"><a href="#5-动态规划优化的分类" class="headerlink" title="5. 动态规划优化的分类"></a>5. 动态规划优化的分类</h1><ol>
<li>状态转移过程的优化，不改变状态定义，使用一些特殊的数据结构或者算法专门优化转移过程</li>
<li>程序实现的优化，例如：01背包问题。状态定义没有变、转移过程也没变。</li>
<li>状态定义的优化，大量训练，才能培养出来的能力，从源头进行优化</li>
<li>状态定义-&gt;源头，转移过程-&gt;过程，程序实现-&gt;结果</li>
</ol>
<p>程序优化：01背包，钱币问题，滚动数组</p>
<h2 id="5-1-扔鸡蛋问题的优化"><a href="#5-1-扔鸡蛋问题的优化" class="headerlink" title="5.1.扔鸡蛋问题的优化"></a>5.1.扔鸡蛋问题的优化</h2><h3 id="转移过程优化"><a href="#转移过程优化" class="headerlink" title="转移过程优化"></a><strong>转移过程优化</strong></h3><p>$$dp[n][m] = min(max\left{\begin{aligned}&amp;dp[n-1][k-1]+1&amp;鸡蛋碎了\&amp;dp[n][m-k]+1 &amp;鸡蛋没碎\end{aligned})\right.$$</p>
<p>$dp[n][m]$ 用 n 个鸡蛋，测 m 层楼，最坏情况下最少测$dp[n][m]$次</p>
<p>通过观察 k 与 $dp[n-1][k-1]$与 $dp[n][m-k]$之间的关系，最优的转移 k 值，一定发生在两个函数的交点处</p>
<p>k增加，$dp[n-1][k-1]$增加，$dp[n][m-k]$减小(如果不理解，可以假如用1(n-1=1)个鸡蛋，测m(k - 1 = m)层楼有m种方法理解)</p>
<p>交叉点出的值满足：$dp[n-1][k-1] \le dp[n][m-k]$</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%888.39.00.png" alt="截屏2021-01-13 下午8.39.00"></p>
<p>m1&lt;m2  ==&gt; k1&lt;=k2</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%888.42.19.png" alt="截屏2021-01-13 下午8.42.19"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%888.48.59.png" alt="截屏2021-01-13 下午8.48.59"></p>
<p>优化掉 min 以后，总体时间复杂度变成了 $O(n \times m)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100000</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>][MAX_M + <span class="number">5</span>];</span><br><span class="line"><span class="comment">//dp[n][m]用n个鸡蛋，测 m 层楼，最坏情况下最少测dp[n][m]次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//输入两个数字 𝑛,𝑚（1≤𝑛≤32,1≤𝑚&lt;231），代表 𝑛 个鸡蛋和 𝑚 层楼。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) dp[<span class="number">1</span>][i] = i;<span class="comment">//一个鸡蛋测i层楼,有i种方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;<span class="comment">//从两个鸡蛋开始</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m; j++) &#123;<span class="comment">//楼层</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//1.</span></span><br><span class="line">            <span class="comment">//while(k &lt; j &amp;&amp; dp[i - 1][k - 1] &lt; dp[i][j - k]) ++k;</span></span><br><span class="line">            <span class="comment">//dp[i][j] = max(dp[i - 1][k -1], dp[i][j - k]) + 1;</span></span><br><span class="line">            <span class="comment">//2.</span></span><br><span class="line">            <span class="keyword">if</span>(k &lt; j &amp;&amp; dp[i - <span class="number">1</span>][k - <span class="number">1</span>] &lt; dp[i][j - k]) ++k;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][k <span class="number">-1</span>], dp[i][j - k]) + <span class="number">1</span>;</span><br><span class="line">           <span class="comment">// while(dp[i - 1][k - 1 + 1] &lt;= dp[i][j - k + 1]) ++k;</span></span><br><span class="line">             <span class="comment">//   dp[i][j] = dp[i][j - k] + 1;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>60</p>
<h3 id="状态定义的优化"><a href="#状态定义的优化" class="headerlink" title="状态定义的优化"></a><strong>状态定义的优化</strong></h3><ol>
<li>原状态定义所需存储空间与 m 相关，m 值域大，所以存不下</li>
<li>当发现某个自变量与因变量之间存在相关性的时候，两者即可对调</li>
<li>$dp[n][m]=k$ 重定义为$dp[n][k]=m$，代表 n 个鸡蛋扔 k 次，最多测多少层楼</li>
<li>k 的值域小，当 n=2 时，$k \le \sqrt{2m}$ </li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8A%E5%8D%885.57.48.png" alt="截屏2021-01-14 上午5.57.48"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8A%E5%8D%885.58.43.png" alt="截屏2021-01-14 上午5.58.43"></p>
<p><strong>状态转移方程：</strong>$dp[n][k] = dp[n-1][k-1]+dp[n][k-1] + 1$</p>
<p>本质上已经不是一个动态规划题目了，实际上变成了一个递推问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_K 100000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAX_N + <span class="number">5</span>][MAX_K + <span class="number">5</span>];</span><br><span class="line"><span class="comment">//dp[n][k]代表 n 个鸡蛋扔 k 次，最多测多少层楼</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_K; i++) dp[<span class="number">1</span>][i] = i;<span class="comment">//1个鸡蛋测i层楼有i种方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= MAX_K; k++) &#123;</span><br><span class="line">            dp[i][k] = dp[i - <span class="number">1</span>][k - <span class="number">1</span>] + dp[i][k - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(dp[n][k] &lt; m) k++;<span class="comment">//n个鸡蛋扔k次不足以测m层楼的时候增加k</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//输入两个数字 𝑛,𝑚（1≤𝑛≤32,1≤𝑚&lt;231），代表 𝑛 个鸡蛋和 𝑚 层楼。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve(n, m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>100</p>
<p>动态数组优化存储空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_K 100000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">2</span>][MAX_K + <span class="number">5</span>];</span><br><span class="line"><span class="comment">//dp[n][m]用n个鸡蛋，测 m 层楼，最坏情况下最少测dp[n][m]次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_K; i++) dp[<span class="number">1</span>][i] = i;<span class="comment">//1个鸡蛋测i层楼有i种方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= MAX_K; k++) &#123;</span><br><span class="line">            dp[i % <span class="number">2</span>][k] = dp[(i - <span class="number">1</span>) % <span class="number">2</span>][k - <span class="number">1</span>] + dp[i % <span class="number">2</span>][k - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(dp[n % <span class="number">2</span>][k] &lt; m) k++;<span class="comment">//n个鸡蛋扔k次不足以测m层楼的时候增加k</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//输入两个数字 𝑛,𝑚（1≤𝑛≤32,1≤𝑚&lt;231），代表 𝑛 个鸡蛋和 𝑚 层楼。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve(n, m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="5-2-多重背包的优化"><a href="#5-2-多重背包的优化" class="headerlink" title="5.2.多重背包的优化"></a>5.2.多重背包的优化</h2><p>[7.海贼 OJ-49-多重背包](#7.海贼 OJ-49-多重背包)</p>
<h3 id="二进制拆分法"><a href="#二进制拆分法" class="headerlink" title="二进制拆分法"></a>二进制拆分法</h3><ol>
<li>本质上，对于某一类物品，我们具体要选择多少件，才是最优答案</li>
<li>普通的单一拆分法，实际上只是想枚举某个物品选择 1–s 件的所有情况</li>
<li>二进制拆分法可以达到相同的效果，拆分出来的物品数量会更少</li>
<li>拿14举例，普通拆分法 14 份，二进制拆分法 4 份物品(1 2 4 7)</li>
</ol>
<p><strong>时间复杂度：</strong>$O(nm\sum_{i=1}^{i=n}{logs_i})$</p>
<p><strong>最优时间复杂度：</strong>$O(nm)$，借助单调队列，后续再讲</p>
<p><strong>01背包时间复杂度：</strong>$O(nm)$</p>
<p><strong>完全背包时间复杂度：</strong>$O(nm)$</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8A%E5%8D%887.25.53.png" alt="截屏2021-01-14 上午7.25.53"></p>
<h3 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> V, n, v, w, s;</span><br><span class="line">    <span class="comment">//第一行输入两个数𝑉、𝑛，分别代表背包的最大承重和物品种类数。</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//v、w、s代表物品的重量、价值和数量。</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; s; k *= <span class="number">2</span>) &#123;<span class="comment">//当前一共有多少物品</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; s) k = s;</span><br><span class="line">            s -= k;<span class="comment">//减去物品加上的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= k * v; j--) &#123;<span class="comment">//当前这一堆的总重量为k * v</span></span><br><span class="line">                dp[j] = max(dp[j], dp[j - k * v] + k * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-3-最长上升子序列优化"><a href="#5-3-最长上升子序列优化" class="headerlink" title="5.3.最长上升子序列优化"></a>5.3.最长上升子序列优化</h2><p><a href="#5.%E4%BE%8B%E9%A2%981%EF%BC%9A%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97">5.例题1：最长上升子序列</a></p>
<h3 id="状态定义-7"><a href="#状态定义-7" class="headerlink" title="状态定义"></a>状态定义</h3><p>$dp[i]$，代表以 i 位做为结尾的最长上升子序列的长度</p>
<h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>$dp[i] = max(dp[j]) + 1 | val_j &lt; val_i$</p>
<h3 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h3><ol>
<li>维护一个单调数组 len，len[i] 代表长度为 i 的序列，结尾最小值</li>
<li>$dp[i]$ 在转移的时候，在 len 数组中查找第一个 $len[k]&gt;=val_i$ 的位置，$dp[i] = k$</li>
<li>更新 $len[k] = val_i$</li>
<li>需要明确，len 数组为什么是单调的</li>
<li>证明过程：假设，更新前是单调的，更新以后，一定是单调的</li>
<li>在 len 数组中查找位置 k，实际上就是二分算法搞定</li>
</ol>
<p><strong>时间复杂度：</strong>$O(nlogl)$</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8B%E5%8D%883.06.40.png" alt="截屏2021-01-14 下午3.06.40"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8B%E5%8D%883.06.40.png" alt="截屏2021-01-14 下午3.06.51"></p>
<h3 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[MAX_N + <span class="number">5</span>];<span class="comment">//长度为i的序列的最小值</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//二分查找</span></span><br><span class="line">    <span class="comment">//在arr数组中查找第一个大于等于x的值</span></span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = n, mid;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; x) head = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tail = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, val;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(len, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(len));<span class="comment">//极大值</span></span><br><span class="line">    len[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//极小值，0的位置为极小值，其他位置为极大值</span></span><br><span class="line">   <span class="comment">// for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, val[i]);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">        dp[i] = binary_search(len, ans + <span class="number">1</span>,val);<span class="comment">//找到第一个&gt;=val[i]的值</span></span><br><span class="line">        len[dp[i]] = val;</span><br><span class="line">        ans = max(dp[i], ans);<span class="comment">//最后一位有记录的下标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-4切割回文"><a href="#5-4切割回文" class="headerlink" title="5.4切割回文"></a>5.4切割回文</h2><p><a href="#1.%E5%88%87%E5%89%B2%E5%9B%9E%E6%96%87">4.1.切割回文</a></p>
<p>提前处理得到 mark 数组，$mark[i]$ 存储的是所有以 i 位置做为结尾的回文串的起始坐标，在转移过程中，利用 mark 数组，就可以避免掉大量的无用循环遍历过程。</p>
<p><strong>时间复杂度：</strong>$O(n+m)$，m 是字符串中回文串的数量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>];<span class="comment">//取字符串的前i位，最少分成多少段回文串</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mark[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="comment">//以 i 位置做为结尾的回文串的起始坐标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//回文字符串</span></span><br><span class="line">    <span class="keyword">while</span> (s[i] == s[j]) &#123;</span><br><span class="line">        mark[j + <span class="number">1</span>].push_back(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//以j+1为结尾的回文串的起始坐标i+1 </span></span><br><span class="line">        --i, ++j;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &gt;= s.size()) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;<span class="comment">//一个长度为n(1≤𝑛≤500000)的字符串S，只包含小写字母。</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;<span class="comment">//提前处理得到 mark 数组</span></span><br><span class="line">        expand(s, i, i);<span class="comment">//处理奇数类型字符串</span></span><br><span class="line">        (i + <span class="number">1</span> &lt; s.size()) &amp;&amp; expand(s, i, i + <span class="number">1</span>);</span><br><span class="line">      	<span class="comment">//处理偶数类型的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); i++) &#123;</span><br><span class="line">        dp[i] = i;<span class="comment">//初始化dp[i],取字符串的前i位，最少分成多少段回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mark[i].size(); j++) &#123;</span><br><span class="line">            dp[i] = min(dp[i], dp[mark[i][j] - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[s.size()] - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//分多少段-1==&gt;切多少刀</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="6-树状数组"><a href="#6-树状数组" class="headerlink" title="6.树状数组"></a>6.树状数组</h1><p>2021.1.17 20:00</p>
<h2 id="6-1前缀和与差分"><a href="#6-1前缀和与差分" class="headerlink" title="6.1前缀和与差分"></a>6.1前缀和与差分</h2><h3 id="原数组、前缀和、差分数组"><a href="#原数组、前缀和、差分数组" class="headerlink" title="原数组、前缀和、差分数组"></a>原数组、前缀和、差分数组</h3><ol>
<li><p>原数组：${a_1, a_2,a_3,….,a_n}$</p>
</li>
<li><p>前缀和：$S_i=\sum_{k=1}^{k=i}{a_i}$，$a_i=S_i-S_{i-1}$</p>
</li>
<li><p>差分数组：$X_i=a_i-a_{i-1}$</p>
<p>$X_1 + X_2 + X_3 = (a_1 - a_0) + (a_2 - a_1) + (a_3 - a_2) = a_3 $</p>
</li>
<li><p>X 数组是 a 数组的差分数组，a 数组是 S 数组的差分数组</p>
</li>
<li><p>S 数组是 a 数组的前缀和数组，a 数组是 X 数组的前缀和数组</p>
</li>
<li><p>前缀和数组以及差分数组，并没有增加信息，只是信息的另外一种表示形式</p>
</li>
<li><p>前缀和数组用来优化==区间和==操作</p>
</li>
<li><p>差分数组用来优化==区间修改==操作</p>
</li>
</ol>
<h3 id="问题1：原数组区间和操作"><a href="#问题1：原数组区间和操作" class="headerlink" title="问题1：原数组区间和操作"></a>问题1：原数组区间和操作</h3><p>a 数组上的操作：$O(n)$</p>
<p>S 数组上的操作：$O(1)，S_i - S_{j-1}=a[j,i]区间和$</p>
<h3 id="问题2：原数组区间元素修改（加法）"><a href="#问题2：原数组区间元素修改（加法）" class="headerlink" title="问题2：原数组区间元素修改（加法）"></a>问题2：原数组区间元素修改（加法）</h3><p>$a={a_1,a_2,a_3,a_4,a_5,a_6}$</p>
<p>$X={X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5}$</p>
<p>${a_1,a_2+d,a_3+d,a_4+d,a_5,a_6}$</p>
<p>$X={X_1=a_1-a_0,X_2=a_2-a_1+d,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4-d,X_6=a_6-a_5}$</p>
<p>a 数组时间复杂度：$O(n)$</p>
<p>X 数组时间复杂度：$O(1)$</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%888.51.02.png" alt="截屏2021-01-17 下午8.51.02"></p>
<h2 id="6-2树状数组"><a href="#6-2树状数组" class="headerlink" title="6.2树状数组"></a>6.2树状数组</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%888.54.51.png" alt="截屏2021-01-17 下午8.54.51"></p>
<ol>
<li><p>lowbit 函数求数字 i，二进制表示中的最低1所在的位权</p>
</li>
<li><p>lowbit(x) = x &amp; -x</p>
<p>正数=原码，负数=补码=正数的反码+1，</p>
</li>
<li><p>树状数组本质上是对前缀和数组的一种优化，主要体现在单点修改操作上</p>
</li>
<li><p>前缀和查询 $O(logn)$，单点修改$O(logn)$</p>
</li>
<li><p>相比于最普通的前缀和数组，查询方面变差，单点修改操作变好，综合时间复杂度变好</p>
</li>
<li><p>查询的时候，向前统计，$i$ 的前一位 $i-lowbit(i)$</p>
</li>
<li><p>修改的时候，向后修改，$i$ 的后一位 $i + lowbit(i)$</p>
</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.04.29.png" alt="截屏2021-01-17 下午9.04.29"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.10.13.png" alt="截屏2021-01-17 下午9.10.13"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.10.55.png" alt="截屏2021-01-17 下午9.10.55"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.16.13.png" alt="截屏2021-01-17 下午9.16.13"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.17.02.png" alt="截屏2021-01-17 下午9.17.02"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.37.27.png" alt="截屏2021-01-17 下午9.37.27"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>方便区间修改版</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">int</span> c[MAX_N + <span class="number">5</span>];<span class="comment">//维护的是原数组的差分数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//单点修改</span></span><br><span class="line">    <span class="comment">//在c[n]中的c[i]加x</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        c[i] += x;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//前缀和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;<span class="comment">//原数组前n项和为第i项的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-3海贼-OJ-329-弱化的整数问题"><a href="#6-3海贼-OJ-329-弱化的整数问题" class="headerlink" title="6.3海贼 OJ-329-弱化的整数问题"></a>6.3海贼 OJ-329-弱化的整数问题</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.43.34.png" alt="截屏2021-01-17 下午9.43.34"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.43.50.png" alt="截屏2021-01-17 下午9.43.50"></p>
<p><strong>引入差分数组</strong></p>
<p>$a={a_1,a_2,a_3,a_4,a_5,a_6}$</p>
<p>$X={X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5}$</p>
<p>${a_1,a_2+d,a_3+d,a_4+d,a_5,a_6}$</p>
<p>$X={X_1=a_1-a_0,X_2=a_2-a_1+d,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4-d,X_6=a_6-a_5}$</p>
<p>引入差分数组 X，将原数组 a 上的区间加操作，转换成 X 数组上的两次【单点操作】</p>
<p>对于查询原数组 a[i] 的值，等价于查询 X 数组前 i 位的【前缀和】</p>
<p><strong>结论</strong></p>
<p>由于，既要维护【前缀和】，又要进行【单点修改】，所以可以使用树状数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">int</span> c[MAX_N + <span class="number">5</span>];<span class="comment">//维护的是原数组的差分数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//单点修改</span></span><br><span class="line">    <span class="comment">//在c[n]中的c[i]加x</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        c[i] += x;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//前缀和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;<span class="comment">//原数组前n项和为第i项的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, pre, a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;<span class="comment">//第一行一个整数𝑁,代表序列𝐴的长度</span></span><br><span class="line">    <span class="comment">//第二行是由空格分隔开的𝑁个数，分别代表𝐴1，𝐴2……𝐴𝑛</span></span><br><span class="line">    pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;<span class="comment">//a代表当前输入的值</span></span><br><span class="line">        add(i, a - pre, n);<span class="comment">//pre代表上一个输出的值</span></span><br><span class="line">        pre = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;<span class="comment">//接下来一行是一个整数𝑚，代表操作的次数。</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//接下来𝑚行，每行代表这一条指令如题目所述</span></span><br><span class="line">    <span class="keyword">int</span> l, r, d, x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="keyword">switch</span> (str[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: &#123;</span><br><span class="line">                      <span class="comment">// 第一类指令形如𝐶 𝑙 𝑟 𝑑(1≤𝑙≤𝑟≤𝑁)，表示把数列中第𝑙...𝑟之间的数都加𝑑(0≤𝑑≤100000)</span></span><br><span class="line">                      <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; d;</span><br><span class="line">                      add(l, d, n);</span><br><span class="line">                      add(r + <span class="number">1</span>, -d, n);</span><br><span class="line">                  &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: &#123;</span><br><span class="line">                      <span class="built_in">cin</span> &gt;&gt; x;<span class="comment">//第二类指令形如𝑄 𝑥(𝑥≤𝑁)，表示询问序列中第𝑥个数的值。</span></span><br><span class="line">                      <span class="built_in">cout</span> &lt;&lt; query(x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-4-海贼-OJ-330-加强的整数问题"><a href="#6-4-海贼-OJ-330-加强的整数问题" class="headerlink" title="6.4 海贼 OJ-330-加强的整数问题"></a>6.4 海贼 OJ-330-加强的整数问题</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%8810.29.57.png" alt="截屏2021-01-17 下午10.29.57"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%8810.30.10.png" alt="截屏2021-01-17 下午10.30.10"></p>
<p><strong>引入差分数组</strong></p>
<p>参考 HZOJ-329 的解法，主要为了维护原数组上的区间修改操作</p>
<p><strong>原数组上的区间和问题转化</strong></p>
<p>$a={a_1,a_2,a_3,a_4,a_5,a_6}$</p>
<p>$X={X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5}$</p>
<p>$Query(l, r) = S(r) - S(l - 1)$，重点分析 S 怎么求，会求 S，万事大吉</p>
<p>$S_i= \sum_{k=1}^{i}\sum_{y=1}^{k}{X_y} = \sum_{k=1}{i}{(i + 1)X_k-k<em>X_k}=(i + 1)\sum_{k=1}^{i}{X_k-\sum_{k=1}^{i}k</em>X_k}$</p>
<p>设$Y_i = i \times X_i$</p>
<p>$S_i=(i + 1)\sum_{k=1}^{i}{X_k-\sum_{k=1}^{i}{Y_k}}$</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%8810.27.25.png" alt="截屏2021-01-17 下午10.27.25"></p>
<p><strong>结论</strong></p>
<p>$S_i$ 可以通过维护 X 与 Y 两个序列的前缀和得到</p>
<p>所以可以通过维护两个与差分数组 X 相关的前缀和数组，从而得到原数组 a 的前缀和值</p>
<p>需要维护两个：树状数组</p>
<p><strong>代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c[<span class="number">2</span>][MAX_N + <span class="number">5</span>];<span class="comment">//差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k, <span class="keyword">long</span> <span class="keyword">long</span> i, <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在c[k][i]的位置加x</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        c[k][i] += x;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k, <span class="keyword">long</span> <span class="keyword">long</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询c[k][i]的前缀和</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        sum += c[k][i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> i)</span> </span>&#123;<span class="comment">//S[i]前i项和</span></span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>) * query(<span class="number">0</span>, i) - query(<span class="number">1</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> i, <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;<span class="comment">//在c[][i]位置上加上x</span></span><br><span class="line">    add(<span class="number">0</span>, i, x, n);</span><br><span class="line">    add(<span class="number">1</span>, i, i * x, n);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> m, n;</span><br><span class="line">    <span class="comment">//第一行包含两个整数𝑁,𝑀(1≤𝑁,𝑀≤100000)，代表序列的长度和询问的次数.</span></span><br><span class="line">    <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">//第二行包含𝑁个整数，表示初始的序列𝐴(−1000000000≤𝐴𝑖≤1000000000)。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>, pre = <span class="number">0</span>, a; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; a;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a);</span><br><span class="line">        modify(i, a - pre, n);</span><br><span class="line">        pre = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>, l, r, d; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; s;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">switch</span> (s[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: &#123;<span class="comment">//&quot;C a b c&quot;表示给[a, b]区间中的值全部增加c (-10000 ≤ c ≤ 10000)。</span></span><br><span class="line">                      <span class="comment">//cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;</span></span><br><span class="line">                      <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;l, &amp;r, &amp;d);</span><br><span class="line">                      modify(l, d, n);</span><br><span class="line">                      modify(r + <span class="number">1</span>, -d, n);</span><br><span class="line">                  &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: &#123;<span class="comment">//&quot;Q a b&quot; 询问[a, b]区间中所有值的和。</span></span><br><span class="line">                      <span class="comment">//cin &gt;&gt; l &gt;&gt; r;</span></span><br><span class="line">                      <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, S(r) - S(l - <span class="number">1</span>));</span><br><span class="line">                      <span class="comment">//cout &lt;&lt; (S(r) - S(l - 1)) &lt;&lt; endl;</span></span><br><span class="line">                  &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="7-树状数组习题"><a href="#7-树状数组习题" class="headerlink" title="7.树状数组习题"></a>7.树状数组习题</h1><h2 id="一、海贼-OJ-331-丢失的奶牛"><a href="#一、海贼-OJ-331-丢失的奶牛" class="headerlink" title="一、海贼 OJ-331-丢失的奶牛"></a>一、海贼 OJ-331-丢失的奶牛</h2><ol>
<li>理解标记数组，标记数组记录的是每一个下标知否可用，可用为1，不可用为0</li>
<li>根据题意，我们从后向前，依次确定每一头奶牛的编号</li>
<li>例如，当前奶牛比他前面的2个奶牛编号大的话，当前奶牛的编号就是当前剩余可用编号中的第三大的编号</li>
<li>如何找到可用的第 x 大的编号，可以在标记数组的前缀和数组上做二分查找</li>
<li>设计到标记数组的前缀和维护和单点更新，所以可以使用树状数组</li>
<li>时间复杂度：$O(nlogn)$</li>
</ol>
<p>相似问题：海贼 OJ-332-买票</p>
<h2 id="二、海贼-OJ-328-楼兰图腾"><a href="#二、海贼-OJ-328-楼兰图腾" class="headerlink" title="二、海贼 OJ-328-楼兰图腾"></a>二、海贼 OJ-328-楼兰图腾</h2><ol>
<li>求在当前位置之前，小于当前位置值的元素数量，当前元素值记为 X，元素数量记为 a，元素位置记为 i</li>
<li>前面小于 $X$ 的元素数量是 $a$</li>
<li>后面小于 $X$ 的元素数量是$X - a - 1$</li>
<li>前面大于 $X$ 的元素数量 $i - a - 1$</li>
<li>后面大于X 的元素数量$n-X-i+a+1$</li>
<li>解题关键：前面小于 $X$ 的元素数量是 $a$</li>
<li>标记数组，记录当前位置之前有哪些元素出现过，出现过标记为 1，否则标记为 0</li>
<li>$a$ 等于标记数组在 $X$ 位置之前的前缀和</li>
<li>对于标记数组的单点修改及前缀和查询，所以可以使用树状数组</li>
</ol>
<h2 id="三、海贼-OJ-333-区间最大子段和"><a href="#三、海贼-OJ-333-区间最大子段和" class="headerlink" title="三、海贼 OJ-333-区间最大子段和"></a>三、海贼 OJ-333-区间最大子段和</h2><ol>
<li>线段树有点点儿难度的题目</li>
<li>每个节点：区间和值，最大子段和值，左侧最大子段和，右侧最大子段和</li>
<li>特殊性质：递归遍历时，是按照下标顺序得到的每一个查询区间内的线段树的节点</li>
<li>$|①②③④⑤|$，就是按照①②③④⑤的顺序遍历得到的每一个节点</li>
<li>代码有点儿复杂，学会了，代码思维会更上一层楼</li>
</ol>
<h1 id="8-字符串的匹配算法-上"><a href="#8-字符串的匹配算法-上" class="headerlink" title="8.字符串的匹配算法(上)"></a>8.字符串的匹配算法(上)</h1><h2 id="8-1暴力匹配算法"><a href="#8-1暴力匹配算法" class="headerlink" title="8.1暴力匹配算法"></a>8.1暴力匹配算法</h2><ol>
<li>字符串匹配问题：单模匹配问题，顾名思义，只有一个模式串</li>
<li>依次对齐模式串和文本串的每一位，直到匹配成功</li>
<li>关键：不重不漏的找到答案</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8A%E5%8D%8810.36.32.png" alt="截屏2021-01-18 上午10.36.32"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>; t[j]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i + j] &amp;&amp; s[i + j] == t[j]) <span class="keyword">continue</span>;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;match(%s, %s) = %d\n&quot;</span>, s, t, brute_force(s, t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="8-2KMP-算法"><a href="#8-2KMP-算法" class="headerlink" title="8.2KMP 算法"></a>8.2KMP 算法</h2><ol>
<li><p>KMP 算法中，模式串中的第三部分的重要性</p>
</li>
<li><p>第三部分是可以帮助我们加快匹配速度的，避免掉大量无用的匹配尝试</p>
</li>
<li><p>KMP 算法保证不漏：第三部分匹配到的是模式串的最长前缀</p>
</li>
<li><p>普通编码：获得 NEXT 数组，使用 NEXT 数组</p>
</li>
<li><p>高级编码：抽象化了一个状态机模型，j 所指向的就是状态机中的位置</p>
</li>
<li><p>getNext 方法相当于根据输入字符，进行状态跳转，实际上就是改变 j 的值</p>
</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%884.43.10.png" alt="截屏2021-01-18 下午4.43.10"></p>
<p>next数组:</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%885.08.27.png" alt="截屏2021-01-18 下午5.08.27"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%885.12.55%201.png" alt="截屏2021-01-18 下午5.12.55 1"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>; t[j]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i + j] &amp;&amp; s[i + j] == t[j]) <span class="keyword">continue</span>;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//预处理t字符串，储存在next数组中，next数组存储匹配到字符串的下标</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;<span class="comment">//指向上一位next数组的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;<span class="comment">//遍历t字符串</span></span><br><span class="line">      <span class="comment">//如果上一位next数组的值不为-1且当前数组位置的值和字符串不匹配，</span></span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; t[j + <span class="number">1</span>] != t[i]) j = next[j];</span><br><span class="line">      <span class="comment">//字符串j+1位!=当前位置,但是t[j]=t[i - 1],</span></span><br><span class="line">      <span class="comment">//如果要使t[j + 1] = t[i],就可以跟着next[j]往回走，</span></span><br><span class="line">      <span class="comment">//直到t[j + 1] = t[i]或者没有找到，直到j = -1</span></span><br><span class="line">        <span class="keyword">if</span> (t[j + <span class="number">1</span>] == t[i]) j += <span class="number">1</span>;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化next数组</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">int</span> *next = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n + <span class="number">1</span>);</span><br><span class="line">    getNext(t, next);</span><br><span class="line">    <span class="comment">//输出next数组的值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%d &quot;, next[i]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//使用next数组进行匹配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="comment">//s[i]!=t[j+1]</span></span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; s[i] - t[j + <span class="number">1</span>]) j = next[j];  </span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j + <span class="number">1</span>]) j += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t[j + <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> i - n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;brute_force(%s, %s) = %d\n&quot;</span>, s, t, brute_force(s, t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;kmp(%s, %s) = %d\n&quot;</span>, s, t, kmp(s, t));</span><br><span class="line">        <span class="comment">//printf(&quot;brute_force(%s, %s) = %d\n&quot;, s, t, brute_force(s, t));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对代码进行优化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; t[j] &amp;&amp; flag; j++) &#123;</span><br><span class="line">            flag = flag &amp;&amp; (s[i + j] &amp;&amp; s[i + j] == t[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">int</span> &amp;j, <span class="keyword">char</span> input, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//传入j和当前位置的字符串</span></span><br><span class="line">    <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; t[j + <span class="number">1</span>] != input) j = next[j];</span><br><span class="line">    <span class="keyword">if</span> (t[j + <span class="number">1</span>] == input) j += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">int</span> *next = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n + <span class="number">1</span>);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; t[i]; i++) next[i] = getNext(t, j, t[i], next);<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getNext(t, j, s[i], next) != n - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - n + <span class="number">1</span>;<span class="comment">//匹配完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;brute_force(%s, %s) = %d\n&quot;</span>, s, t, brute_force(s, t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;kmp(%s, %s) = %d\n&quot;</span>, s, t, kmp(s, t));</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="8-3SUNDAY-算法"><a href="#8-3SUNDAY-算法" class="headerlink" title="8.3SUNDAY 算法"></a>8.3SUNDAY 算法</h2><ol>
<li>SUNDAY 算法理解的核心，在于理解黄金对齐点位</li>
<li>是文本串的匹配尾部，一定会出现在模式串中的字符</li>
<li>应该和模式串中最后一位出现该字符的位置对齐</li>
<li>第一步：预处理每一个字符在模式串中最后一次出现的位置</li>
<li>第二步：模拟暴力匹配算法过程，失配的时候，文本串指针根据预处理信息向后移动若干位</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.06.30.png" alt="截屏2021-01-18 下午9.06.30"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.06.51.png" alt="截屏2021-01-18 下午9.06.51"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.07.10.png" alt="截屏2021-01-18 下午9.07.10"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.30.57.png" alt="截屏2021-01-18 下午9.30.57"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.30.43.png" alt="截屏2021-01-18 下午9.30.43"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; t[j] &amp;&amp; flag; j++) &#123;</span><br><span class="line">            flag = flag &amp;&amp; (s[i + j] &amp;&amp; s[i + j] == t[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sunday</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> offset[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(t), m = <span class="built_in">strlen</span>(s);</span><br><span class="line">  	<span class="comment">//第一次匹配的时候会从t字符串末尾开始匹配</span></span><br><span class="line"> 	 <span class="comment">//初始化offset数组，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) offset[i] = n + <span class="number">1</span>;</span><br><span class="line"> 	 <span class="comment">//假如所有字符都没没有出现过，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; t[i]; i++) offset[t[i]] = n - i;</span><br><span class="line">  	<span class="comment">//遍历t字符串,字符串出现在倒数第n-i位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + n &lt;= m; i += offset[s[i + n]]) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; t[j] &amp;&amp; flag; j++) &#123;</span><br><span class="line">            flag = flag &amp;&amp; (s[i + j] == t[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;brute_force(%s, %s) = %d\n&quot;</span>, s, t, brute_force(s, t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sunday(%s, %s) = %d\n&quot;</span>, s, t, sunday(s, t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">brute_force(123456789, aeadaeadaeae) = -1</span><br><span class="line">sunday(123456789, aeadaeadaeae) = -1</span><br><span class="line">brute_force(hello, ll) = 2</span><br><span class="line">sunday(hello, ll) = 2</span><br><span class="line">brute_force(world, ld) = 3</span><br><span class="line">sunday(world, ld) = 3</span><br><span class="line">brute_force(haizei, hu) = -1</span><br><span class="line">sunday(haizei, hu) = -1</span><br></pre></td></tr></table></figure>




<h1 id="9-字符串匹配算法-中"><a href="#9-字符串匹配算法-中" class="headerlink" title="9 字符串匹配算法(中)"></a>9 字符串匹配算法(中)</h1><h2 id="9-1字符串的哈希匹配算法"><a href="#9-1字符串的哈希匹配算法" class="headerlink" title="9.1字符串的哈希匹配算法"></a>9.1字符串的哈希匹配算法</h2><h3 id="HAIZEIOJ-275-兔子与兔子"><a href="#HAIZEIOJ-275-兔子与兔子" class="headerlink" title="HAIZEIOJ-275.兔子与兔子"></a>HAIZEIOJ-275.兔子与兔子</h3><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.16.17.png" alt="截屏2021-01-19 下午2.16.17"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.16.34.png" alt="截屏2021-01-19 下午2.16.34"></p>
<ol>
<li>可以使用哈希操作判断两个字符串是否相等</li>
<li>哈希值不同的话，两个字符串一定不相等，从而就不需要按位比较了</li>
<li>$H = (\sum_{k=0}^{n-1}{C_k\times base^k})%P$</li>
<li>在文本串上，每一位字符串哈希值的前缀和，方便以后求区间和</li>
<li>$H(i,j)=(HS_j-HS_{i-1})\times (base^i)^{-1}%P $//求i~j的哈希值</li>
</ol>
<h3 id="快速求逆元的推导过程"><a href="#快速求逆元的推导过程" class="headerlink" title="快速求逆元的推导过程"></a>快速求逆元的推导过程</h3><p>$$<br>\begin{aligned}<br>x\times x^{-1}&amp;\equiv1\ (mod\ P) \<br>令：P%x&amp;=r \<br>P &amp;= kx+r \<br>kx+r &amp;\equiv0\ (mod\ P) \<br>kr^{-1}+x^{-1} &amp;\equiv0\ (mod\ P) \<br>x^{-1} &amp;\equiv-kr^{-1}\ (mod\ P)<br>\end{aligned}<br>$$</p>
<h3 id="哈希值的计算"><a href="#哈希值的计算" class="headerlink" title="哈希值的计算"></a>哈希值的计算</h3><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.36.27.png"></p>
<p>逆元</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.41.05.png" alt="截屏2021-01-19 下午2.41.05"></p>
<p>逆元的推导：*</p>
<p>r=P%x</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.41.13.png" alt="截屏2021-01-19 下午2.41.13"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> inv[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//求1~7的7的逆元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">7</span>; i++) &#123;<span class="comment">//P = 7</span></span><br><span class="line">        <span class="comment">//inv[i] = (-(7/i) * inv[7 % i]);==&gt;是负数，将负数变成正数</span></span><br><span class="line">        inv[i] = ((-(<span class="number">7</span> / i) * inv[<span class="number">7</span> % i]) % <span class="number">7</span> + <span class="number">7</span>) % <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; inv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2:4</span><br><span class="line">3:5</span><br><span class="line">4:2</span><br><span class="line">5:3</span><br><span class="line">6:6</span><br></pre></td></tr></table></figure>


<h2 id="9-2-shift-and-算法"><a href="#9-2-shift-and-算法" class="headerlink" title="9.2 shift_and 算法"></a>9.2 shift_and 算法</h2><ol>
<li>第一步对模式串做特殊处理，把每一种字符出现的位置，转换成相应的二进制编码</li>
<li>后续匹配的过程中跟模式串一毛钱关系都没有</li>
<li>$p_i = (p_{i-1}&lt;&lt;1 | 1) &amp; d[s_i]$</li>
<li>$p_i$第 j 位二进制为1，代表当前位置为结尾，可以匹配成功模式串的第 j 位</li>
</ol>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%888.38.00.png" alt="截屏2021-01-19 下午8.38.00"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.46.34.png" alt="截屏2021-01-19 下午2.46.34"></p>
<p>i = 1,P = 010000</p>
<p>i = 4, P = 010010</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;<span class="comment">//暴力匹配算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; t[j] &amp;&amp; flag; j++) &#123;</span><br><span class="line">            flag = flag &amp;&amp; (s[i + j] &amp;&amp; s[i + j] == t[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift_and</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, n = <span class="number">0</span>;<span class="comment">//处理模式串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; t[i]; n++,i++) d[t[i]] |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        p = (p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &amp; d[s[i]];</span><br><span class="line">        <span class="keyword">if</span> (p &amp; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>))) <span class="keyword">return</span> i - n + <span class="number">1</span>;<span class="comment">//判断p的第n位是否为1，是：完全匹配成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;brute_force(%s, %s) = %d\n&quot;</span>, s, t, brute_force(s, t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shitf_and(%s, %s) = %d\n&quot;</span>, s, t, shift_and(s, t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="9-3-字典树结构"><a href="#9-3-字典树结构" class="headerlink" title="9.3 字典树结构"></a>9.3 字典树结构</h2><ol>
<li>也叫做：前缀索引树</li>
<li>把每个字符串按照前缀的顺序插入到树形结构中</li>
<li>字典树可以用于==字符串的排序==，时间复杂度 $O(n)$</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="comment">//字典树</span></span><br><span class="line">    <span class="keyword">int</span> flag;<span class="comment">//标记当前结点是否独立成词</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>[<span class="title">BASE</span>];</span><span class="comment">//假如只有26个字符串</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;next, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;next));<span class="comment">//将p的子树的每一个值都初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *p, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[ind] == <span class="literal">NULL</span>)  p-&gt;next[ind] = getNewNode();</span><br><span class="line">        p = p-&gt;next[ind];<span class="comment">//向下走动一个结点，继续向下插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        clear(root-&gt;next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root, <span class="keyword">int</span> k, <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    s[k] = <span class="number">0</span>;<span class="comment">//字符串的最后一位为0</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;flag) &#123;<span class="comment">//当前结点独立成词</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;<span class="comment">//遍历子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;<span class="comment">//当前子节点为空</span></span><br><span class="line">        <span class="comment">//当前子节点不为空继续向下遍历</span></span><br><span class="line">        s[k] = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">        output(root-&gt;next[i], k + <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        insert(root, str);</span><br><span class="line">    &#125;</span><br><span class="line">    output(root, <span class="number">0</span>, str);<span class="comment">//深度优先遍历，当前字典树所在结点地址root，所在层数0， 字符串</span></span><br><span class="line">    clear(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="9-4-海贼-OJ-282-最大异或对"><a href="#9-4-海贼-OJ-282-最大异或对" class="headerlink" title="9.4 海贼 OJ-282-最大异或对"></a>9.4 海贼 OJ-282-最大异或对</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%8811.52.03.png" alt="截屏2021-01-19 下午11.52.03"></p>
<ol>
<li>思考：如何使得异或结果尽可能大</li>
<li>结论：参与异或运算的两个数字，参与异或运算的每一位尽可能不同</li>
<li>问题转换为：确定一个数字的情况下，找到从高为到低位与当前数字尽量不同的另外一个数字</li>
<li>把每个数字看成一个二进制字符串，插入到字符串中，采用贪心策略进行选择</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 310000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 31</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Node *next[<span class="number">2</span>];</span><br><span class="line">&#125; tree[MAX_N * BASE + <span class="number">5</span>];<span class="comment">//假如 每个都是32位，所以需要flag</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;tree[cnt++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//插入x</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = !!(x &amp; (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">        <span class="comment">//归一化，将(1 &lt;&lt; i) 转换成0或1,(1 &lt;&lt; 1) == 2,!!(1 &amp; 2) = 0,!!(2 &amp; 2) = 1</span></span><br><span class="line">        <span class="comment">//ind = (x &amp; (1 &lt;&lt; i)) % 2;</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[ind] == <span class="literal">NULL</span>) root-&gt;next[ind] = getNewNode();</span><br><span class="line">        root = root-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//求和x所能形成的最大异或和</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = !(x &amp; (<span class="number">1</span> &lt;&lt; i));<span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[ind]) &#123;<span class="comment">//判断第i位异或结果能不能为1</span></span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i);<span class="comment">//将ans的第i为置为1</span></span><br><span class="line">            root = root-&gt;next[ind];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = root-&gt;next[!ind];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> val [MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    insert(root, a);</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">while</span> (n --) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        ans = max(query(root, a), ans);</span><br><span class="line">        insert(root, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="10-字符串匹配算法-下"><a href="#10-字符串匹配算法-下" class="headerlink" title="10 字符串匹配算法(下)"></a>10 字符串匹配算法(下)</h1><p>字典树是字典数据的另一种表现形式，本质字典树+AC自动机s</p>
<h2 id="10-1多模匹配问题"><a href="#10-1多模匹配问题" class="headerlink" title="10.1多模匹配问题"></a>10.1多模匹配问题</h2><ol>
<li>有多个模式串的匹配问题，就是多模匹配问题</li>
<li>Step1：多个模式串，建立成一棵字典树</li>
<li>Step2：和文本串的每一位对齐匹配，模拟暴力匹配算法的过程</li>
</ol>
<h2 id="10-2AC-自动机的思想"><a href="#10-2AC-自动机的思想" class="headerlink" title="10.2AC 自动机的思想"></a>10.2AC 自动机的思想</h2><ol>
<li>当匹配成功文本串中的 she 时，也就意味着后续一定会匹配成功 he</li>
<li>she 对应了字典树中的节点 P，he 对应了字典树中的节点Q</li>
<li>P 和 Q 就是等价匹配节点，如果从 P 引出一条边指向 Q，就可以加速匹配过程</li>
<li>在 P 下面查找节点的操作，等价于在 Q 下面查找节点的操作</li>
<li>这条等价关系边，通常在 AC 自动机上叫做 【Fail 指针】</li>
<li>AC 自动机 = Trie + Fail 指针(字典树+fai指针)</li>
<li>子节点的 Fail 指针是需要参照父节点的 Fail指针信息的，最简单的建立方式，就是采用【层序遍历】</li>
<li>没做优化的 AC 自动机，本质上是一个 NFA（非确定型有穷状态自动机）</li>
<li>通俗理解：根据当前状态 p，以及输入字符 c，无法通过一步操作确定状态</li>
<li>第二种理解：当前状态，并不代表唯一状态。(当前状态、当前状态的fail的状态，当前状态的fail的fail的状态)</li>
</ol>
<p><strong>AC 自动机优化：</strong>使用路径压缩思想，使状态转移时可以一步跳转到目标状态。</p>
<p>优化以后的 AC 自动机，更像 DFA（确定性有穷状态自动机）。</p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-24%20%E4%B8%8B%E5%8D%884.30.09.png" alt="截屏2021-01-24 下午4.30.09"></p>
<h2 id="10-3代码实现"><a href="#10-3代码实现" class="headerlink" title="10.3代码实现"></a>10.3代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;<span class="comment">//是否独立成词，1是，0不是</span></span><br><span class="line">    <span class="keyword">int</span> tag[BASE];<span class="comment">//记录每一条边是否被优化过：1字典树中的边，0：ac自动机中的边</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>[<span class="title">BASE</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">fail</span>;</span><span class="comment">//等价关系指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> node_cnt = <span class="number">0</span>;<span class="comment">//记录当前环境一共有多少个节点</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node_cnt += <span class="number">1</span>;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;next, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;next));</span><br><span class="line">    p-&gt;fail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *root, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;<span class="comment">//以字典树的形式插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[ind] == <span class="literal">NULL</span>) root-&gt;next[ind] = getNewNode();<span class="comment">//要插入的新节点为空</span></span><br><span class="line">        root-&gt;tag[ind] = <span class="number">1</span>;</span><br><span class="line">        root = root-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    root-&gt;str = strdup(str);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_ac</span><span class="params">(Node *root)</span> </span>&#123;<span class="comment">//建立ac自动机</span></span><br><span class="line">    <span class="comment">//用层序遍历的方式遍历，建立fail指针,层序遍历使用队列</span></span><br><span class="line">    Node **q = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *) * (node_cnt + <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    root-&gt;fail = <span class="literal">NULL</span>;<span class="comment">//初始化根节点fail指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;<span class="comment">//初始化其他节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root-&gt;next[i] = root;<span class="comment">//根节点的next为空，默认指向根节点</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;next[i]-&gt;fail = root;<span class="comment">//根节点下面的第一层fail默认指向根节点</span></span><br><span class="line">        q[tail++] = root-&gt;next[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;<span class="comment">//当队列不为空</span></span><br><span class="line">        Node *p = q[head++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">            Node *c = p-&gt;next[i], *k = p-&gt;fail;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;<span class="comment">//当前节点没有子孩子</span></span><br><span class="line">                p-&gt;next[i] = k-&gt;next[i];<span class="comment">//没有子孩子，直接指向fail指向的节点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k &amp;&amp; k-&gt;next[i] == <span class="literal">NULL</span>) k = k-&gt;fail;<span class="comment">//fail不为空且没有子孩子则直接指向fail</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">NULL</span>) k = root;</span><br><span class="line">            <span class="keyword">if</span> (k-&gt;next[i]) k = k-&gt;next[i];<span class="comment">//k-&gt;next[i] != NULL,fail指向的节点那个节点和c指向的节点对应</span></span><br><span class="line">            c-&gt;fail = k;</span><br><span class="line">            q[tail++] = c;<span class="comment">//c节点压入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(Node *root, <span class="keyword">const</span> <span class="keyword">char</span> *text)</span> </span>&#123;<span class="comment">//AC自动机的匹配过程</span></span><br><span class="line">    Node *p = root;<span class="comment">//当前状态的位置</span></span><br><span class="line">    Node *q;<span class="comment">//下一次要跳转的状态</span></span><br><span class="line">  <span class="comment">// for (int i = 0; text[i]; i++) &#123;//遍历文本串的每一位</span></span><br><span class="line">    <span class="comment">//     int ind = text[i] - &#x27;a&#x27;;</span></span><br><span class="line">    <span class="comment">//      while (p &amp;&amp; p-&gt;next[ind] == NULL ) p = p-&gt;fail;//找不到文本串的内容，就通过fail指针向上跳</span></span><br><span class="line">    <span class="comment">//      if (p == NULL) p = root;;</span></span><br><span class="line">    <span class="comment">//      if (p-&gt;nex[ind]) p = p-&gt;ext[ind];</span></span><br><span class="line">    <span class="comment">//      q = p;</span></span><br><span class="line">    <span class="comment">//      while (q) &#123;//当前的是fail对应的指针独立成词</span></span><br><span class="line">    <span class="comment">//      if (q-&gt;flag == 1) printf(&quot;find : %s\n&quot;, q-&gt;str);//输出</span></span><br><span class="line">    <span class="comment">//          q = q-&gt;fail;</span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">    <span class="comment">//      if (q-&gt;flag == 1) printf(&quot;find : %s\n&quot;, q-&gt;str);//p所在的节点独立成词</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// 优化，将空节点指向fail</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; text[i]; i++) &#123;<span class="comment">//遍历文本串的每一位</span></span><br><span class="line">        <span class="keyword">int</span> ind = text[i] -<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        p = p-&gt;next[ind];</span><br><span class="line">        q = p;</span><br><span class="line">        <span class="keyword">while</span> (q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q-&gt;flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;find : %s\n&quot;</span>, q-&gt;str);</span><br><span class="line">            q = q-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;tag[i]) clear(root-&gt;next[i]);<span class="comment">//是字典树上的边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        insert(root, str);</span><br><span class="line">    &#125;</span><br><span class="line">    build_ac(root);<span class="comment">//建立AC自动机</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;build ac\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    match(root, str);<span class="comment">//匹配文本串</span></span><br><span class="line">    clear(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">say</span><br><span class="line">she</span><br><span class="line">shr</span><br><span class="line">he</span><br><span class="line">her</span><br><span class="line">sasherhs</span><br></pre></td></tr></table></figure>


<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">build ac</span><br><span class="line">find : she</span><br><span class="line">find : he</span><br><span class="line">find : he</span><br></pre></td></tr></table></figure>


<h2 id="10-4字符串统计"><a href="#10-4字符串统计" class="headerlink" title="10.4字符串统计"></a>10.4字符串统计</h2><p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-25%20%E4%B8%8B%E5%8D%885.01.20.png" alt="截屏2021-01-25 下午5.01.20"></p>
<p><img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-25%20%E4%B8%8B%E5%8D%885.01.42.png" alt="截屏2021-01-25 下午5.01.42"></p>
<ol>
<li><p>AC 自动机裸题</p>
</li>
<li><p>解题的关键，在于如何维护每一个单词的计数量</p>
</li>
<li><p>使用幼儿园必知必会的指针技巧维护的</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 20000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag, *cnt;<span class="comment">//是否独立成词,指针ans中的某个元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">26</span>], fail;<span class="comment">//26条边,英文单词有26个,存储单词所在数组的下标编号</span></span><br><span class="line">&#125; tree[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> que[MAX_N + <span class="number">5</span>], head, tail;<span class="comment">//队列</span></span><br><span class="line"><span class="keyword">int</span> *ans[MAX_N + <span class="number">5</span>];<span class="comment">//ans[i]:第i个单词出现的次数</span></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>, cnt = <span class="number">2</span>;<span class="comment">//根节点编号,当前可用节点编号</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100005</span>];<span class="comment">//文本串,即字符串 S,仅由小写字母组成，长度不超过 10^5,表示蒜头君看的文章</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNewNode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cnt++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;<span class="comment">//在字典树中插入单词</span></span><br><span class="line">    <span class="keyword">int</span> p = root;<span class="comment">//p指向根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = str[i] - <span class="string">&#x27;a&#x27;</span>;<span class="comment">//第i位所对应根的编号</span></span><br><span class="line">        <span class="keyword">if</span> (tree[p].next[ind] == <span class="number">0</span>) tree[p].next[ind] = getNewNode();<span class="comment">//p节点的第ind条边</span></span><br><span class="line">        p = tree[p].next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    tree[p].flag = <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (tree[p].cnt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tree[p].cnt = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        tree[p].cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;<span class="comment">//建立fail指针</span></span><br><span class="line">    <span class="comment">//初始化队列</span></span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    tree[root].fail = <span class="number">0</span>;<span class="comment">//初始化根节点的fail指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;<span class="comment">//初始化根节点的子孩子</span></span><br><span class="line">        <span class="keyword">if</span> (tree[root].next[i] == <span class="number">0</span>) &#123;<span class="comment">//没有第i个子孩子，直接指向根节点</span></span><br><span class="line">            tree[root].next[i] = root;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[tree[root].next[i]].fail = root;<span class="comment">//根节点的第i个子孩子的fail指针</span></span><br><span class="line">        que[tail++] = tree[root].next[i];<span class="comment">//入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> p = que[head++];<span class="comment">//取出当前节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;<span class="comment">//扫描当前节点的子孩子，建立fail指针</span></span><br><span class="line">            <span class="keyword">int</span> c = tree[p].next[i], k = tree[p].fail;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                tree[p].next[i] = tree[k].next[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            k = tree[k].next[i];</span><br><span class="line">            tree[c].fail = k;</span><br><span class="line">            que[tail++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = root;<span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = str[i] - <span class="string">&#x27;a&#x27;</span>, q;</span><br><span class="line">        p = tree[p].next[ind];</span><br><span class="line">        q = p;</span><br><span class="line">        <span class="keyword">while</span> (q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[q].flag) &#123;<span class="comment">//q节点独立成词</span></span><br><span class="line">                (*tree[q].cnt) += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q = tree[q].fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//第一行输入一个整数 n（10001≤n≤1000），表示蒜头君学习的 n 个单词。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//接下来 n 行，每行输入一个字符串，仅由小写字母组成，长度不超过 20。</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        ans[i] = insert(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);<span class="comment">//文本串，输入一个字符串 S，仅由小写字母组成，长度不超过 10^5，表示蒜头君看的文章。</span></span><br><span class="line">    build();</span><br><span class="line">    match(str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, i, *ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>














<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="0-END"><a href="#0-END" class="headerlink" title="0.END"></a>0.END</h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://guziqiu.cn/2020/12/22/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E4%B8%8B/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95/" rel="tag">面试笔试算法</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/12/22/03.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            基础数据结构
          
        </div>
      </a>
    
    
      <a href="/2020/12/22/04.%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">高级数据结构</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021
        <i class="ri-heart-fill heart_icon"></i> guziqiu
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.jpeg" alt="古子秋"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>